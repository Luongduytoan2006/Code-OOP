================================================================================
                    T√ÄI LI·ªÜU √îN T·∫¨P OOP - GI·ªÆA K√å
        INHERITANCE + OPERATOR OVERLOADING (T·ªîNG H·ª¢P)
================================================================================

M·ª§C L·ª§C:
1. INHERITANCE (K·∫æ TH·ª™A)
2. CONSTRUCTOR & DESTRUCTOR ORDER
3. VIRTUAL FUNCTIONS & POLYMORPHISM
4. OPERATOR OVERLOADING V·ªöI INHERITANCE
5. STATIC MEMBERS
6. TYPE CONVERSION
7. C√ÅC L·ªñI TH∆Ø·ªúNG G·∫∂P
8. TIPS & TRICKS

================================================================================
1. INHERITANCE (K·∫æ TH·ª™A)
================================================================================

1.1. KH√ÅI NI·ªÜM C∆† B·∫¢N
----------------------
Inheritance cho ph√©p class con k·∫ø th·ª´a properties v√† methods t·ª´ class cha.

C√ö PH√ÅP:
    class Base {
    protected:
        int value;
    public:
        Base(int v) : value(v) {}
        void show() { cout << value; }
    };
    
    class Derived : public Base {
    public:
        Derived(int v) : Base(v) {}  // G·ªçi constructor cha
    };

LO·∫†I K·∫æ TH·ª™A:
- public: public ‚Üí public, protected ‚Üí protected
- protected: public ‚Üí protected, protected ‚Üí protected
- private: public ‚Üí private, protected ‚Üí private

1.2. SINGLE INHERITANCE
-----------------------
V√ç D·ª§ T·ª™ TEST:

    class Person {
    protected:
        string name;
        int age;
    public:
        Person(string n, int a) : name(n), age(a) {}
        void display() {
            cout << name << " " << age;
        }
    };
    
    class Student : public Person {
        int studentID;
    public:
        Student(string n, int a, int id) 
            : Person(n, a), studentID(id) {}
        
        void show() {
            display();  // G·ªçi method c·ªßa cha
            cout << " " << studentID;
        }
    };

ƒê·∫∂C ƒêI·ªÇM:
‚úì Class con k·∫ø th·ª´a T·∫§T C·∫¢ members c·ªßa cha
‚úì C√≥ quy·ªÅn truy c·∫≠p public v√† protected (kh√¥ng ph·∫£i private)
‚úì C√≥ th·ªÉ override methods c·ªßa cha

1.3. MULTIPLE INHERITANCE
--------------------------
V√ç D·ª§ T·ª™ TEST:

    class A {
    protected:
        int a;
    public:
        A(int x) : a(x) { cout << "A"; }
        ~A() { cout << "~A"; }
    };
    
    class B {
    protected:
        int b;
    public:
        B(int x) : b(x) { cout << "B"; }
        ~B() { cout << "~B"; }
    };
    
    class C : public A, public B {
        int c;
    public:
        C(int x, int y, int z) : A(x), B(y), c(z) {
            cout << "C";
        }
        ~C() { cout << "~C"; }
    };
    
    int main() {
        C obj(1, 2, 3);
        // Output: ABC
        // Destructor: ~C~B~A (reverse order)
    }

TH·ª® T·ª∞:
- Constructor: Theo th·ª© t·ª± khai b√°o base classes (A, B, C)
- Destructor: Ng∆∞·ª£c l·∫°i (~C, ~B, ~A)

1.4. DIAMOND PROBLEM
--------------------
V√ç D·ª§:
    class Base {
    public:
        int value;
    };
    
    class A : public Base {};
    class B : public Base {};
    
    class C : public A, public B {
    public:
        void func() {
            // value;  // AMBIGUOUS! A::value hay B::value?
            A::value = 10;  // Ph·∫£i ch·ªâ ƒë·ªãnh r√µ
            B::value = 20;
        }
    };

GI·∫¢I PH√ÅP: Virtual Inheritance
    class A : virtual public Base {};
    class B : virtual public Base {};
    
    class C : public A, public B {
        // Ch·ªâ c√≥ 1 copy c·ªßa Base
    };

================================================================================
2. CONSTRUCTOR & DESTRUCTOR ORDER
================================================================================

2.1. CONSTRUCTOR ORDER
----------------------
V√ç D·ª§ T·ª™ TEST (test.cpp):

    class Base {
    public:
        Base() { cout << "Base"; }
    };
    
    class Derived : public Base {
    public:
        Derived() { cout << "Derived"; }
    };
    
    int main() {
        Derived d;
        // Output: BaseDerived
    }

TH·ª® T·ª∞:
1. Base class constructor
2. Member objects constructor
3. Derived class constructor

2.2. DESTRUCTOR ORDER
---------------------
V√ç D·ª§ T·ª™ TEST (test2.cpp):

    class Base {
    public:
        ~Base() { cout << "~Base"; }
    };
    
    class Derived : public Base {
    public:
        ~Derived() { cout << "~Derived"; }
    };
    
    int main() {
        Derived d;
        // Output khi k·∫øt th√∫c: ~Derived~Base
    }

TH·ª® T·ª∞:
1. Derived class destructor
2. Member objects destructor
3. Base class destructor

QUAN TR·ªåNG: NG∆Ø·ª¢C L·∫†I v·ªõi constructor!

2.3. VIRTUAL DESTRUCTOR
-----------------------
V√ç D·ª§ T·ª™ TEST (test3.cpp):

    class Base {
    public:
        virtual ~Base() { cout << "~Base"; }
    };
    
    class Derived : public Base {
    public:
        ~Derived() { cout << "~Derived"; }
    };
    
    int main() {
        Base* ptr = new Derived;
        delete ptr;
        // V·ªõi virtual: ~Derived~Base
        // Kh√¥ng virtual: CH·ªà ~Base (MEMORY LEAK!)
    }

QUY T·∫ÆC V√ÄNG:
‚úì N·∫øu class c√≥ virtual function ‚Üí PH·∫¢I c√≥ virtual destructor
‚úì N·∫øu class ƒë∆∞·ª£c d√πng l√†m base class ‚Üí N√™n c√≥ virtual destructor

2.4. MEMBER INITIALIZATION LIST
--------------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
        int x;
    public:
        Base(int val) : x(val) {
            cout << "Base(" << x << ")";
        }
    };
    
    class Derived : public Base {
        int y;
    public:
        Derived(int a, int b) : Base(a), y(b) {
            cout << "Derived(" << y << ")";
        }
    };
    
    int main() {
        Derived d(10, 20);
        // Output: Base(10)Derived(20)
    }

TH·ª® T·ª∞ KH·ªûI T·∫†O:
1. Base class (theo th·ª© t·ª± khai b√°o)
2. Member variables (theo th·ª© t·ª± khai b√°o trong class)
3. Constructor body

================================================================================
3. VIRTUAL FUNCTIONS & POLYMORPHISM
================================================================================

3.1. VIRTUAL FUNCTION
---------------------
V√ç D·ª§ T·ª™ TEST (test4.cpp):

    class Animal {
    public:
        virtual void sound() {
            cout << "Animal sound";
        }
    };
    
    class Dog : public Animal {
    public:
        void sound() override {  // Override virtual function
            cout << "Woof";
        }
    };
    
    int main() {
        Animal* ptr = new Dog;
        ptr->sound();  // "Woof" (dynamic binding)
        
        Animal& ref = Dog();
        ref.sound();   // "Woof"
        
        delete ptr;
    }

ƒê·∫∂C ƒêI·ªÇM:
‚úì Dynamic binding (runtime polymorphism)
‚úì G·ªçi function c·ªßa derived class qua base pointer/reference
‚úì D√πng override ƒë·ªÉ ƒë·∫£m b·∫£o ƒë√∫ng signature

3.2. PURE VIRTUAL FUNCTION
---------------------------
V√ç D·ª§:
    class Shape {
    public:
        virtual double area() = 0;  // Pure virtual (abstract)
        virtual ~Shape() {}
    };
    
    class Circle : public Shape {
        double radius;
    public:
        double area() override {
            return 3.14 * radius * radius;
        }
    };
    
    int main() {
        // Shape s;  // ERROR! Cannot instantiate abstract class
        Shape* ptr = new Circle();  // OK
    }

ABSTRACT CLASS:
- C√≥ √≠t nh·∫•t 1 pure virtual function
- Kh√¥ng th·ªÉ t·∫°o object tr·ª±c ti·∫øp
- D√πng l√†m interface

3.3. VIRTUAL TABLE (VTABLE)
----------------------------
C∆° ch·∫ø ho·∫°t ƒë·ªông:
1. Compiler t·∫°o vtable cho m·ªói class c√≥ virtual function
2. M·ªói object c√≥ vptr tr·ªè ƒë·∫øn vtable
3. Khi g·ªçi virtual function ‚Üí lookup trong vtable

OVERHEAD:
- Memory: vptr trong m·ªói object (4/8 bytes)
- Performance: Indirect function call

================================================================================
4. OPERATOR OVERLOADING V·ªöI INHERITANCE
================================================================================

4.1. ARITHMETIC OPERATORS
--------------------------
V√ç D·ª§ T·ª™ TEST:

    class Complex {
    protected:
        double real, imag;
    public:
        Complex(double r = 0, double i = 0) : real(r), imag(i) {}
        
        // operator+ as member function
        Complex operator+(const Complex& other) const {
            return Complex(real + other.real, imag + other.imag);
        }
        
        // operator+= 
        Complex& operator+=(const Complex& other) {
            real += other.real;
            imag += other.imag;
            return *this;
        }
    };
    
    class ExtendedComplex : public Complex {
        string name;
    public:
        ExtendedComplex(double r, double i, string n) 
            : Complex(r, i), name(n) {}
    };

L∆ØU √ù:
- Operators ƒë∆∞·ª£c k·∫ø th·ª´a NH∆ØNG return type v·∫´n l√† Base
- C√≥ th·ªÉ c·∫ßn override ƒë·ªÉ return Derived type

4.2. COMPARISON OPERATORS
--------------------------
V√ç D·ª§ T·ª™ TEST:

    class Point {
    protected:
        int x, y;
    public:
        Point(int a, int b) : x(a), y(b) {}
        
        bool operator==(const Point& other) const {
            return x == other.x && y == other.y;
        }
        
        bool operator<(const Point& other) const {
            return (x*x + y*y) < (other.x*other.x + other.y*other.y);
        }
    };
    
    class Point3D : public Point {
        int z;
    public:
        Point3D(int a, int b, int c) : Point(a, b), z(c) {}
        
        bool operator==(const Point3D& other) const {
            return Point::operator==(other) && z == other.z;
        }
    };

PATTERN:
‚úì G·ªçi base class operator
‚úì Th√™m logic cho derived members

4.3. STREAM OPERATORS
----------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    protected:
        int value;
    public:
        Base(int v) : value(v) {}
        
        friend ostream& operator<<(ostream& os, const Base& obj) {
            return os << obj.value;
        }
    };
    
    class Derived : public Base {
        int extra;
    public:
        Derived(int v, int e) : Base(v), extra(e) {}
        
        friend ostream& operator<<(ostream& os, const Derived& obj) {
            // Kh√¥ng th·ªÉ g·ªçi Base::operator<< tr·ª±c ti·∫øp v·ªõi friend
            os << static_cast<const Base&>(obj);  // Cast to base
            return os << " " << obj.extra;
        }
    };

L∆ØU √ù:
- Friend function KH√îNG ƒë∆∞·ª£c k·∫ø th·ª´a
- Ph·∫£i override cho derived class
- C√≥ th·ªÉ cast to base ƒë·ªÉ reuse logic

4.4. ASSIGNMENT OPERATOR V·ªöI INHERITANCE
-----------------------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    protected:
        int* data;
    public:
        Base(int val) {
            data = new int(val);
        }
        
        Base& operator=(const Base& other) {
            if (this != &other) {
                delete data;
                data = new int(*other.data);
            }
            return *this;
        }
        
        virtual ~Base() {
            delete data;
        }
    };
    
    class Derived : public Base {
        int* extra;
    public:
        Derived(int v, int e) : Base(v) {
            extra = new int(e);
        }
        
        Derived& operator=(const Derived& other) {
            if (this != &other) {
                Base::operator=(other);  // G·ªçi base assignment
                delete extra;
                extra = new int(*other.extra);
            }
            return *this;
        }
        
        ~Derived() {
            delete extra;
        }
    };

CHECKLIST:
‚ñ° Self-assignment check
‚ñ° G·ªçi base class operator=
‚ñ° Deep copy cho pointers
‚ñ° Return *this

4.5. TYPE CONVERSION OPERATORS
-------------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
        int value;
    public:
        Base(int v) : value(v) {}
        
        // Implicit conversion to int
        operator int() const {
            return value;
        }
    };
    
    class Derived : public Base {
    public:
        Derived(int v) : Base(v) {}
        
        // Conversion to double
        operator double() const {
            int baseValue = Base::operator int();
            return baseValue * 1.5;
        }
    };
    
    int main() {
        Derived d(10);
        int x = d;      // 10
        double y = d;   // 15.0
    }

================================================================================
5. STATIC MEMBERS
================================================================================

5.1. STATIC DATA MEMBER V·ªöI INHERITANCE
----------------------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    protected:
        static int count;
    public:
        Base() { ++count; }
        static int getCount() { return count; }
    };
    
    int Base::count = 0;  // Definition
    
    class Derived : public Base {
    public:
        Derived() : Base() {}
    };
    
    int main() {
        Base b1, b2;
        Derived d1;
        cout << Base::count;  // 3 (shared!)
    }

ƒê·∫∂C ƒêI·ªÇM:
‚úì Static members ƒë∆∞·ª£c SHARED gi·ªØa base v√† derived
‚úì Ch·ªâ c√≥ 1 copy d√π c√≥ bao nhi√™u derived classes

5.2. STATIC MEMBER FUNCTION
----------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
        static int value;
    public:
        static void setValue(int v) {
            value = v;
        }
        static int getValue() {
            return value;
        }
    };
    
    int Base::value = 0;
    
    class Derived : public Base {
    public:
        static void display() {
            cout << getValue();  // G·ªçi static function c·ªßa base
        }
    };
    
    int main() {
        Base::setValue(10);
        Derived::display();  // 10
    }

5.3. STATIC LOCAL VARIABLES
----------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    public:
        void func() {
            static int counter = 0;  // Kh·ªüi t·∫°o 1 l·∫ßn
            cout << ++counter << " ";
        }
    };
    
    int main() {
        Base b1, b2;
        b1.func();  // 1
        b2.func();  // 2
        b1.func();  // 3
    }

ƒê·∫∂C ƒêI·ªÇM:
‚úì Kh·ªüi t·∫°o 1 l·∫ßn duy nh·∫•t
‚úì Gi·ªØ gi√° tr·ªã gi·ªØa c√°c l·∫ßn g·ªçi
‚úì Scope trong function, lifetime nh∆∞ global

================================================================================
6. TYPE CONVERSION
================================================================================

6.1. IMPLICIT CONVERSION
------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
        int value;
    public:
        Base(int v) : value(v) {}  // Converting constructor
    };
    
    class Derived : public Base {
    public:
        Derived(int v) : Base(v) {}
    };
    
    void func(Base obj) {
        // ...
    }
    
    int main() {
        func(10);        // int ‚Üí Base (implicit)
        func(Derived(5)); // Derived ‚Üí Base (slicing)
    }

6.2. EXPLICIT CONVERSION
------------------------
V√ç D·ª§:
    class Base {
    public:
        explicit Base(int v) {}  // NgƒÉn implicit conversion
    };
    
    int main() {
        // Base b = 10;  // ERROR!
        Base b(10);      // OK
        Base b2 = Base(10);  // OK
    }

D√ôNG explicit KHI:
- Constructor c√≥ 1 tham s·ªë
- Mu·ªën tr√°nh unexpected conversions

6.3. UPCASTING & DOWNCASTING
-----------------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    public:
        virtual void show() { cout << "Base"; }
        virtual ~Base() {}
    };
    
    class Derived : public Base {
    public:
        void show() override { cout << "Derived"; }
        void derivedOnly() { cout << "Only in Derived"; }
    };
    
    int main() {
        // UPCASTING (an to√†n, t·ª± ƒë·ªông)
        Derived d;
        Base* basePtr = &d;  // Derived* ‚Üí Base*
        basePtr->show();     // "Derived" (polymorphism)
        
        // DOWNCASTING (c·∫ßn c·∫©n th·∫≠n)
        Base* bPtr = new Derived;
        Derived* dPtr = dynamic_cast<Derived*>(bPtr);
        if (dPtr) {
            dPtr->derivedOnly();  // Safe
        }
        
        delete bPtr;
    }

LO·∫†I CAST:
- static_cast: Compile-time, kh√¥ng check
- dynamic_cast: Runtime check, c·∫ßn virtual function
- const_cast: Remove const
- reinterpret_cast: Low-level cast

6.4. SLICING PROBLEM
--------------------
V√ç D·ª§ T·ª™ TEST:

    class Base {
    public:
        int x;
        Base(int v) : x(v) {}
    };
    
    class Derived : public Base {
    public:
        int y;
        Derived(int a, int b) : Base(a), y(b) {}
    };
    
    void func(Base obj) {  // Pass by VALUE
        cout << obj.x;
    }
    
    int main() {
        Derived d(10, 20);
        func(d);  // SLICING! y b·ªã m·∫•t
    }

GI·∫¢I PH√ÅP:
‚úì Pass by reference: void func(Base& obj)
‚úì Pass by pointer: void func(Base* obj)

================================================================================
7. C√ÅC L·ªñI TH∆Ø·ªúNG G·∫∂P
================================================================================

7.1. QU√äN VIRTUAL DESTRUCTOR
-----------------------------
‚ùå SAI:
    class Base {
    public:
        ~Base() { cout << "~Base"; }  // Kh√¥ng virtual
    };
    
    class Derived : public Base {
        int* data;
    public:
        Derived() { data = new int[100]; }
        ~Derived() { delete[] data; }  // Kh√¥ng ƒë∆∞·ª£c g·ªçi!
    };
    
    int main() {
        Base* ptr = new Derived;
        delete ptr;  // MEMORY LEAK! Ch·ªâ g·ªçi ~Base
    }

‚úì ƒê√öNG:
    class Base {
    public:
        virtual ~Base() { cout << "~Base"; }
    };

7.2. OPERATOR= KH√îNG L√Ä FRIEND
-------------------------------
‚ùå SAI:
    class Base {
        friend Base& operator=(Base& lhs, const Base& rhs) {
            // operator= PH·∫¢I l√† member function!
        }
    };

‚úì ƒê√öNG:
    class Base {
        Base& operator=(const Base& other) {
            if (this != &other) {
                // Assignment logic
            }
            return *this;
        }
    };

7.3. KH√îNG G·ªåI BASE CONSTRUCTOR
--------------------------------
‚ùå SAI:
    class Base {
        int x;
    public:
        Base(int v) : x(v) {}
    };
    
    class Derived : public Base {
        int y;
    public:
        Derived(int a, int b) : y(b) {  // Kh√¥ng g·ªçi Base(a)
            // ERROR! Base kh√¥ng c√≥ default constructor
        }
    };

‚úì ƒê√öNG:
    class Derived : public Base {
        int y;
    public:
        Derived(int a, int b) : Base(a), y(b) {}
    };

7.4. HIDING BASE CLASS FUNCTIONS
---------------------------------
‚ùå NH·∫¶M L·∫™N:
    class Base {
    public:
        void func(int x) { cout << x; }
    };
    
    class Derived : public Base {
    public:
        void func(double x) { cout << x; }  // HIDE Base::func
    };
    
    int main() {
        Derived d;
        d.func(10);  // G·ªçi Derived::func(double), KO ph·∫£i Base::func(int)
    }

‚úì S·ª¨A:
    class Derived : public Base {
    public:
        using Base::func;  // Expose base function
        void func(double x) { cout << x; }
    };

7.5. SLICING V·ªöI PASS BY VALUE
-------------------------------
‚ùå SAI:
    void process(Base obj) {  // Pass by value
        obj.virtualFunc();  // Ch·ªâ g·ªçi Base version
    }
    
    int main() {
        Derived d;
        process(d);  // Slicing! M·∫•t derived part
    }

‚úì ƒê√öNG:
    void process(Base& obj) {  // Pass by reference
        obj.virtualFunc();  // Polymorphism works
    }

7.6. STATIC MEMBER INITIALIZATION
----------------------------------
‚ùå SAI:
    class Base {
        static int count = 0;  // ERROR! Kh√¥ng init trong class
    };

‚úì ƒê√öNG:
    class Base {
        static int count;
    };
    
    int Base::count = 0;  // Init ngo√†i class

7.7. MULTIPLE INHERITANCE AMBIGUITY
------------------------------------
‚ùå SAI:
    class A {
    public:
        void func() { cout << "A"; }
    };
    
    class B {
    public:
        void func() { cout << "B"; }
    };
    
    class C : public A, public B {
    public:
        void test() {
            func();  // AMBIGUOUS! A::func hay B::func?
        }
    };

‚úì ƒê√öNG:
    void test() {
        A::func();  // Ch·ªâ ƒë·ªãnh r√µ r√†ng
        B::func();
    }

================================================================================
8. TIPS & TRICKS
================================================================================

8.1. INHERITANCE CHECKLIST
---------------------------
‚ñ° Base class c√≥ virtual destructor?
‚ñ° Constructor g·ªçi base constructor?
‚ñ° Virtual functions c·∫ßn override?
‚ñ° Operator= g·ªçi base operator=?
‚ñ° Tr√°nh slicing (d√πng reference/pointer)?

8.2. POLYMORPHISM CHECKLIST
----------------------------
‚ñ° Function c·∫ßn virtual?
‚ñ° Destructor c·∫ßn virtual?
‚ñ° Override keyword d√πng ƒë√∫ng?
‚ñ° Pure virtual cho abstract class?
‚ñ° Dynamic binding qua pointer/reference?

8.3. OPERATOR OVERLOADING CHECKLIST
------------------------------------
‚ñ° operator= l√† member function?
‚ñ° operator<< l√† friend function?
‚ñ° Return type ƒë√∫ng?
‚ñ° Const correctness?
‚ñ° Self-assignment check?

8.4. BEST PRACTICES
-------------------
‚úì Virtual destructor cho base class
‚úì Pass by reference ƒë·ªÉ tr√°nh slicing
‚úì Use override keyword
‚úì Prefer composition over inheritance
‚úì Follow Liskov Substitution Principle

8.5. COMMON PATTERNS
--------------------

PATTERN 1: Factory Pattern
    class Shape {
    public:
        virtual void draw() = 0;
        virtual ~Shape() {}
    };
    
    class ShapeFactory {
    public:
        static Shape* create(string type) {
            if (type == "circle") return new Circle();
            if (type == "square") return new Square();
            return nullptr;
        }
    };

PATTERN 2: Template Method
    class Algorithm {
    public:
        void execute() {
            step1();
            step2();  // Virtual
            step3();
        }
    protected:
        void step1() { /*...*/ }
        virtual void step2() = 0;  // Override in derived
        void step3() { /*...*/ }
    };

PATTERN 3: Interface Pattern
    class IDrawable {
    public:
        virtual void draw() = 0;
        virtual ~IDrawable() {}
    };
    
    class Circle : public IDrawable {
    public:
        void draw() override { /*...*/ }
    };

8.6. DEBUGGING TIPS
-------------------
‚Ä¢ Th√™m debug output trong constructor/destructor
‚Ä¢ Check vtable v·ªõi typeid
‚Ä¢ Use dynamic_cast ƒë·ªÉ verify types
‚Ä¢ Valgrind/AddressSanitizer cho memory issues

V√ç D·ª§ DEBUG:
    class Base {
    public:
        Base() { cout << "Base() at " << this << endl; }
        virtual ~Base() { cout << "~Base() at " << this << endl; }
    };

8.7. PERFORMANCE TIPS
---------------------
‚úì Virtual functions c√≥ overhead nh·ªè
‚úì Inline functions kh√¥ng th·ªÉ virtual
‚úì Template th∆∞·ªùng nhanh h∆°n virtual (compile-time)
‚úì Avoid deep inheritance hierarchies

8.8. DESIGN GUIDELINES
----------------------
‚Ä¢ Inheritance for IS-A relationship
‚Ä¢ Composition for HAS-A relationship
‚Ä¢ Interface segregation (pure virtual)
‚Ä¢ Single Responsibility Principle

8.9. QUICK REFERENCE
--------------------
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FEATURE           ‚îÇ BINDING  ‚îÇ WHEN        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Normal function   ‚îÇ Static   ‚îÇ Compile     ‚îÇ
‚îÇ Virtual function  ‚îÇ Dynamic  ‚îÇ Runtime     ‚îÇ
‚îÇ Operator          ‚îÇ Static   ‚îÇ Compile     ‚îÇ
‚îÇ Virtual operator  ‚îÇ Dynamic  ‚îÇ Runtime     ‚îÇ
‚îÇ Constructor       ‚îÇ N/A      ‚îÇ Object init ‚îÇ
‚îÇ Destructor        ‚îÇ Dynamic* ‚îÇ Object del  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
* If virtual

8.10. COMPILATION & TESTING
----------------------------
    // Compile v·ªõi warnings
    g++ -Wall -Wextra -std=c++17 file.cpp
    
    // Check vtable
    g++ -fdump-class-hierarchy file.cpp
    
    // Memory check
    valgrind --leak-check=full ./a.out
    
    // Runtime type info
    g++ -frtti file.cpp

================================================================================
K·∫æT LU·∫¨N
================================================================================

GI·ªÆA K√å T·∫¨P TRUNG V√ÄO:
‚úÖ Inheritance (40%)
‚úÖ Constructor/Destructor Order (20%)
‚úÖ Operator Overloading (25%)
‚úÖ Virtual Functions (10%)
‚úÖ Static Members (5%)

ƒêI·ªÇM THEN CH·ªêT C·∫¶N NH·ªö:
1. Virtual destructor khi c√≥ inheritance
2. Constructor order: Base ‚Üí Member ‚Üí Derived
3. Destructor order: Ng∆∞·ª£c l·∫°i
4. operator= PH·∫¢I l√† member function
5. Pass by reference ƒë·ªÉ tr√°nh slicing

C√ÅC L·ªñI TH∆Ø·ªúNG G·∫∂P:
- Qu√™n virtual destructor ‚Üí Memory leak
- Kh√¥ng g·ªçi base constructor ‚Üí Compile error
- operator= l√† friend ‚Üí Compile error
- Pass by value ‚Üí Slicing
- Ambiguity trong multiple inheritance

K·∫æT H·ª¢P KI·∫æN TH·ª®C:
- Inheritance + Polymorphism
- Operator overloading + Inheritance
- Virtual functions + Dynamic binding
- Static members + Inheritance

LUY·ªÜN T·∫¨P:
- Vi·∫øt class hierarchy v·ªõi virtual functions
- Implement operators cho derived classes
- Debug constructor/destructor order
- Practice upcasting/downcasting

BEST PRACTICES:
- Virtual destructor cho base class
- Override keyword cho virtual functions
- Pass by reference/pointer
- Self-assignment check trong operator=
- Const correctness everywhere

CH√öC B·∫†N √îN T·∫¨P T·ªêT V√Ä ƒê·∫†T ƒêI·ªÇM CAO! üöÄ
