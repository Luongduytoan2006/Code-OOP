================================================================================
                    TÃ€I LIá»†U Ã”N Táº¬P OOP - Tá»”NG Há»¢P
              C++ OBJECT-ORIENTED PROGRAMMING - COMPLETE GUIDE
================================================================================

                        TOÃ€N Bá»˜ KIáº¾N THá»¨C OOP C++
              Tá»•ng há»£p tá»« Test 1, Test 2, Giá»¯a KÃ¬, vÃ  Test 3

================================================================================

Má»¤C Lá»¤C Tá»”NG QUAN
=================
PHáº¦N I: C++ FUNDAMENTALS (Test 1)
    1. References & Pointers
    2. sizeof Operator
    3. Default Parameters
    4. Pass By Value/Reference/Pointer
    5. Type Conversion

PHáº¦N II: OPERATOR OVERLOADING (Test 2)
    6. Operator Overloading Basics
    7. Member vs Friend Functions
    8. Special Operators
    9. Function Overloading
    10. const-correctness

PHáº¦N III: INHERITANCE & POLYMORPHISM (Giá»¯a KÃ¬ + Test 3)
    11. Single & Multiple Inheritance
    12. Constructor/Destructor Order
    13. Virtual Functions
    14. Abstract Classes & Pure Virtual
    15. Polymorphism & Dynamic Binding

PHáº¦N IV: ADVANCED CONCEPTS (Test 3)
    16. Templates (Function & Class)
    17. Exception Handling
    18. Copy Control & Rule of Three
    19. Static Polymorphism
    20. Design Patterns

================================================================================
                            PHáº¦N I: C++ FUNDAMENTALS
================================================================================

CHAPTER 1: REFERENCES & POINTERS
=================================

1.1. REFERENCES (THAM CHIáº¾U)
----------------------------
Reference lÃ  ALIAS cá»§a biáº¿n Ä‘Ã£ tá»“n táº¡i.

SYNTAX:
    int x = 10;
    int& ref = x;  // ref lÃ  bÃ­ danh cá»§a x
    ref = 20;      // x cÅ©ng thÃ nh 20

Äáº¶C ÄIá»‚M:
âœ“ PHáº¢I khá»Ÿi táº¡o khi khai bÃ¡o
âœ“ KHÃ”NG THá»‚ re-bind (thay Ä‘á»•i target)
âœ“ KHÃ”NG null reference

1.2. POINTERS (CON TRá»)
-----------------------
Pointer lÆ°u Ä‘á»‹a chá»‰ cá»§a biáº¿n.

SYNTAX:
    int x = 10;
    int* ptr = &x;  // ptr lÆ°u Ä‘á»‹a chá»‰ x
    *ptr = 20;      // Thay Ä‘á»•i x qua pointer

Äáº¶C ÄIá»‚M:
âœ“ CÃ³ thá»ƒ nullptr
âœ“ CÃ³ thá»ƒ thay Ä‘á»•i target
âœ“ Pointer arithmetic

1.3. SO SÃNH REFERENCE VS POINTER
----------------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Äáº¶C ÄIá»‚M        â”‚ REFERENCE    â”‚ POINTER       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Khá»Ÿi táº¡o        â”‚ Báº¯t buá»™c     â”‚ KhÃ´ng báº¯t buá»™câ”‚
â”‚ Null            â”‚ KhÃ´ng thá»ƒ    â”‚ CÃ³ thá»ƒ        â”‚
â”‚ Re-assign       â”‚ KhÃ´ng thá»ƒ    â”‚ CÃ³ thá»ƒ        â”‚
â”‚ Syntax          â”‚ ÄÆ¡n giáº£n     â”‚ Phá»©c táº¡p      â”‚
â”‚ Overhead        â”‚ KhÃ´ng        â”‚ CÃ³            â”‚
â”‚ Use case        â”‚ Parameters   â”‚ Dynamic mem   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1.4. CONST REFERENCE
--------------------
    void print(const MyClass& obj);  // KhÃ´ng copy, khÃ´ng modify

Æ¯U ÄIá»‚M:
âœ“ KhÃ´ng copy (efficient)
âœ“ KhÃ´ng modify (safe)
âœ“ CÃ³ thá»ƒ bind vá»›i temporary

BEST PRACTICE:
â†’ DÃ¹ng const reference cho read-only parameters lá»›n

================================================================================

CHAPTER 2: SIZEOF OPERATOR
===========================

2.1. CÆ  Báº¢N
-----------
sizeof tráº£ vá» kÃ­ch thÆ°á»›c (bytes) cá»§a type/variable.

    sizeof(int)      // 4
    sizeof(double)   // 8
    sizeof(char)     // 1

2.2. QUAN TRá»ŒNG: SIZEOF KHÃ”NG CÃ“ SIDE EFFECTS
----------------------------------------------
    int x = 5;
    sizeof(x++);  // x++ KHÃ”NG Ä‘Æ°á»£c thá»±c hiá»‡n!
    cout << x;    // 5 (khÃ´ng Ä‘á»•i)

LÃ DO:
- sizeof lÃ  compile-time operator
- Chá»‰ tÃ­nh size, khÃ´ng evaluate expression

2.3. SIZEOF Vá»šI ARRAY
---------------------
    int arr[10];
    sizeof(arr)           // 40 (10 * 4)
    sizeof(arr) / sizeof(arr[0])  // 10 (length)

Cáº¢NH BÃO: ARRAY DECAY
    void func(int arr[]) {
        sizeof(arr);  // Size cá»§a POINTER, khÃ´ng pháº£i array!
    }

2.4. SIZEOF Vá»šI CLASS
---------------------
    class Example {
        char c;   // 1 byte
        int i;    // 4 bytes
        // Padding: 3 bytes
    };
    sizeof(Example) = 8  // CÃ³ alignment/padding

2.5. EMPTY CLASS
----------------
    class Empty {};
    sizeof(Empty) = 1  // Minimum 1 byte

================================================================================

CHAPTER 3: DEFAULT PARAMETERS
==============================

3.1. CÃš PHÃP
------------
    void func(int x, int y = 10, int z = 5);
    
    func(1);        // x=1, y=10, z=5
    func(1, 2);     // x=1, y=2, z=5
    func(1, 2, 3);  // x=1, y=2, z=3

3.2. QUY Táº®C VÃ€NG
-----------------
âœ“ Default parameters PHáº¢I á»Ÿ CUá»I
âŒ void func(int x = 1, int y);     // SAI!
âœ“ void func(int x, int y = 10);    // ÄÃšNG

âœ“ Chá»‰ khai bÃ¡o default trong DECLARATION
âœ“ KhÃ´ng thá»ƒ bá» qua parameter á»Ÿ giá»¯a

3.3. Vá»šI FUNCTION OVERLOADING
------------------------------
Cáº¢NH BÃO: AMBIGUITY
    void func(int x);
    void func(int x, int y = 10);
    
    func(5);  // COMPILE ERROR! Ambiguous

GIáº¢I PHÃP:
â†’ TrÃ¡nh dÃ¹ng default vá»›i overloaded functions

================================================================================

CHAPTER 4: PASS BY VALUE/REFERENCE/POINTER
===========================================

4.1. PASS BY VALUE
------------------
    void func(int x) { x = 10; }
    
    int a = 5;
    func(a);
    cout << a;  // 5 (khÃ´ng Ä‘á»•i)

Äáº¶C ÄIá»‚M:
- Táº¡o COPY
- KhÃ´ng áº£nh hÆ°á»Ÿng biáº¿n gá»‘c
- COSTLY vá»›i objects lá»›n

4.2. PASS BY REFERENCE
----------------------
    void func(int& x) { x = 10; }
    
    int a = 5;
    func(a);
    cout << a;  // 10 (Ä‘Ã£ Ä‘á»•i)

Äáº¶C ÄIá»‚M:
- KHÃ”NG copy
- Thay Ä‘á»•i biáº¿n gá»‘c
- Efficient

4.3. PASS BY POINTER
--------------------
    void func(int* ptr) { *ptr = 10; }
    
    int a = 5;
    func(&a);
    cout << a;  // 10

4.4. Báº¢NG QUYáº¾T Äá»ŠNH
--------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SCENARIO         â”‚ RECOMMENDED     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Small type       â”‚ By value        â”‚
â”‚ Large type       â”‚ const reference â”‚
â”‚ Need modify      â”‚ Reference       â”‚
â”‚ Optional         â”‚ Pointer         â”‚
â”‚ Array            â”‚ Pointer + size  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4.5. CONST REFERENCE PATTERN
-----------------------------
    void print(const MyClass& obj) {
        // Read-only, no copy
    }

BEST PRACTICE:
â†’ Const reference cho read-only parameters

================================================================================

CHAPTER 5: TYPE CONVERSION
===========================

5.1. IMPLICIT CONVERSION
------------------------
    int x = 5;
    double y = x;  // int â†’ double (widening)
    
    double z = 3.14;
    int w = z;     // double â†’ int (narrowing)

5.2. TYPE PROMOTION
-------------------
    char c = 'A';  // ASCII 65
    int result = c + 1;  // char â†’ int, result = 66

HIERARCHY:
    char, short â†’ int â†’ long â†’ long long â†’ float â†’ double

5.3. EXPLICIT CAST
------------------
    double x = 3.14;
    
    // C-style
    int y = (int)x;
    
    // C++ style
    int z = static_cast<int>(x);

5.4. CAST OPERATORS
-------------------
- static_cast: Compile-time conversion
- dynamic_cast: Runtime type checking
- const_cast: Remove const
- reinterpret_cast: Low-level cast

================================================================================
                        PHáº¦N II: OPERATOR OVERLOADING
================================================================================

CHAPTER 6: OPERATOR OVERLOADING BASICS
=======================================

6.1. KHÃI NIá»†M
--------------
Operator overloading Ä‘á»‹nh nghÄ©a láº¡i toÃ¡n tá»­ cho user-defined types.

    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;  // operator+ overloaded

6.2. CÃš PHÃP: MEMBER FUNCTION
------------------------------
    class Complex {
    public:
        Complex operator+(const Complex& other) const {
            return Complex(R + other.R, I + other.I);
        }
    };
    
    // c3 = c1 + c2;
    // TÆ°Æ¡ng Ä‘Æ°Æ¡ng: c3 = c1.operator+(c2);

6.3. CÃš PHÃP: FRIEND FUNCTION
------------------------------
    class Complex {
        friend Complex operator+(const Complex& a, const Complex& b) {
            return Complex(a.R + b.R, a.I + b.I);
        }
    };
    
    // c3 = c1 + c2;
    // TÆ°Æ¡ng Ä‘Æ°Æ¡ng: c3 = operator+(c1, c2);

6.4. MEMBER VS FRIEND
---------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚ Member       â”‚ Friend         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Tham sá»‘      â”‚ 1 (right)    â”‚ 2 (both sides) â”‚
â”‚ this         â”‚ CÃ³           â”‚ KhÃ´ng          â”‚
â”‚ Symmetry     â”‚ Háº¡n cháº¿      â”‚ Linh hoáº¡t      â”‚
â”‚ Use case     â”‚ a op b       â”‚ op(a, b)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================

CHAPTER 7: MEMBER VS FRIEND FUNCTIONS
======================================

7.1. ARITHMETIC OPERATORS (+, -, *, /)
---------------------------------------
MEMBER FUNCTION:
    Complex operator+(const Complex& obj) const {
        return Complex(R + obj.R, I + obj.I);
    }

Äáº¶C ÄIá»‚M:
âœ“ Return by VALUE (new object)
âœ“ CONST member function
âœ“ Const reference parameter

7.2. COMPOUND ASSIGNMENT (+=, -=, *=, /=)
-----------------------------------------
    Exam& operator+=(const Exam& obj) {
        val += obj.val;
        return *this;  // Return reference
    }

Äáº¶C ÄIá»‚M:
âœ“ Return REFERENCE (*this)
âœ“ NON-CONST (thay Ä‘á»•i object)
âœ“ Cho phÃ©p chain: a += b += c

7.3. STREAM OPERATORS (<<, >>)
-------------------------------
PHáº¢I LÃ€ FRIEND:
    class Exam {
        friend ostream& operator<<(ostream& os, const Exam& obj) {
            return os << obj.val;
        }
        
        friend istream& operator>>(istream& is, Exam& obj) {
            return is >> obj.val;
        }
    };

Táº I SAO FRIEND?
- Left operand lÃ  stream (ostream/istream)
- KhÃ´ng thá»ƒ lÃ m member cá»§a Exam
- Cáº§n access private members

7.4. SUBSCRIPT OPERATOR ([])
----------------------------
PHáº¢I LÃ€ MEMBER:
    T& operator[](size_t index) {
        return data[index];  // Return reference
    }
    
    const T& operator[](size_t index) const {
        return data[index];
    }

Äáº¶C ÄIá»‚M:
âœ“ Return REFERENCE (Ä‘á»ƒ gÃ¡n Ä‘Æ°á»£c: arr[0] = 5)
âœ“ 2 versions: const vÃ  non-const
âœ“ MUST be member function

7.5. FUNCTION CALL OPERATOR (())
---------------------------------
    class Functor {
    public:
        int operator()(int x) const {
            return x * 2;
        }
    };
    
    Functor func;
    cout << func(5);  // 10

á»¨NG Dá»¤NG:
- Function objects (functors)
- STL algorithms
- Callbacks

7.6. ASSIGNMENT OPERATOR (=)
----------------------------
PHáº¢I LÃ€ MEMBER:
    Exam& operator=(const Exam& other) {
        if (this != &other) {  // Self-assignment check
            val = other.val;
        }
        return *this;
    }

CHECKLIST:
â–¡ Self-assignment check
â–¡ Return *this by reference
â–¡ Deep copy cho pointers
â–¡ MUST be member function

================================================================================

CHAPTER 8: SPECIAL OPERATORS
=============================

8.1. NEW & DELETE OPERATORS
----------------------------
    class Base {
    public:
        void* operator new(size_t size) {
            void* ptr = malloc(size);
            if (!ptr) throw bad_alloc();
            return ptr;
        }
        
        void operator delete(void* ptr) {
            free(ptr);
        }
    };

á»¨NG Dá»¤NG:
- Memory pool management
- Debug memory leaks
- Custom allocators

8.2. CONVERSION OPERATORS
--------------------------
    class Exam {
        int val;
    public:
        // Implicit conversion to int
        operator int() const {
            return val;
        }
        
        // Implicit conversion to double
        operator double() const {
            return static_cast<double>(val);
        }
    };
    
    Exam e(10);
    int x = e;      // Gá»i operator int()
    double y = e;   // Gá»i operator double()

8.3. COMPARISON OPERATORS
--------------------------
    bool operator==(const Exam& other) const {
        return val == other.val;
    }
    
    bool operator<(const Exam& other) const {
        return val < other.val;
    }
    
    // Implement cÃ¡c toÃ¡n tá»­ khÃ¡c báº±ng == vÃ  <
    bool operator!=(const Exam& other) const {
        return !(*this == other);
    }
    
    bool operator>(const Exam& other) const {
        return other < *this;
    }

PATTERN:
â†’ Implement == vÃ  <, derive cÃ¡c toÃ¡n tá»­ khÃ¡c

================================================================================

CHAPTER 9: FUNCTION OVERLOADING
================================

9.1. CÆ  Báº¢N
-----------
Function overloading: Nhiá»u hÃ m cÃ¹ng tÃªn, khÃ¡c tham sá»‘.

    int add(int a, int b);
    double add(double a, double b);
    int add(int a, int b, int c);

9.2. OVERLOAD RESOLUTION
------------------------
Compiler chá»n hÃ m theo:
1. Exact match
2. Type promotion (int â†’ long)
3. Type conversion (int â†’ double)

9.3. AMBIGUITY
--------------
    int Func(int a, int b);
    int Func(int a, int b, int c = 6);
    
    Func(2, 4);  // ERROR! Ambiguous

NGUYÃŠN NHÃ‚N:
- Default parameter táº¡o multiple matches
- Compiler khÃ´ng biáº¿t chá»n hÃ m nÃ o

GIáº¢I PHÃP:
â†’ TrÃ¡nh default parameters vá»›i overloaded functions

9.4. BEST PRACTICES
-------------------
âœ“ Overload khi functions lÃ m viá»‡c tÆ°Æ¡ng tá»±
âœ“ TrÃ¡nh ambiguity vá»›i default parameters
âœ“ DÃ¹ng different parameter counts/types
âŒ KhÃ´ng overload chá»‰ dá»±a vÃ o return type

================================================================================

CHAPTER 10: CONST-CORRECTNESS
==============================

10.1. CONST MEMBER FUNCTION
----------------------------
    class Exam {
        int val;
    public:
        int getVal() const {  // KhÃ´ng thay Ä‘á»•i object
            return val;
        }
        
        void setVal(int v) {  // Thay Ä‘á»•i object
            val = v;
        }
    };

QUY Táº®C:
â†’ HÃ m khÃ´ng thay Ä‘á»•i object â†’ const member function

10.2. CONST PARAMETERS
----------------------
    void print(const MyClass& obj) {
        // obj khÃ´ng thá»ƒ thay Ä‘á»•i
    }

Æ¯U ÄIá»‚M:
âœ“ KhÃ´ng copy (efficient)
âœ“ KhÃ´ng thay Ä‘á»•i (safe)
âœ“ Self-documenting code

10.3. CONST RETURN TYPE
-----------------------
    const MyClass& getMax(const MyClass& a, const MyClass& b) const {
        return (a > b) ? a : b;
    }

10.4. CONST CORRECTNESS CHECKLIST
----------------------------------
â–¡ Member function khÃ´ng Ä‘á»•i object? â†’ const
â–¡ Parameter khÃ´ng Ä‘á»•i? â†’ const reference
â–¡ Return reference khÃ´ng muá»‘n Ä‘á»•i? â†’ const reference
â–¡ Pointer khÃ´ng Ä‘á»•i target? â†’ const pointer

================================================================================

Báº¢NG Tá»”NG Há»¢P OPERATOR OVERLOADING
===================================
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATOR        â”‚ MEMBER?  â”‚ RETURN     â”‚ CONST?   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ +, -, *, /      â”‚ M or F   â”‚ By value   â”‚ const    â”‚
â”‚ +=, -=, *=, /=  â”‚ Member   â”‚ Reference  â”‚ no       â”‚
â”‚ ==, !=, <, >    â”‚ M or F   â”‚ bool       â”‚ const    â”‚
â”‚ <<, >>          â”‚ Friend   â”‚ stream&    â”‚ const    â”‚
â”‚ []              â”‚ Member   â”‚ Reference  â”‚ 2 ver    â”‚
â”‚ ()              â”‚ Member   â”‚ Any        â”‚ Any      â”‚
â”‚ =               â”‚ Member   â”‚ Reference  â”‚ no       â”‚
â”‚ new, delete     â”‚ Static   â”‚ void*      â”‚ N/A      â”‚
â”‚ Type conversion â”‚ Member   â”‚ Type       â”‚ const    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PHáº¢I LÃ€ MEMBER:
- = (assignment)
- [] (subscript)
- () (function call)
- -> (member access)

NÃŠN LÃ€ FRIEND:
- << vÃ  >> (stream operators)
- Binary operators cáº§n symmetry

KHÃ”NG THá»‚ OVERLOAD:
- . (member access)
- .* (pointer to member)
- :: (scope resolution)
- ?: (ternary)
- sizeof, typeid

================================================================================
                    PHáº¦N III: INHERITANCE & POLYMORPHISM
================================================================================

CHAPTER 11: SINGLE & MULTIPLE INHERITANCE
==========================================

11.1. SINGLE INHERITANCE
------------------------
    class Base {
    protected:
        int value;
    public:
        Base(int v) : value(v) {}
        void show() { cout << value; }
    };
    
    class Derived : public Base {
    public:
        Derived(int v) : Base(v) {}  // Gá»i base constructor
    };

Äáº¶C ÄIá»‚M:
âœ“ Derived káº¿ thá»«a Táº¤T Cáº¢ members cá»§a Base
âœ“ Access: public vÃ  protected (khÃ´ng pháº£i private)
âœ“ CÃ³ thá»ƒ override methods

11.2. MULTIPLE INHERITANCE
---------------------------
    class A {
    protected:
        int a;
    public:
        A(int x) : a(x) { cout << "A"; }
        ~A() { cout << "~A"; }
    };
    
    class B {
    protected:
        int b;
    public:
        B(int x) : b(x) { cout << "B"; }
        ~B() { cout << "~B"; }
    };
    
    class C : public A, public B {
        int c;
    public:
        C(int x, int y, int z) : A(x), B(y), c(z) {
            cout << "C";
        }
        ~C() { cout << "~C"; }
    };
    
    int main() {
        C obj(1, 2, 3);
        // Constructor: ABC
        // Destructor: ~C~B~A
    }

THá»¨ Tá»°:
- Constructor: Theo thá»© tá»± khai bÃ¡o (A, B, C)
- Destructor: NgÆ°á»£c láº¡i (~C, ~B, ~A)

11.3. DIAMOND PROBLEM
---------------------
    class Base {
    public:
        int value;
    };
    
    class A : public Base {};
    class B : public Base {};
    
    class C : public A, public B {
    public:
        void func() {
            // value;  // AMBIGUOUS!
            A::value = 10;  // Pháº£i chá»‰ Ä‘á»‹nh
            B::value = 20;
        }
    };

GIáº¢I PHÃP: VIRTUAL INHERITANCE
    class A : virtual public Base {};
    class B : virtual public Base {};
    
    class C : public A, public B {
        // Chá»‰ cÃ³ 1 copy cá»§a Base
    };

11.4. INHERITANCE ACCESS SPECIFIERS
------------------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Base Member â”‚ public:    â”‚ protected:    â”‚ private:    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ public      â”‚ public     â”‚ protected     â”‚ private     â”‚
â”‚ protected   â”‚ protected  â”‚ protected     â”‚ private     â”‚
â”‚ private     â”‚ inaccessibleâ”‚ inaccessible â”‚ inaccessibleâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BEST PRACTICE:
â†’ DÃ¹ng public inheritance cho IS-A relationship

================================================================================

CHAPTER 12: CONSTRUCTOR & DESTRUCTOR ORDER
===========================================

12.1. CONSTRUCTOR ORDER
-----------------------
THá»¨ Tá»° THá»°C HIá»†N:
1. Base class constructors (theo thá»© tá»± khai bÃ¡o)
2. Member objects constructors (theo thá»© tá»± khai bÃ¡o)
3. Derived class constructor body

VÃ Dá»¤:
    class Base {
    public:
        Base() { cout << "1.Base "; }
    };
    
    class Member {
    public:
        Member() { cout << "2.Member "; }
    };
    
    class Derived : public Base {
        Member m;
    public:
        Derived() { cout << "3.Derived "; }
    };
    
    int main() {
        Derived d;
        // Output: 1.Base 2.Member 3.Derived
    }

12.2. DESTRUCTOR ORDER
----------------------
THá»¨ Tá»° THá»°C HIá»†N: NGÆ¯á»¢C Láº I CONSTRUCTOR
1. Derived class destructor body
2. Member objects destructors (reverse order)
3. Base class destructors (reverse order)

VÃ Dá»¤:
    int main() {
        Derived d;
        // Destructor: ~Derived ~Member ~Base
    }

12.3. VIRTUAL DESTRUCTOR
------------------------
QUY Táº®C VÃ€NG:
    class Base {
    public:
        virtual ~Base() { cout << "~Base"; }
    };
    
    class Derived : public Base {
    public:
        ~Derived() { cout << "~Derived"; }
    };
    
    int main() {
        Base* ptr = new Derived;
        delete ptr;
        // Vá»›i virtual: ~Derived~Base (CORRECT!)
        // KhÃ´ng virtual: ~Base only (MEMORY LEAK!)
    }

KHI NÃ€O Cáº¦N VIRTUAL DESTRUCTOR?
âœ“ Class cÃ³ virtual functions
âœ“ Class Ä‘Æ°á»£c dÃ¹ng lÃ m base class
âœ“ Delete qua base pointer

12.4. MEMBER INITIALIZATION LIST
---------------------------------
    class Derived : public Base {
        int x;
        const int y;
        Member& ref;
    public:
        Derived(int a, int b, Member& m) 
            : Base(a),  // 1. Base constructor
              y(b),      // 2. const member
              ref(m),    // 3. reference member
              x(0)       // 4. normal member
        {
            // Constructor body
        }
    };

THá»¨ Tá»° KHá»I Táº O:
- Theo thá»© tá»± khai bÃ¡o trong class (KHÃ”NG theo init list)

PHáº¢I DÃ™NG INIT LIST:
âœ“ Base class constructor
âœ“ const members
âœ“ Reference members
âœ“ Member objects khÃ´ng cÃ³ default constructor

================================================================================

CHAPTER 13: VIRTUAL FUNCTIONS
==============================

13.1. KHÃI NIá»†M
---------------
Virtual function cho phÃ©p override trong derived class.

    class Animal {
    public:
        virtual void sound() {
            cout << "Animal sound";
        }
        virtual ~Animal() {}
    };
    
    class Dog : public Animal {
    public:
        void sound() override {  // Override
            cout << "Woof";
        }
    };
    
    int main() {
        Animal* ptr = new Dog;
        ptr->sound();  // "Woof" (dynamic binding)
        delete ptr;
    }

13.2. DYNAMIC BINDING
---------------------
    Animal* animal = new Dog;
    animal->sound();  // Calls Dog::sound() (runtime)

STATIC BINDING (khÃ´ng virtual):
    Animal* animal = new Dog;
    animal->sound();  // Calls Animal::sound() (compile-time)

13.3. OVERRIDE KEYWORD
----------------------
    class Derived : public Base {
    public:
        void func() override {  // Compiler check
            // Must override Base::func()
        }
    };

Æ¯U ÄIá»‚M:
âœ“ Compile-time check
âœ“ Catch typos
âœ“ Self-documenting

13.4. FINAL KEYWORD
-------------------
    class Base {
    public:
        virtual void func() final {
            // KhÃ´ng thá»ƒ override
        }
    };
    
    class Derived final : public Base {
        // KhÃ´ng thá»ƒ inherit tá»« Derived
    };

13.5. VIRTUAL FUNCTION TABLE (VTABLE)
--------------------------------------
CÆ  CHáº¾:
1. Compiler táº¡o vtable cho class cÃ³ virtual functions
2. Má»—i object cÃ³ vptr trá» Ä‘áº¿n vtable
3. Virtual function call â†’ lookup trong vtable

OVERHEAD:
- Memory: vptr (4/8 bytes per object)
- Performance: Indirect call (nhá»)

DIAGRAM:
    Object: | vptr | data |
              â†“
    vtable: | &func1 | &func2 | ...

================================================================================

CHAPTER 14: ABSTRACT CLASSES & PURE VIRTUAL
============================================

14.1. PURE VIRTUAL FUNCTION
----------------------------
    class Shape {
    public:
        virtual double area() = 0;  // Pure virtual
        virtual void draw() = 0;
        virtual ~Shape() {}
    };

Äáº¶C ÄIá»‚M:
- KhÃ´ng cÃ³ implementation
- Class cÃ³ pure virtual â†’ abstract class
- KhÃ´ng thá»ƒ táº¡o object

14.2. ABSTRACT CLASS
--------------------
    class Shape {
    public:
        virtual double area() = 0;
        virtual ~Shape() {}
    };
    
    // Shape s;  // ERROR! Abstract class
    
    class Circle : public Shape {
        double radius;
    public:
        double area() override {
            return 3.14 * radius * radius;
        }
    };
    
    Shape* ptr = new Circle();  // OK

14.3. INTERFACE PATTERN
-----------------------
    class IDrawable {
    public:
        virtual void draw() = 0;
        virtual ~IDrawable() {}
    };
    
    class IResizable {
    public:
        virtual void resize(double factor) = 0;
        virtual ~IResizable() {}
    };
    
    class Shape : public IDrawable, public IResizable {
    public:
        void draw() override { /*...*/ }
        void resize(double factor) override { /*...*/ }
    };

BEST PRACTICE:
â†’ DÃ¹ng abstract class lÃ m interface

14.4. CONCRETE CLASS
--------------------
Concrete class: Class cÃ³ implementation cho Táº¤T Cáº¢ functions.

    class Circle : public Shape {
    public:
        double area() override {
            return 3.14 * r * r;  // Implementation
        }
    };

================================================================================

CHAPTER 15: POLYMORPHISM & DYNAMIC BINDING
===========================================

15.1. COMPILE-TIME POLYMORPHISM (STATIC)
-----------------------------------------
- Function overloading
- Operator overloading
- Templates

VÃ Dá»¤:
    void print(int x);
    void print(double x);
    void print(string s);
    
    print(10);      // Compile-time resolution

15.2. RUNTIME POLYMORPHISM (DYNAMIC)
-------------------------------------
- Virtual functions
- Inheritance

VÃ Dá»¤:
    Animal* animal = new Dog;
    animal->sound();  // Runtime resolution

15.3. UPCASTING & DOWNCASTING
------------------------------
UPCASTING (an toÃ n, tá»± Ä‘á»™ng):
    Derived d;
    Base* basePtr = &d;  // Derived* â†’ Base*

DOWNCASTING (cáº§n cáº©n tháº­n):
    Base* bPtr = new Derived;
    Derived* dPtr = dynamic_cast<Derived*>(bPtr);
    if (dPtr) {
        // Safe downcasting
    }

15.4. SLICING PROBLEM
---------------------
    class Base {
    public:
        int x;
    };
    
    class Derived : public Base {
    public:
        int y;
    };
    
    void func(Base obj) {  // Pass by value
        // y bá»‹ máº¥t (slicing)
    }
    
    int main() {
        Derived d;
        func(d);  // SLICING!
    }

GIáº¢I PHÃP:
    void func(Base& obj) {  // Pass by reference
        // Polymorphism works!
    }

15.5. LISKOV SUBSTITUTION PRINCIPLE
------------------------------------
Derived class pháº£i cÃ³ thá»ƒ thay tháº¿ Base class mÃ  khÃ´ng lÃ m sai logic.

VÃ Dá»¤:
    void processAnimal(Animal& animal) {
        animal.sound();
        animal.eat();
    }
    
    Dog dog;
    Cat cat;
    processAnimal(dog);  // Works
    processAnimal(cat);  // Works

================================================================================
                        PHáº¦N IV: ADVANCED CONCEPTS
================================================================================

CHAPTER 16: TEMPLATES
=====================

16.1. FUNCTION TEMPLATES
------------------------
    template<typename T>
    T max(T a, T b) {
        return (a > b) ? a : b;
    }
    
    int main() {
        cout << max(10, 20);        // max<int>
        cout << max(3.14, 2.71);    // max<double>
        cout << max<int>(10, 20);   // Explicit
    }

16.2. CLASS TEMPLATES
---------------------
    template<typename T>
    class Stack {
        T data[100];
        int top;
    public:
        Stack() : top(-1) {}
        
        void push(const T& item) {
            data[++top] = item;
        }
        
        T pop() {
            return data[top--];
        }
    };
    
    int main() {
        Stack<int> intStack;
        Stack<string> strStack;
    }

16.3. TEMPLATE SPECIALIZATION
------------------------------
    // General template
    template<typename T>
    class MyClass {
    public:
        void func() { cout << "General"; }
    };
    
    // Specialization for int
    template<>
    class MyClass<int> {
    public:
        void func() { cout << "Specialized for int"; }
    };

16.4. NON-TYPE TEMPLATE PARAMETERS
-----------------------------------
    template<typename T, int SIZE>
    class Array {
        T data[SIZE];
    public:
        int size() const { return SIZE; }
    };
    
    Array<int, 10> arr1;
    Array<double, 20> arr2;

16.5. VARIADIC TEMPLATES
-------------------------
    template<typename... Args>
    void print(Args... args) {
        (cout << ... << args) << endl;
    }
    
    print(1, 2.5, "hello");  // 12.5hello

16.6. TEMPLATE VS INHERITANCE
------------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  â”‚ Template     â”‚ Inheritance    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Binding          â”‚ Compile-time â”‚ Runtime        â”‚
â”‚ Code generation  â”‚ Many copies  â”‚ One copy       â”‚
â”‚ Performance      â”‚ Faster       â”‚ Slower (vtable)â”‚
â”‚ Binary size      â”‚ Larger       â”‚ Smaller        â”‚
â”‚ Flexibility      â”‚ Type-safe    â”‚ Polymorphic    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================

CHAPTER 17: EXCEPTION HANDLING
===============================

17.1. CÆ  Báº¢N
------------
    try {
        // Code cÃ³ thá»ƒ throw exception
        if (error) {
            throw runtime_error("Error message");
        }
    }
    catch (const runtime_error& e) {
        cout << "Caught: " << e.what();
    }
    catch (...) {
        cout << "Unknown exception";
    }

17.2. EXCEPTION HIERARCHY
-------------------------
    exception
    â”œâ”€â”€ logic_error
    â”‚   â”œâ”€â”€ invalid_argument
    â”‚   â”œâ”€â”€ out_of_range
    â”‚   â””â”€â”€ length_error
    â””â”€â”€ runtime_error
        â”œâ”€â”€ overflow_error
        â”œâ”€â”€ underflow_error
        â””â”€â”€ range_error

17.3. THROW SPECIFICATIONS
--------------------------
    void func() noexcept {
        // KhÃ´ng throw exception
    }
    
    void func() {
        // CÃ³ thá»ƒ throw báº¥t ká»³ exception
    }

17.4. RETHROW
-------------
    try {
        // Code
    }
    catch (const exception& e) {
        cout << "Handling: " << e.what();
        throw;  // Rethrow cÃ¹ng exception
    }

17.5. EXCEPTION SAFETY
----------------------
LEVELS:
1. No guarantee: CÃ³ thá»ƒ corrupt state
2. Basic guarantee: No leaks, valid state
3. Strong guarantee: Commit or rollback
4. No-throw guarantee: Never throws

RAII PATTERN:
    class Resource {
        int* data;
    public:
        Resource() : data(new int[100]) {}
        ~Resource() { delete[] data; }
        // Destructor tá»± Ä‘á»™ng giáº£i phÃ³ng
    };

17.6. CATCH ORDER
-----------------
    try {
        // Code
    }
    catch (const DerivedError& e) {
        // Pháº£i catch derived trÆ°á»›c
    }
    catch (const BaseError& e) {
        // Base sau
    }
    catch (...) {
        // Catch-all cuá»‘i cÃ¹ng
    }

================================================================================

CHAPTER 18: COPY CONTROL & RULE OF THREE
=========================================

18.1. RULE OF THREE
-------------------
Náº¿u class cáº§n 1 trong 3 â†’ cáº§n Cáº¢ 3:
1. Destructor
2. Copy constructor
3. Copy assignment operator

VÃ Dá»¤:
    class String {
        char* data;
    public:
        // 1. Destructor
        ~String() {
            delete[] data;
        }
        
        // 2. Copy constructor
        String(const String& other) {
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        }
        
        // 3. Copy assignment
        String& operator=(const String& other) {
            if (this != &other) {
                delete[] data;
                data = new char[strlen(other.data) + 1];
                strcpy(data, other.data);
            }
            return *this;
        }
    };

18.2. RULE OF FIVE (C++11)
--------------------------
ThÃªm 2 thÃ nh viÃªn ná»¯a:
4. Move constructor
5. Move assignment operator

    class String {
    public:
        // 4. Move constructor
        String(String&& other) noexcept {
            data = other.data;
            other.data = nullptr;
        }
        
        // 5. Move assignment
        String& operator=(String&& other) noexcept {
            if (this != &other) {
                delete[] data;
                data = other.data;
                other.data = nullptr;
            }
            return *this;
        }
    };

18.3. DEEP COPY VS SHALLOW COPY
--------------------------------
SHALLOW COPY (default):
    class String {
        char* data;
    };
    
    String s1;
    String s2 = s1;  // Copy pointer â†’ DANGEROUS!
    // Cáº£ 2 trá» cÃ¹ng memory

DEEP COPY:
    String(const String& other) {
        data = new char[...];  // Allocate new memory
        strcpy(data, other.data);  // Copy data
    }

18.4. COPY-AND-SWAP IDIOM
--------------------------
    class String {
    public:
        friend void swap(String& a, String& b) {
            using std::swap;
            swap(a.data, b.data);
        }
        
        String& operator=(String other) {  // Pass by value
            swap(*this, other);
            return *this;
        }
    };

Æ¯U ÄIá»‚M:
âœ“ Exception-safe
âœ“ Self-assignment safe
âœ“ Code reuse

18.5. RULE OF ZERO
------------------
Best practice: DÃ¹ng smart pointers, khÃ´ng cáº§n define special members.

    class String {
        unique_ptr<char[]> data;
    public:
        // KhÃ´ng cáº§n destructor, copy constructor, etc.
        // Compiler tá»± generate hoáº·c delete
    };

================================================================================

CHAPTER 19: STATIC POLYMORPHISM
================================

19.1. CRTP (Curiously Recurring Template Pattern)
--------------------------------------------------
    template<typename Derived>
    class Base {
    public:
        void interface() {
            static_cast<Derived*>(this)->implementation();
        }
    };
    
    class Derived : public Base<Derived> {
    public:
        void implementation() {
            cout << "Derived implementation";
        }
    };

SO SÃNH:
- Dynamic polymorphism: Virtual functions (runtime)
- Static polymorphism: Templates (compile-time)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚ Virtual     â”‚ CRTP            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Binding      â”‚ Runtime     â”‚ Compile-time    â”‚
â”‚ Overhead     â”‚ Vtable      â”‚ None            â”‚
â”‚ Performance  â”‚ Slower      â”‚ Faster          â”‚
â”‚ Flexibility  â”‚ High        â”‚ Low             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

19.2. FUNCTION OBJECTS (FUNCTORS)
----------------------------------
    struct Comparator {
        bool operator()(int a, int b) const {
            return a < b;
        }
    };
    
    vector<int> v = {3, 1, 4, 1, 5};
    sort(v.begin(), v.end(), Comparator());

Æ¯U ÄIá»‚M:
âœ“ Inline (fast)
âœ“ State (cÃ³ members)
âœ“ Type-safe

19.3. POLICY-BASED DESIGN
--------------------------
    template<typename SortPolicy>
    class DataProcessor {
    public:
        void process(vector<int>& data) {
            SortPolicy::sort(data);
        }
    };
    
    struct QuickSortPolicy {
        static void sort(vector<int>& data) {
            // Quick sort
        }
    };

================================================================================

CHAPTER 20: DESIGN PATTERNS
============================

20.1. SINGLETON PATTERN
-----------------------
    class Singleton {
        static Singleton* instance;
        Singleton() {}  // Private constructor
    public:
        static Singleton* getInstance() {
            if (!instance) {
                instance = new Singleton();
            }
            return instance;
        }
    };

20.2. FACTORY PATTERN
---------------------
    class Shape {
    public:
        virtual void draw() = 0;
        virtual ~Shape() {}
    };
    
    class ShapeFactory {
    public:
        static Shape* create(string type) {
            if (type == "circle") return new Circle();
            if (type == "square") return new Square();
            return nullptr;
        }
    };

20.3. OBSERVER PATTERN
----------------------
    class Observer {
    public:
        virtual void update() = 0;
    };
    
    class Subject {
        vector<Observer*> observers;
    public:
        void attach(Observer* obs) {
            observers.push_back(obs);
        }
        
        void notify() {
            for (auto obs : observers) {
                obs->update();
            }
        }
    };

20.4. STRATEGY PATTERN
----------------------
    class SortStrategy {
    public:
        virtual void sort(vector<int>& data) = 0;
        virtual ~SortStrategy() {}
    };
    
    class QuickSort : public SortStrategy {
        void sort(vector<int>& data) override {
            // Quick sort implementation
        }
    };
    
    class Context {
        SortStrategy* strategy;
    public:
        void setStrategy(SortStrategy* s) {
            strategy = s;
        }
        
        void execute(vector<int>& data) {
            strategy->sort(data);
        }
    };

================================================================================
                            Tá»”NG Káº¾T & BEST PRACTICES
================================================================================

1. C++ FUNDAMENTALS
===================
âœ“ Prefer references over pointers (trá»« khi cáº§n nullptr)
âœ“ Use const reference for read-only parameters
âœ“ sizeof khÃ´ng cÃ³ side effects
âœ“ Default parameters pháº£i á»Ÿ cuá»‘i
âœ“ Pass by reference cho objects lá»›n

2. OPERATOR OVERLOADING
========================
âœ“ operator= pháº£i lÃ  member function
âœ“ operator<< pháº£i lÃ  friend function
âœ“ Return reference tá»« +=, -=, *= (cho chain)
âœ“ Return value tá»« +, -, * (táº¡o object má»›i)
âœ“ Self-assignment check trong operator=
âœ“ Const correctness everywhere

3. INHERITANCE
==============
âœ“ Virtual destructor cho base class
âœ“ Gá»i base constructor trong initialization list
âœ“ Override keyword cho virtual functions
âœ“ Pass by reference Ä‘á»ƒ trÃ¡nh slicing
âœ“ Prefer composition over inheritance

4. POLYMORPHISM
===============
âœ“ Virtual functions cho dynamic binding
âœ“ Pure virtual cho abstract class/interface
âœ“ dynamic_cast cho safe downcasting
âœ“ Avoid deep inheritance hierarchies

5. TEMPLATES
============
âœ“ Templates cho compile-time polymorphism
âœ“ Specialization cho special cases
âœ“ Prefer templates over macros
âœ“ Consider compilation time

6. EXCEPTION HANDLING
======================
âœ“ Throw by value, catch by const reference
âœ“ Catch specific exceptions trÆ°á»›c
âœ“ RAII cho resource management
âœ“ noexcept cho functions khÃ´ng throw

7. MEMORY MANAGEMENT
====================
âœ“ Rule of Three/Five/Zero
âœ“ Use smart pointers (unique_ptr, shared_ptr)
âœ“ RAII pattern
âœ“ Avoid manual new/delete
âœ“ nullptr check trÆ°á»›c dereference

8. CODE QUALITY
===============
âœ“ const correctness
âœ“ Self-documenting code
âœ“ SOLID principles
âœ“ DRY (Don't Repeat Yourself)
âœ“ KISS (Keep It Simple, Stupid)

================================================================================
                            COMPILATION & DEBUGGING
================================================================================

COMPILATION FLAGS:
------------------
    # Warnings
    g++ -Wall -Wextra -Werror file.cpp
    
    # Optimization
    g++ -O2 file.cpp
    
    # Debug
    g++ -g file.cpp
    
    # C++ standard
    g++ -std=c++17 file.cpp
    
    # All combined
    g++ -Wall -Wextra -std=c++17 -O2 file.cpp -o program

DEBUGGING TOOLS:
----------------
    # GDB
    gdb ./program
    
    # Valgrind (memory check)
    valgrind --leak-check=full ./program
    
    # AddressSanitizer
    g++ -fsanitize=address file.cpp
    
    # UndefinedBehaviorSanitizer
    g++ -fsanitize=undefined file.cpp

================================================================================
                            CHECKLIST Tá»”NG Há»¢P
================================================================================

BEFORE COMPILE:
â–¡ Include guards trong headers?
â–¡ Forward declarations Ä‘Ãºng?
â–¡ Template definitions trong headers?
â–¡ Const correctness?

CLASS DESIGN:
â–¡ Virtual destructor náº¿u cÃ³ virtual functions?
â–¡ Rule of Three/Five/Zero?
â–¡ Copy constructor vá»›i deep copy?
â–¡ Self-assignment check trong operator=?
â–¡ Const member functions?

INHERITANCE:
â–¡ Gá»i base constructor?
â–¡ Virtual destructor?
â–¡ Override keyword?
â–¡ Avoid slicing?

MEMORY:
â–¡ new â†’ delete, new[] â†’ delete[]?
â–¡ No memory leaks?
â–¡ No dangling pointers?
â–¡ nullptr checks?

PERFORMANCE:
â–¡ Pass by reference cho large objects?
â–¡ Const reference cho read-only?
â–¡ Move semantics cho transfers?
â–¡ Reserve vector capacity?

================================================================================
                            COMMON MISTAKES
================================================================================

1. âŒ QuÃªn virtual destructor
   âœ“ Always virtual destructor cho base class

2. âŒ Array decay trong sizeof
   âœ“ Truyá»n size nhÆ° tham sá»‘

3. âŒ sizeof vá»›i side effects
   âœ“ sizeof khÃ´ng evaluate expression

4. âŒ operator= lÃ  friend
   âœ“ operator= PHáº¢I lÃ  member

5. âŒ Pass by value gÃ¢y slicing
   âœ“ Pass by reference/pointer

6. âŒ Dangling reference/pointer
   âœ“ KhÃ´ng return reference Ä‘áº¿n local

7. âŒ Self-assignment khÃ´ng check
   âœ“ if (this != &other)

8. âŒ Shallow copy vá»›i pointers
   âœ“ Deep copy trong copy constructor

9. âŒ KhÃ´ng gá»i base constructor
   âœ“ Initialization list: Base(args)

10. âŒ Exception safety
    âœ“ RAII pattern

================================================================================
                            QUICK REFERENCE
================================================================================

MEMBER FUNCTION:
    ReturnType functionName(params) const {
        return value;
    }

CONSTRUCTOR:
    ClassName(params) : member1(val1), member2(val2) {
        // Body
    }

DESTRUCTOR:
    virtual ~ClassName() {
        // Cleanup
    }

COPY CONSTRUCTOR:
    ClassName(const ClassName& other) {
        // Deep copy
    }

COPY ASSIGNMENT:
    ClassName& operator=(const ClassName& other) {
        if (this != &other) {
            // Copy
        }
        return *this;
    }

OPERATOR OVERLOAD (MEMBER):
    ReturnType operator+(const ClassName& other) const {
        return ClassName(/*...*/);
    }

OPERATOR OVERLOAD (FRIEND):
    friend ostream& operator<<(ostream& os, const ClassName& obj) {
        return os << obj.member;
    }

INHERITANCE:
    class Derived : public Base {
    public:
        Derived(params) : Base(baseParams) {
            // Body
        }
    };

VIRTUAL FUNCTION:
    virtual ReturnType functionName() override {
        // Implementation
    }

TEMPLATE:
    template<typename T>
    class ClassName {
        T member;
    };

================================================================================
                            Káº¾T LUáº¬N
================================================================================

TÃ i liá»‡u nÃ y tá»•ng há»£p TOÃ€N Bá»˜ kiáº¿n thá»©c OOP C++ tá»«:
âœ… Test 1: C++ Fundamentals
âœ… Test 2: Operator Overloading
âœ… Giá»¯a KÃ¬: Inheritance + Operators
âœ… Test 3: Polymorphism + Templates + Exceptions

ÄIá»‚M THEN CHá»T:
1. References & Pointers - KhÃ¡c biá»‡t vÃ  khi nÃ o dÃ¹ng
2. sizeof operator - KhÃ´ng cÃ³ side effects
3. Operator Overloading - Member vs Friend
4. Inheritance - Constructor/Destructor order
5. Virtual Functions - Dynamic binding
6. Templates - Compile-time polymorphism
7. Exception Handling - RAII pattern
8. Copy Control - Rule of Three/Five/Zero

LUYá»†N Táº¬P:
- Viáº¿t class vá»›i Ä‘áº§y Ä‘á»§ special members
- Implement operators cho custom types
- Practice inheritance hierarchies
- Template programming
- Exception-safe code

BEST PRACTICES:
- Const correctness
- RAII for resources
- Virtual destructor
- Pass by reference
- Smart pointers
- Override keyword
- Rule of Zero when possible

CHÃšC Báº N Ã”N Táº¬P Tá»T VÃ€ Äáº T ÄIá»‚M CAO TRONG Táº¤T Cáº¢ CÃC BÃ€I THI! ğŸš€ğŸ¯

================================================================================
                            Háº¾T
================================================================================
