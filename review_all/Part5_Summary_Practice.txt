================================================================================
              PHáº¦N V: Tá»”NG Há»¢P & THá»°C HÃ€NH
================================================================================

Tá»•ng há»£p cÃ¡c lá»—i thÆ°á»ng gáº·p, best practices, vÃ  checklist Ã´n táº­p
Format: Váº¥n Ä‘á» â†’ Giáº£i thÃ­ch â†’ Giáº£i phÃ¡p

================================================================================

Má»¤C Lá»¤C
â•â•â•â•â•â•â•

35. CÃC Lá»–I THÆ¯á»œNG Gáº¶P (TOP 20)
36. BEST PRACTICES
37. CHECKLIST Tá»”NG Há»¢P
38. DEBUGGING TECHNIQUES
39. PERFORMANCE TIPS
40. COMPILATION & TOOLS

================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 35: CÃC Lá»–I THÆ¯á»œNG Gáº¶P (TOP 20)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

35.1. SIZEOF SIDE EFFECTS â­â­â­
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int x = 5;
int y = sizeof(x++);  // NghÄ© x = 6
cout << x << y;  // âŒ NghÄ©: 64
```

âœ“ ÄÃšNG:
```cpp
int x = 5;
int y = sizeof(x++);  // sizeof KHÃ”NG thá»±c hiá»‡n x++
cout << x << y;  // âœ“ ÄÃºng: 54 (x khÃ´ng Ä‘á»•i!)
```

GHI NHá»š: sizeof KHÃ”NG BAO GIá»œ cÃ³ side effects!

35.2. ARRAY DECAY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
void func(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // âŒ SAI!
    // arr decay thÃ nh pointer, sizeof(arr) = 4/8
}

int main() {
    int arr[10];
    func(arr);
}
```

âœ“ GIáº¢I PHÃP:
```cpp
void func(int arr[], int size) {  // Truyá»n size
    for (int i = 0; i < size; i++) {
        cout << arr[i];
    }
}

int main() {
    int arr[10];
    func(arr, sizeof(arr)/sizeof(arr[0]));  // TÃ­nh size trÆ°á»›c
}
```

35.3. DANGLING REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int& getReference() {
    int x = 10;
    return x;  // âŒ NGUY HIá»‚M! x bá»‹ há»§y
}
```

âœ“ GIáº¢I PHÃP:
```cpp
int& getReference() {
    static int x = 10;  // âœ“ Static: tá»“n táº¡i sau return
    return x;
}
```

35.4. KHÃ”NG CÃ“ VIRTUAL DESTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class Base {
public:
    ~Base() {}  // âŒ KhÃ´ng virtual!
};

class Derived : public Base {
    int* data;
public:
    Derived() { data = new int[1000]; }
    ~Derived() { delete[] data; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  // âŒ MEMORY LEAK! Chá»‰ gá»i ~Base()
}
```

âœ“ GIáº¢I PHÃP:
```cpp
class Base {
public:
    virtual ~Base() {}  // âœ“ Virtual!
};
```

35.5. SLICING PROBLEM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
void func(Base obj) {  // âŒ Pass by value
    obj.print();  // Slicing! Chá»‰ gá»i Base::print
}

int main() {
    Derived d;
    func(d);  // Derived part bá»‹ "sliced off"
}
```

âœ“ GIáº¢I PHÃP:
```cpp
void func(Base& obj) {  // âœ“ Pass by reference
    obj.print();  // Polymorphism works!
}
```

35.6. QUÃŠN SELF-ASSIGNMENT CHECK
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
MyClass& operator=(const MyClass& other) {
    delete[] data;  // âŒ Delete first
    data = new char[other.length];
    strcpy(data, other.data);  // âŒ other Ä‘Ã£ bá»‹ delete!
    return *this;
}

// Khi: obj = obj; â†’ CRASH!
```

âœ“ GIáº¢I PHÃP:
```cpp
MyClass& operator=(const MyClass& other) {
    if (this != &other) {  // âœ“ Check trÆ°á»›c
        delete[] data;
        data = new char[other.length];
        strcpy(data, other.data);
    }
    return *this;
}
```

35.7. STREAM OPERATOR LÃ€ MEMBER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class MyClass {
public:
    ostream& operator<<(ostream& os) {  // âŒ SAI!
        os << value;
        return os;
    }
};

// Gá»i: obj << cout;  // âŒ NgÆ°á»£c!
```

âœ“ GIáº¢I PHÃP:
```cpp
class MyClass {
public:
    friend ostream& operator<<(ostream& os, const MyClass& obj) {
        os << obj.value;
        return os;
    }
};

// Gá»i: cout << obj;  // âœ“ ÄÃºng!
```

35.8. RETURN REFERENCE Äáº¾N LOCAL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
MyClass& operator+(const MyClass& other) const {
    MyClass result = ...;
    return result;  // âŒ Dangling reference!
}
```

âœ“ GIáº¢I PHÃP:
```cpp
MyClass operator+(const MyClass& other) const {
    MyClass result = ...;
    return result;  // âœ“ Return by value
}
```

35.9. QUÃŠN Gá»ŒI BASE CONSTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class Base {
    int value;
public:
    Base(int v) : value(v) {}  // KhÃ´ng cÃ³ default ctor
};

class Derived : public Base {
public:
    Derived(int v) {}  // âŒ ERROR! Base khÃ´ng cÃ³ default ctor
};
```

âœ“ GIáº¢I PHÃP:
```cpp
class Derived : public Base {
public:
    Derived(int v) : Base(v) {}  // âœ“ Gá»i base ctor
};
```

35.10. QUÃŠN CONST TRONG COMPARISON
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class MyClass {
public:
    bool operator==(const MyClass& other) {  // âŒ Thiáº¿u const
        return value == other.value;
    }
};

const MyClass obj1, obj2;
obj1 == obj2;  // âŒ ERROR: KhÃ´ng gá»i Ä‘Æ°á»£c non-const function
```

âœ“ GIáº¢I PHÃP:
```cpp
bool operator==(const MyClass& other) const {  // âœ“ const
    return value == other.value;
}
```

35.11. DEFAULT PARAMETERS KHÃ”NG á» CUá»I
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
void func(int x = 10, int y);  // âŒ ERROR!
```

âœ“ GIáº¢I PHÃP:
```cpp
void func(int x, int y = 10);  // âœ“ Default á»Ÿ cuá»‘i
```

35.12. AMBIGUITY Vá»šI OVERLOADING + DEFAULT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int func(int, int);
int func(int, int, int = 5);

func(1, 2);  // âŒ Ambiguous! Gá»i func nÃ o?
```

âœ“ GIáº¢I PHÃP:
```cpp
// TrÃ¡nh overloading + default cÃ¹ng lÃºc
// Hoáº·c Ä‘áº·t tÃªn khÃ¡c:
int func2(int, int);
int func3(int, int, int = 5);
```

35.13. OPERATOR[] RETURN BY VALUE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int operator[](int index) {  // âŒ Return by value
    return data[index];
}

arr[5] = 10;  // âŒ KhÃ´ng gÃ¡n Ä‘Æ°á»£c!
```

âœ“ GIáº¢I PHÃP:
```cpp
int& operator[](int index) {  // âœ“ Return reference
    return data[index];
}

arr[5] = 10;  // âœ“ OK!
```

35.14. KHÃ”NG RETURN STREAM&
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
void operator<<(ostream& os, const MyClass& obj) {
    os << obj.value;
    // âŒ KhÃ´ng return
}

cout << obj1 << obj2;  // âŒ ERROR: KhÃ´ng chain Ä‘Æ°á»£c
```

âœ“ GIáº¢I PHÃP:
```cpp
ostream& operator<<(ostream& os, const MyClass& obj) {
    os << obj.value;
    return os;  // âœ“ Return stream&
}
```

35.15. SHALLOW COPY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class MyClass {
    int* data;
public:
    MyClass(int v) { data = new int(v); }
    ~MyClass() { delete data; }
    // âŒ KhÃ´ng cÃ³ copy ctor â†’ Compiler-generated shallow copy
};

MyClass obj1(42);
MyClass obj2 = obj1;  // âŒ obj2.data = obj1.data (same pointer!)
// âŒ DOUBLE DELETE khi ~obj1() vÃ  ~obj2()
```

âœ“ GIáº¢I PHÃP:
```cpp
MyClass(const MyClass& other) {
    data = new int(*other.data);  // âœ“ Deep copy
}
```

35.16. TYPE PROMOTION BUG
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int a = 5, b = 2;
double result = a / b;  // âŒ NghÄ©: 2.5
cout << result;  // âŒ Káº¿t quáº£: 2.0 (int/int = int)
```

âœ“ GIáº¢I PHÃP:
```cpp
double result = static_cast<double>(a) / b;  // âœ“ 2.5
// Hoáº·c: double result = a / 2.0;
```

35.17. REFERENCE RE-BIND
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
int x = 10, y = 20;
int& ref = x;
ref = y;  // âŒ NghÄ©: ref trá» sang y
cout << x;  // âŒ NghÄ©: 10, Tháº­t: 20
```

âœ“ HIá»‚U ÄÃšNG:
```cpp
ref = y;  // âœ“ GÃN GIÃ TRá»Š y cho x (x = 20)
// ref VáºªN lÃ  alias cá»§a x
```

35.18. INITIALIZER LIST ORDER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class MyClass {
    int x, y;  // Khai bÃ¡o: x trÆ°á»›c y
public:
    MyClass(int val) : y(val), x(y) {}  // âŒ x init trÆ°á»›c y!
    // x = ??? (y chÆ°a init)
};
```

âœ“ GIáº¢I PHÃP:
```cpp
MyClass(int val) : x(val), y(x) {}  // âœ“ Theo thá»© tá»± khai bÃ¡o
```

35.19. STATIC MEMBER KHÃ”NG DEFINE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class MyClass {
public:
    static int count;  // Chá»‰ khai bÃ¡o
};

int main() {
    MyClass::count = 10;  // âŒ LINKER ERROR!
}
```

âœ“ GIáº¢I PHÃP:
```cpp
class MyClass {
public:
    static int count;
};

int MyClass::count = 0;  // âœ“ PHáº¢I define á»Ÿ ngoÃ i
```

35.20. QUÃŠN OVERRIDE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I:
```cpp
class Derived : public Base {
public:
    void func(double) {}  // âŒ KhÃ´ng override Base::func(int)
    // Táº¡o function Má»šI thay vÃ¬ override
};
```

âœ“ GIáº¢I PHÃP:
```cpp
void func(double) override {}  // âœ“ Compiler check
// ERROR: Signature khÃ´ng khá»›p!

void func(int) override {}  // âœ“ OK
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 36: BEST PRACTICES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

36.1. CONST-CORRECTNESS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ LUÃ”N DÃ™NG const:
```cpp
class MyClass {
    int value;
public:
    // âœ“ Getters const
    int getValue() const { return value; }
    
    // âœ“ Comparison const
    bool operator==(const MyClass& other) const {
        return value == other.value;
    }
    
    // âœ“ Parameters const&
    MyClass(const MyClass& other) { ... }
    MyClass& operator=(const MyClass& other) { ... }
};

// âœ“ Pass const reference
void print(const MyClass& obj) { ... }
```

36.2. RULE OF ZERO/THREE/FIVE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ RULE OF ZERO (khuyÃªn dÃ¹ng):
```cpp
class MyClass {
    std::vector<int> data;  // âœ“ DÃ¹ng STL containers
    std::string name;
    // KhÃ´ng cáº§n define destructor, copy, move
    // Compiler-generated Ä‘á»§ tá»‘t!
};
```

âœ“ RULE OF THREE (khi cáº§n):
```cpp
class MyClass {
    int* data;
public:
    ~MyClass() { delete[] data; }
    MyClass(const MyClass& other) { ... }
    MyClass& operator=(const MyClass& other) { ... }
};
```

âœ“ RULE OF FIVE (C++11):
```cpp
class MyClass {
public:
    ~MyClass() { ... }
    MyClass(const MyClass&) { ... }
    MyClass& operator=(const MyClass&) { ... }
    MyClass(MyClass&&) noexcept { ... }
    MyClass& operator=(MyClass&&) noexcept { ... }
};
```

36.3. RAII PATTERN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ Tá»° Äá»˜NG QUáº¢N LÃ RESOURCES:
```cpp
class FileHandle {
    FILE* file;
public:
    FileHandle(const char* name) {
        file = fopen(name, "r");
    }
    ~FileHandle() {
        if (file) fclose(file);  // âœ“ Tá»± Ä‘á»™ng
    }
};

// âœ“ DÃ¹ng smart pointers
std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
// KhÃ´ng cáº§n delete, tá»± Ä‘á»™ng cleanup
```

36.4. PREFER REFERENCES OVER POINTERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ DÃ™NG REFERENCES KHI CÃ“ THá»‚:
```cpp
// âœ“ Reference (an toÃ n hÆ¡n)
void func(const MyClass& obj) { ... }

// âŒ Pointer (chá»‰ khi cáº§n nullptr)
void func(const MyClass* obj) {
    if (obj) { ... }
}
```

36.5. INITIALIZE MEMBERS IN INITIALIZER LIST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ DÃ™NG INITIALIZER LIST:
```cpp
class MyClass {
    int x;
    const int y;
    MyClass& ref;
public:
    // âœ“ Initializer list
    MyClass(int a, int b, MyClass& r) : x(a), y(b), ref(r) {}
    
    // âŒ Body assignment (khÃ´ng compile vá»›i const, reference)
    // MyClass(int a, int b) {
    //     x = a;
    //     y = b;  // ERROR: const
    // }
};
```

36.6. USE OVERRIDE KEYWORD
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ RÃ• RÃ€NG Vá»šI override:
```cpp
class Derived : public Base {
public:
    void func() override {}  // âœ“ Compiler check
    void func2() {}          // âŒ KhÃ´ng rÃµ: new hay override?
};
```

36.7. PASS SMALL TYPES BY VALUE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ QUY Táº®C NGÃ“N TAY CÃI:
```cpp
// Small types (int, char, bool, pointer) â†’ by value
void func(int x) { ... }

// Large types (class, struct > 16 bytes) â†’ by const reference
void func(const string& str) { ... }
void func(const vector<int>& vec) { ... }
```

36.8. EXPLICIT CONSTRUCTORS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ TRÃNH IMPLICIT CONVERSION:
```cpp
class MyClass {
public:
    explicit MyClass(int value) { ... }  // âœ“ explicit
    
    // NgÄƒn:
    // MyClass obj = 10;  // âŒ ERROR vá»›i explicit
    // func(10);          // âŒ ERROR vá»›i explicit
    
    // Pháº£i:
    // MyClass obj(10);   // âœ“ OK
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 37: CHECKLIST Tá»”NG Há»¢P
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

37.1. REFERENCES & POINTERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Reference PHáº¢I khá»Ÿi táº¡o ngay
â–¡ Reference KHÃ”NG THá»‚ re-bind
â–¡ Reference KHÃ”NG cÃ³ null
â–¡ Pointer cÃ³ thá»ƒ nullptr, cÃ³ thá»ƒ Ä‘á»•i target
â–¡ DÃ¹ng reference cho parameters, pointer cho optional

37.2. SIZEOF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ sizeof KHÃ”NG cÃ³ side effects â­â­â­
â–¡ sizeof(array) trong function = sizeof(pointer)
â–¡ sizeof(pointer) = 4 (32-bit) hoáº·c 8 (64-bit)
â–¡ sizeof(class) bao gá»“m padding
â–¡ Truyá»n size khi pass array vÃ o function

37.3. DEFAULT PARAMETERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Default parameters PHáº¢I á»Ÿ cuá»‘i
â–¡ Cáº©n tháº­n ambiguity vá»›i overloading
â–¡ KhÃ´ng redeclare vá»›i default khÃ¡c

37.4. OPERATOR OVERLOADING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ =, [], (), -> PHáº¢I lÃ  member functions
â–¡ <<, >> PHáº¢I lÃ  friend functions
â–¡ Arithmetic (+, -, *, /) return BY VALUE
â–¡ Compound (+=, -=) return REFERENCE
â–¡ Stream operators return stream&
â–¡ operator= cáº§n self-assignment check
â–¡ operator[] return reference Ä‘á»ƒ gÃ¡n Ä‘Æ°á»£c
â–¡ Comparison operators nÃªn const

37.5. INHERITANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Construction: Base â†’ Derived
â–¡ Destruction: ~Derived â†’ ~Base
â–¡ Virtual destructor náº¿u class Ä‘Æ°á»£c káº¿ thá»«a
â–¡ Gá»i base constructor trong initializer list
â–¡ Copy constructor pháº£i gá»i base copy
â–¡ Pass by reference/pointer Ä‘á»ƒ trÃ¡nh slicing
â–¡ DÃ¹ng override keyword

37.6. POLYMORPHISM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Virtual functions cho runtime polymorphism
â–¡ Pure virtual (= 0) cho abstract classes
â–¡ Upcasting luÃ´n an toÃ n
â–¡ Downcasting dÃ¹ng dynamic_cast
â–¡ Virtual destructor Ä‘á»ƒ delete qua base pointer

37.7. TEMPLATES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Function templates automatic type deduction
â–¡ Class templates cáº§n explicit type
â–¡ Template specialization cho specific types

37.8. EXCEPTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Use try-catch-throw
â–¡ Catch specific exceptions trÆ°á»›c general
â–¡ RAII pattern tá»± Ä‘á»™ng cleanup
â–¡ noexcept cho functions khÃ´ng throw

37.9. COPY CONTROL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Rule of Three/Five/Zero
â–¡ Deep copy cho dynamic memory
â–¡ Self-assignment check trong operator=
â–¡ Return *this trong assignment
â–¡ Move semantics cho performance (C++11)

37.10. STATIC
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Static members shared by all objects
â–¡ Static members PHáº¢I define á»Ÿ ngoÃ i class
â–¡ Static functions khÃ´ng cÃ³ this pointer
â–¡ Static local variables giá»¯ giÃ¡ trá»‹

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 38: DEBUGGING TECHNIQUES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

38.1. PRINT DEBUGGING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
class MyClass {
public:
    MyClass() {
        cout << "MyClass() called" << endl;  // âœ“ Track constructors
    }
    
    ~MyClass() {
        cout << "~MyClass() called" << endl;  // âœ“ Track destructors
    }
    
    void func() {
        cout << "func() start" << endl;
        // ...
        cout << "func() end" << endl;
    }
};
```

38.2. ASSERT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <cassert>

void func(int* ptr) {
    assert(ptr != nullptr);  // âœ“ Check preconditions
    // ...
}

void setSize(int s) {
    assert(s > 0);  // âœ“ Check invariants
    size = s;
}
```

38.3. MEMORY DEBUGGING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VALGRIND (Linux):
```bash
g++ -g program.cpp -o program
valgrind --leak-check=full ./program
```

VISUAL STUDIO (Windows):
- Enable memory leak detection
- Check output window for leaks

38.4. GDB BASICS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```bash
g++ -g program.cpp -o program
gdb ./program

(gdb) break main       # Set breakpoint
(gdb) run              # Run program
(gdb) next             # Next line
(gdb) step             # Step into
(gdb) print variable   # Print value
(gdb) backtrace        # Call stack
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 39: PERFORMANCE TIPS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

39.1. PASS BY CONST REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ CHáº¬M:
```cpp
void func(string str) {  // Copy toÃ n bá»™ string
    cout << str;
}
```

âœ“ NHANH:
```cpp
void func(const string& str) {  // KhÃ´ng copy
    cout << str;
}
```

39.2. RESERVE MEMORY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ CHáº¬M:
```cpp
vector<int> vec;
for (int i = 0; i < 1000000; i++) {
    vec.push_back(i);  // Nhiá»u reallocation
}
```

âœ“ NHANH:
```cpp
vector<int> vec;
vec.reserve(1000000);  // Pre-allocate
for (int i = 0; i < 1000000; i++) {
    vec.push_back(i);  // Ãt reallocation hÆ¡n
}
```

39.3. MOVE SEMANTICS (C++11)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ CHáº¬M:
```cpp
vector<int> func() {
    vector<int> result;
    // ... fill result
    return result;  // Copy (trÆ°á»›c C++11)
}
```

âœ“ NHANH:
```cpp
vector<int> func() {
    vector<int> result;
    // ... fill result
    return result;  // Move (C++11), khÃ´ng copy!
}
```

39.4. EMPLACE THAY VÃŒ PUSH
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ CHáº¬M:
```cpp
vector<string> vec;
vec.push_back(string("Hello"));  // Táº¡o temporary rá»“i copy
```

âœ“ NHANH:
```cpp
vector<string> vec;
vec.emplace_back("Hello");  // Construct trá»±c tiáº¿p, khÃ´ng copy
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 40: COMPILATION & TOOLS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

40.1. COMPILATION FLAGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GCC/G++:
```bash
# Basic
g++ program.cpp -o program

# Debug symbols
g++ -g program.cpp -o program

# Optimization
g++ -O2 program.cpp -o program  # O2 optimization
g++ -O3 program.cpp -o program  # O3 aggressive

# Warnings
g++ -Wall -Wextra -Werror program.cpp -o program

# C++ standard
g++ -std=c++11 program.cpp -o program
g++ -std=c++17 program.cpp -o program
g++ -std=c++20 program.cpp -o program

# All together
g++ -Wall -Wextra -std=c++17 -O2 program.cpp -o program
```

40.2. MAKEFILE EXAMPLE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```makefile
CXX = g++
CXXFLAGS = -Wall -Wextra -std=c++17 -O2
TARGET = program
SRCS = main.cpp class1.cpp class2.cpp
OBJS = $(SRCS:.cpp=.o)

$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(TARGET) $(OBJS)

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $<

clean:
	rm -f $(OBJS) $(TARGET)
```

40.3. COMMON COMPILER ERRORS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ERROR: undefined reference to ...
â†’ QuÃªn link file .cpp hoáº·c library

ERROR: multiple definition of ...
â†’ Define function/variable trong .h file (nÃªn declare only)

ERROR: cannot convert ... to ...
â†’ Type mismatch, cáº§n cast hoáº·c fix type

ERROR: no matching function for call to ...
â†’ Function signature khÃ´ng khá»›p, check parameters

ERROR: ... was not declared in this scope
â†’ QuÃªn include header hoáº·c using namespace

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Tá»”NG Káº¾T TOÃ€N Bá»˜ KHÃ“A Há»ŒC OOP C++
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PHáº¦N I: C++ FUNDAMENTALS
âœ“ References, Pointers, sizeof
âœ“ Default parameters, Pass by value/reference/pointer
âœ“ Type conversion

PHáº¦N II: OPERATOR OVERLOADING
âœ“ Arithmetic, Compound, Stream, Comparison operators
âœ“ Subscript, Function call, Assignment operators
âœ“ Const-correctness

PHáº¦N III: INHERITANCE & POLYMORPHISM
âœ“ Single/Multiple inheritance
âœ“ Constructor/Destructor order
âœ“ Virtual functions, Virtual destructor
âœ“ Polymorphism, Slicing problem

PHáº¦N IV: ADVANCED CONCEPTS
âœ“ Templates (function & class)
âœ“ Exception handling
âœ“ Copy control (Rule of Three/Five/Zero)
âœ“ Static members, Friend functions

PHáº¦N V: Tá»”NG Há»¢P & THá»°C HÃ€NH
âœ“ Top 20 lá»—i thÆ°á»ng gáº·p
âœ“ Best practices
âœ“ Checklist tá»•ng há»£p
âœ“ Debugging & Performance tips

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â­ Lá»œI KHUYÃŠN CUá»I CÃ™NG:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Ã”N Táº¬P THEO THá»¨ Tá»°:
   â†’ Part I â†’ Part II â†’ Part III â†’ Part IV â†’ Part V

2. THá»°C HÃ€NH CODE:
   â†’ Äá»c hiá»ƒu khÃ´ng Ä‘á»§, pháº£i viáº¿t code
   â†’ LÃ m láº¡i táº¥t cáº£ vÃ­ dá»¥ trong tÃ i liá»‡u
   â†’ Debug Ä‘á»ƒ hiá»ƒu cÃ¡ch hoáº¡t Ä‘á»™ng

3. Táº¬P TRUNG VÃ€O:
   â­â­â­ sizeof KHÃ”NG cÃ³ side effects
   â­â­â­ Virtual destructor
   â­â­â­ Constructor/Destructor order
   â­â­ Slicing problem
   â­â­ Deep copy vs Shallow copy

4. LÃ€M BÃ€I Táº¬P:
   â†’ Test1: References, pointers, sizeof, default parameters
   â†’ Test2: Operator overloading Ä‘áº§y Ä‘á»§
   â†’ Gki: Inheritance, constructors/destructors
   â†’ Test3: Virtual functions, polymorphism

5. CHECKLIST TRÆ¯á»šC THI:
   â–¡ Äá»c láº¡i 20 lá»—i thÆ°á»ng gáº·p
   â–¡ Review táº¥t cáº£ â­â­â­ sections
   â–¡ LÃ m láº¡i code tá»« test files
   â–¡ Check checklist tá»•ng há»£p

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHÃšC Báº N Há»ŒC Tá»T VÃ€ THI Äáº T ÄIá»‚M CAO! ğŸ“

TÃ i liá»‡u Ä‘Æ°á»£c tá»•ng há»£p tá»«:
- Test 1: C++ Fundamentals
- Test 2: Operator Overloading  
- Giá»¯a KÃ¬: Inheritance
- Test 3: Advanced OOP
- Code examples tá»« táº¥t cáº£ cÃ¡c file test

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
