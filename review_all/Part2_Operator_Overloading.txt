================================================================================
                   PHáº¦N II: OPERATOR OVERLOADING (Test 2)
================================================================================

TÃ i liá»‡u Ã´n táº­p chi tiáº¿t vá» Operator Overloading trong C++
Format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ VÃ­ dá»¥ code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p

================================================================================

Má»¤C Lá»¤C
â•â•â•â•â•â•â•

7. OPERATOR OVERLOADING CÆ  Báº¢N
   7.1. KhÃ¡i niá»‡m & Má»¥c Ä‘Ã­ch
   7.2. Member function syntax
   7.3. Friend function syntax
   7.4. Khi nÃ o dÃ¹ng member, khi nÃ o dÃ¹ng friend
   
8. ARITHMETIC OPERATORS (+, -, *, /)
   8.1. KhÃ¡i niá»‡m & Return type
   8.2. VÃ­ dá»¥ code (Test2/on_15.cpp, on_18.cpp)
   8.3. operator+ return by value
   8.4. Lá»—i thÆ°á»ng gáº·p: Return type sai
   
9. COMPOUND ASSIGNMENT (+=, -=, *=, /=)
   9.1. KhÃ¡i niá»‡m & Return reference
   9.2. Cho phÃ©p chain: a += b += c
   9.3. Implement operator+ báº±ng operator+=
   
10. STREAM OPERATORS (<<, >>)
    10.1. Táº¡i sao PHáº¢I lÃ  friend function
    10.2. VÃ­ dá»¥ code chi tiáº¿t (Test2/on_18.cpp)
    10.3. Return stream& Ä‘á»ƒ chain
    10.4. Lá»—i: LÃ m member function
    
11. COMPARISON OPERATORS (==, !=, <, >, <=, >=)
    11.1. Implement == vÃ  <
    11.2. Derive cÃ¡c toÃ¡n tá»­ khÃ¡c
    11.3. const-correctness
    
12. SUBSCRIPT OPERATOR ([])
    12.1. PHáº¢I lÃ  member function
    12.2. Return reference Ä‘á»ƒ gÃ¡n Ä‘Æ°á»£c (Test2/on_24.cpp)
    12.3. 2 versions: const vÃ  non-const
    12.4. Bounds checking
    
13. FUNCTION CALL OPERATOR (())
    13.1. Functors - Function objects (Test2/on_3.cpp)
    13.2. á»¨ng dá»¥ng trong STL
    
14. ASSIGNMENT OPERATOR (=)
    14.1. PHáº¢I lÃ  member function
    14.2. Self-assignment check (Test2/on_8.cpp)
    14.3. Return *this
    14.4. Deep copy
    
15. SPECIAL OPERATORS
    15.1. new & delete overloading
    15.2. Type conversion operators
    15.3. Comma operator
    
16. FUNCTION OVERLOADING
    16.1. Overload resolution
    16.2. Ambiguity vá»›i default parameters (Test2/on_1.cpp)
    16.3. Type promotion trong overloading
    
17. CONST-CORRECTNESS â­ Cá»°C Ká»² QUAN TRá»ŒNG
    17.1. Const member function
    17.2. Const parameters
    17.3. Const return type
    17.4. Checklist

================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 7: OPERATOR OVERLOADING CÆ  Báº¢N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

7.1. KHÃI NIá»†M & Má»¤C ÄÃCH
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Operator overloading cho phÃ©p Ä‘á»‹nh nghÄ©a láº¡i operators (+, -, *, /, [], <<, v.v.) 
Ä‘á»ƒ lÃ m viá»‡c vá»›i custom classes.

Má»¤C ÄÃCH:
âœ“ LÃ m code tá»± nhiÃªn, dá»… Ä‘á»c
âœ“ Giá»‘ng built-in types
âœ“ Há»— trá»£ STL algorithms

VÃ Dá»¤:
```cpp
// KHÃ”NG cÃ³ operator overloading:
Complex c3 = c1.add(c2);

// CÃ“ operator overloading:
Complex c3 = c1 + c2;  // âœ“ Tá»± nhiÃªn hÆ¡n!
```

7.2. MEMBER FUNCTION SYNTAX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CÃš PHÃP:
    ReturnType operator@(parameters)

VÃ Dá»¤:
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // Member function - 1 operand (right)
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
};

int main() {
    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;  // c1.operator+(c2)
}
```

CÃCH HOáº T Äá»˜NG:
    c1 + c2  â†’  c1.operator+(c2)
    Left operand = this
    Right operand = parameter

7.3. FRIEND FUNCTION SYNTAX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CÃš PHÃP:
    friend ReturnType operator@(left, right)

VÃ Dá»¤:
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // Friend function - 2 operands
    friend Complex operator+(const Complex& left, const Complex& right) {
        return Complex(left.real + right.real, left.imag + right.imag);
    }
};

int main() {
    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;  // operator+(c1, c2)
}
```

CÃCH HOáº T Äá»˜NG:
    c1 + c2  â†’  operator+(c1, c2)
    Left operand = first parameter
    Right operand = second parameter

7.4. KHI NÃ€O DÃ™NG MEMBER, KHI NÃ€O DÃ™NG FRIEND
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Báº¢NG QUYáº¾T Äá»ŠNH:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERATOR                     â”‚ DÃ™NG               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ =, [], (), ->                â”‚ MEMBER (báº¯t buá»™c)  â”‚
â”‚ <<, >>                       â”‚ FRIEND (báº¯t buá»™c)  â”‚
â”‚ +, -, *, /                   â”‚ Member hoáº·c Friend â”‚
â”‚ +=, -=, *=, /=               â”‚ MEMBER (khuyÃªn)    â”‚
â”‚ ==, !=, <, >, <=, >=         â”‚ Member hoáº·c Friend â”‚
â”‚ ++, -- (prefix)              â”‚ MEMBER             â”‚
â”‚ ++, -- (postfix)             â”‚ MEMBER             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

QUY Táº®C:
âœ“ DÃ¹ng MEMBER khi:
  - Left operand lÃ  object cá»§a class
  - Operators: =, [], (), ->, +=, -=, etc.
  
âœ“ DÃ¹ng FRIEND khi:
  - Left operand KHÃ”NG pháº£i object cá»§a class
  - Stream operators: <<, >>
  - Cáº§n symmetric operations

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 8: ARITHMETIC OPERATORS (+, -, *, /)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

8.1. KHÃI NIá»†M & RETURN TYPE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C QUAN TRá»ŒNG:
Arithmetic operators PHáº¢I return BY VALUE (new object), KHÃ”NG return reference!

Táº I SAO?
- Táº¡o object má»›i, khÃ´ng modify operands gá»‘c
- a + b khÃ´ng thay Ä‘á»•i a hay b
- Return reference â†’ Dangling reference (object local bá»‹ há»§y)

CÃš PHÃP:
```cpp
class MyClass {
    int value;
public:
    MyClass(int v = 0) : value(v) {}
    
    // âœ“ ÄÃšNG: Return by value
    MyClass operator+(const MyClass& other) const {
        return MyClass(value + other.value);
    }
    
    // âŒ SAI: Return by reference
    MyClass& operator+(const MyClass& other) const {
        MyClass result(value + other.value);  // Local variable
        return result;  // âŒ Dangling reference!
    }
};
```

8.2. VÃ Dá»¤ CODE Tá»ª TEST (Test2/on_18.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <iostream>
using namespace std;

class Base {
    int x;
public:
    Base(int x = 0);
    Base operator+(int);
    friend ostream& operator<<(ostream&, Base);
};

Base::Base(int x) : x(x) {}

Base Base::operator+(int x) {
    Base obj;
    obj.x = this->x + x;
    return obj;
}

ostream& operator<<(ostream& o, Base obj) {
    o << obj.x;
    return o;
}

int main() {
    Base obj1(1), obj2;
    obj2 = obj1 + 2;     // obj1.operator+(2)
                         // obj1.x (1) + 2 = 3
    cout << obj2;        // Output: 3
    return 0;
}
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. obj1 + 2:
   - Gá»i obj1.operator+(2)
   - this->x = 1
   - Táº¡o obj má»›i vá»›i x = 1 + 2 = 3
   - Return obj (by value)

2. obj2 = ...:
   - GÃ¡n obj vÃ o obj2
   - obj2.x = 3

3. cout << obj2:
   - Gá»i operator<<(cout, obj2)
   - In obj2.x = 3
   - Output: 3

8.3. BEST PRACTICES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ IMPLEMENT Äáº¦Y Äá»¦:
```cpp
class Complex {
    double real, imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    
    // operator+
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }
    
    // operator-
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }
    
    // operator*
    Complex operator*(const Complex& other) const {
        return Complex(
            real * other.real - imag * other.imag,
            real * other.imag + imag * other.real
        );
    }
    
    // operator/
    Complex operator/(const Complex& other) const {
        double denom = other.real * other.real + other.imag * other.imag;
        return Complex(
            (real * other.real + imag * other.imag) / denom,
            (imag * other.real - real * other.imag) / denom
        );
    }
};
```

8.4. Lá»–I THÆ¯á»œNG Gáº¶P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I 1: Return reference
```cpp
MyClass& operator+(const MyClass& other) const {
    MyClass result = ...;
    return result;  // âŒ Dangling reference!
}
```

âŒ Lá»–I 2: Modify this
```cpp
MyClass operator+(const MyClass& other) {
    value += other.value;  // âŒ KhÃ´ng nÃªn modify this!
    return *this;
}
```

âŒ Lá»–I 3: QuÃªn const
```cpp
MyClass operator+(const MyClass& other) {  // âŒ Thiáº¿u const
    // ...
}
```

âœ“ ÄÃšNG:
```cpp
MyClass operator+(const MyClass& other) const {
    return MyClass(value + other.value);
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 9: COMPOUND ASSIGNMENT (+=, -=, *=, /=)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

9.1. KHÃI NIá»†M & RETURN REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C QUAN TRá»ŒNG:
Compound assignment operators PHáº¢I return REFERENCE Ä‘áº¿n *this.

Táº I SAO?
- Modify object hiá»‡n táº¡i
- Cho phÃ©p chaining: a += b += c
- Giá»‘ng behavior cá»§a built-in types

CÃš PHÃP:
```cpp
class MyClass {
    int value;
public:
    MyClass(int v = 0) : value(v) {}
    
    // âœ“ ÄÃšNG: Return reference
    MyClass& operator+=(const MyClass& other) {
        value += other.value;
        return *this;
    }
    
    // âŒ SAI: Return by value
    MyClass operator+=(const MyClass& other) {
        value += other.value;
        return *this;  // âŒ Return copy, khÃ´ng thá»ƒ chain
    }
};
```

9.2. CHO PHÃ‰P CHAINING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class MyClass {
    int value;
public:
    MyClass(int v = 0) : value(v) {}
    
    MyClass& operator+=(const MyClass& other) {
        value += other.value;
        return *this;
    }
    
    void print() const { cout << value << endl; }
};

int main() {
    MyClass a(1), b(2), c(3);
    
    // Chaining:
    a += b += c;
    // TÆ°Æ¡ng Ä‘Æ°Æ¡ng: b.operator+=(c); a.operator+=(b);
    // b = b + c = 2 + 3 = 5
    // a = a + b = 1 + 5 = 6
    
    a.print();  // 6
    b.print();  // 5
}
```

9.3. IMPLEMENT operator+ Báº°NG operator+=
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEST PRACTICE:
Implement += trÆ°á»›c, rá»“i dÃ¹ng nÃ³ Ä‘á»ƒ implement +

```cpp
class MyClass {
    int value;
public:
    MyClass(int v = 0) : value(v) {}
    
    // Implement += trÆ°á»›c
    MyClass& operator+=(const MyClass& other) {
        value += other.value;
        return *this;
    }
    
    // Implement + dá»±a trÃªn +=
    MyClass operator+(const MyClass& other) const {
        MyClass result = *this;  // Copy
        result += other;         // DÃ¹ng +=
        return result;
    }
};
```

Æ¯U ÄIá»‚M:
âœ“ Code reuse
âœ“ Consistency
âœ“ Dá»… maintain

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 10: STREAM OPERATORS (<<, >>)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

10.1. Táº I SAO PHáº¢I LÃ€ FRIEND FUNCTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C QUAN TRá»ŒNG:
Stream operators << vÃ  >> PHáº¢I lÃ  FRIEND FUNCTIONS, KHÃ”NG THá»‚ lÃ  member functions!

Táº I SAO?
- Left operand lÃ  stream (cout, cin), khÃ´ng pháº£i object cá»§a class
- KhÃ´ng thá»ƒ modify class cá»§a stream (std::ostream, std::istream)
- Cáº§n access private members

HÃŒNH DUNG:
    cout << obj;
    
    // Náº¿u lÃ  member function:
    cout.operator<<(obj);  // âŒ KhÃ´ng thá»ƒ! cout lÃ  std::ostream
    
    // Pháº£i lÃ  friend function:
    operator<<(cout, obj);  // âœ“ OK!

10.2. VÃ Dá»¤ CODE Tá»ª TEST (Test2/on_18.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <iostream>
using namespace std;

class Base {
    int x;
public:
    Base(int x = 0) : x(x) {}
    
    // âœ“ ÄÃšNG: Friend function
    friend ostream& operator<<(ostream& o, Base obj) {
        o << obj.x;
        return o;
    }
};

int main() {
    Base obj(42);
    cout << obj;  // Output: 42
}
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. cout << obj:
   - Gá»i operator<<(cout, obj)
   - o lÃ  reference Ä‘áº¿n cout
   - obj lÃ  object cáº§n in
   - o << obj.x in giÃ¡ trá»‹ x
   - Return o Ä‘á»ƒ chain

2. Chaining:
   cout << obj1 << obj2 << obj3;
   // operator<<(operator<<(operator<<(cout, obj1), obj2), obj3)

10.3. RETURN STREAM& Äá»‚ CHAIN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
Stream operators PHáº¢I return stream& Ä‘á»ƒ chain Ä‘Æ°á»£c.

VÃ Dá»¤ Äáº¦Y Äá»¦:
```cpp
class Point {
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}
    
    // operator<< (output)
    friend ostream& operator<<(ostream& os, const Point& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;  // âœ“ Return reference!
    }
    
    // operator>> (input)
    friend istream& operator>>(istream& is, Point& p) {
        is >> p.x >> p.y;
        return is;  // âœ“ Return reference!
    }
};

int main() {
    Point p1, p2, p3;
    
    // Input chaining:
    cin >> p1 >> p2 >> p3;
    
    // Output chaining:
    cout << p1 << " " << p2 << " " << p3 << endl;
}
```

10.4. Lá»–I THÆ¯á»œNG Gáº¶P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I 1: LÃ m member function
```cpp
class MyClass {
public:
    ostream& operator<<(ostream& os) {  // âŒ SAI!
        os << value;
        return os;
    }
};

// Gá»i: obj << cout;  // âŒ NgÆ°á»£c!
```

âŒ Lá»–I 2: KhÃ´ng return reference
```cpp
friend ostream operator<<(ostream& os, const MyClass& obj) {  // âŒ SAI!
    os << obj.value;
    return os;  // âŒ Return by value, khÃ´ng chain Ä‘Æ°á»£c
}
```

âŒ Lá»–I 3: Return void
```cpp
friend void operator<<(ostream& os, const MyClass& obj) {  // âŒ SAI!
    os << obj.value;
    // âŒ KhÃ´ng return, khÃ´ng chain Ä‘Æ°á»£c
}
```

âœ“ ÄÃšNG:
```cpp
friend ostream& operator<<(ostream& os, const MyClass& obj) {
    os << obj.value;
    return os;  // âœ“ Return reference
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 11: COMPARISON OPERATORS (==, !=, <, >, <=, >=)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

11.1. IMPLEMENT == VÃ€ <
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEST PRACTICE:
Chá»‰ cáº§n implement == vÃ  <, cÃ¡c operators khÃ¡c derive tá»« chÃºng.

VÃ Dá»¤:
```cpp
class Point {
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}
    
    // Implement == trÆ°á»›c
    bool operator==(const Point& other) const {
        return x == other.x && y == other.y;
    }
    
    // Derive != tá»« ==
    bool operator!=(const Point& other) const {
        return !(*this == other);
    }
    
    // Implement < trÆ°á»›c
    bool operator<(const Point& other) const {
        if (x != other.x) return x < other.x;
        return y < other.y;
    }
    
    // Derive cÃ¡c operators khÃ¡c tá»« <
    bool operator>(const Point& other) const {
        return other < *this;
    }
    
    bool operator<=(const Point& other) const {
        return !(other < *this);
    }
    
    bool operator>=(const Point& other) const {
        return !(*this < other);
    }
};
```

11.2. CONST-CORRECTNESS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUAN TRá»ŒNG:
Comparison operators PHáº¢I lÃ  const member functions!

```cpp
bool operator==(const Point& other) const {  // âœ“ const
    return x == other.x && y == other.y;
}
```

Táº I SAO?
- KhÃ´ng modify object
- Cho phÃ©p compare const objects

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 12: SUBSCRIPT OPERATOR ([])
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

12.1. PHáº¢I LÃ€ MEMBER FUNCTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
operator[] PHáº¢I lÃ  member function, KHÃ”NG THá»‚ lÃ  friend!

12.2. RETURN REFERENCE Äá»‚ GÃN ÄÆ¯á»¢C (Test2/on_24.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <iostream>
using namespace std;

const int SIZE = 10;

class Exam {
    int arr[SIZE];
public:
    Exam();
    ~Exam() {}
    int& operator[](const int& index);  // âœ“ Return reference!
};

Exam::Exam() {
    for (int i = 0; i < SIZE; ++i) {
        this->arr[i] = i;
    }
}

int& Exam::operator[](const int& index) {
    static int temp = 0;        // Tráº£ vá» khi vÆ°á»£t biÃªn
    if (index > SIZE) {         // ChÃº Ã½: > SIZE, khÃ´ng pháº£i >=
        return temp;
    }
    return this->arr[index];    // âœ“ Return reference!
}

int main() {
    Exam obj;
    cout << obj[5] << obj[12];  // Output: 50
    
    // VÃ¬ return reference, cÃ³ thá»ƒ gÃ¡n:
    obj[3] = 100;  // âœ“ OK!
    cout << obj[3];  // 100
}
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. obj[5]:
   - index = 5 < SIZE (10) â†’ OK
   - Return arr[5] = 5
   
2. obj[12]:
   - index = 12 > SIZE (10) â†’ VÆ°á»£t biÃªn
   - Return temp = 0
   
3. Output: 50

Láº I SAO RETURN REFERENCE?
- Äá»ƒ cÃ³ thá»ƒ gÃ¡n: obj[i] = value
- Náº¿u return by value â†’ obj[i] = value khÃ´ng cÃ³ hiá»‡u lá»±c

12.3. 2 VERSIONS: CONST VÃ€ NON-CONST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEST PRACTICE:
Implement 2 versions cá»§a operator[]

```cpp
class Array {
    int* data;
    int size;
public:
    Array(int s) : size(s) {
        data = new int[size];
    }
    
    ~Array() {
        delete[] data;
    }
    
    // Non-const version (cÃ³ thá»ƒ modify)
    int& operator[](int index) {
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }
    
    // Const version (chá»‰ Ä‘á»c)
    const int& operator[](int index) const {
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }
};

int main() {
    Array arr(10);
    arr[5] = 42;  // âœ“ Non-const version
    
    const Array const_arr(10);
    int x = const_arr[5];  // âœ“ Const version
    // const_arr[5] = 42;  // âŒ ERROR: const
}
```

12.4. BOUNDS CHECKING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ AN TOÃ€N:
```cpp
int& operator[](int index) {
    if (index < 0 || index >= size) {
        throw out_of_range("Index out of bounds");
    }
    return data[index];
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 13: FUNCTION CALL OPERATOR (())
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

13.1. FUNCTORS - FUNCTION OBJECTS (Test2/on_3.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Functor lÃ  object cÃ³ thá»ƒ gá»i nhÆ° function (overload operator()).

VÃ Dá»¤ Tá»ª TEST:
```cpp
#include<iostream>
using namespace std;

class Exam {
public:
    void operator()(int);
};

void Exam::operator()(int var_i) {
    cout << var_i;
}

int main(){
    Exam obj;
    obj(5);  // Gá»i nhÆ° function! Output: 5
    return 0;
}
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. obj(5):
   - Gá»i obj.operator()(5)
   - var_i = 5
   - In ra 5

2. Object hoáº¡t Ä‘á»™ng nhÆ° function!

13.2. á»¨NG Dá»¤NG TRONG STL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ THá»°C Táº¾:
```cpp
#include <algorithm>
#include <vector>
using namespace std;

// Functor Ä‘á»ƒ so sÃ¡nh
class Compare {
public:
    bool operator()(int a, int b) const {
        return a > b;  // Descending order
    }
};

int main() {
    vector<int> vec = {3, 1, 4, 1, 5};
    
    // DÃ¹ng functor vá»›i STL
    sort(vec.begin(), vec.end(), Compare());
    // vec: {5, 4, 3, 1, 1}
}
```

VÃ Dá»¤ Vá»šI STATE:
```cpp
class Accumulator {
    int sum;
public:
    Accumulator() : sum(0) {}
    
    void operator()(int value) {
        sum += value;
    }
    
    int getSum() const { return sum; }
};

int main() {
    Accumulator acc;
    acc(10);
    acc(20);
    acc(30);
    cout << acc.getSum();  // 60
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 14: ASSIGNMENT OPERATOR (=)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

14.1. PHáº¢I LÃ€ MEMBER FUNCTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
operator= PHáº¢I lÃ  member function, KHÃ”NG THá»‚ lÃ  friend!

14.2. SELF-ASSIGNMENT CHECK (Test2/on_8.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST:
```cpp
#include<iostream>
using namespace std;

class Exam {
    int prop;
public:
    Exam(int = 1);
    Exam(const Exam&);
    ~Exam();
    const Exam& operator=(const Exam&);
};

Exam::Exam(int prop) : prop(prop) {
    cout << "1";
}

Exam::Exam(Exam const& obj) : prop(obj.prop) {
    cout << "2";
}

Exam::~Exam() {}

const Exam& Exam::operator=(Exam const& obj) {
    if (this != &obj) {  // â­ Self-assignment check!
        this->prop = obj.prop;
        cout << "3";
    }
    return *this;
}

Exam Func() {
    Exam obj;   // Constructor: "1"
    return obj; // Return by value
}

int main() {
    Exam obj;       // Constructor: "1"
    obj = Func();   // Func() táº¡o obj, return, gÃ¡n
                    // Output: "113"
    return 0;
}
```

PHÃ‚N TÃCH OUTPUT:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. "1": Exam obj trong main() - Constructor
2. "1": Exam obj trong Func() - Constructor
3. "3": obj = Func() - Assignment operator

â­ Táº I SAO Cáº¦N SELF-ASSIGNMENT CHECK?
```cpp
MyClass obj;
obj = obj;  // Self-assignment!

// Náº¿u khÃ´ng check:
// 1. Delete old data (obj's data)
// 2. Copy from obj (nhÆ°ng Ä‘Ã£ delete rá»“i!) â†’ âŒ CRASH!

// Vá»›i check:
if (this != &obj) {
    // Chá»‰ thá»±c hiá»‡n khi khÃ´ng pháº£i self-assignment
}
```

14.3. RETURN *this
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
operator= PHáº¢I return reference Ä‘áº¿n *this Ä‘á»ƒ chain Ä‘Æ°á»£c.

VÃ Dá»¤:
```cpp
const MyClass& operator=(const MyClass& other) {
    if (this != &other) {
        // Deep copy
    }
    return *this;  // âœ“ Return *this
}

// Chaining:
a = b = c;
// b.operator=(c); a.operator=(b);
```

14.4. DEEP COPY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Äáº¦Y Äá»¦:
```cpp
class MyString {
    char* data;
    int length;
public:
    MyString(const char* str = "") {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
    
    ~MyString() {
        delete[] data;
    }
    
    // Assignment operator vá»›i deep copy
    MyString& operator=(const MyString& other) {
        // 1. Self-assignment check
        if (this != &other) {
            // 2. Delete old data
            delete[] data;
            
            // 3. Deep copy new data
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        
        // 4. Return *this
        return *this;
    }
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 15: SPECIAL OPERATORS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

15.1. COMMA OPERATOR (,)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class MyClass {
    int value;
public:
    MyClass(int v = 0) : value(v) {}
    
    MyClass operator,(const MyClass& other) {
        return other;  // Return right operand
    }
    
    void print() { cout << value << endl; }
};

int main() {
    MyClass a(1), b(2), c(3);
    MyClass result = (a, b, c);  // result = c
    result.print();  // 3
}
```

15.2. TYPE CONVERSION OPERATORS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class MyInt {
    int value;
public:
    MyInt(int v = 0) : value(v) {}
    
    // Conversion to int
    operator int() const {
        return value;
    }
    
    // Conversion to double
    operator double() const {
        return static_cast<double>(value);
    }
};

int main() {
    MyInt obj(42);
    
    int i = obj;     // Implicit conversion to int
    double d = obj;  // Implicit conversion to double
    
    cout << i << " " << d;  // 42 42
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 16: FUNCTION OVERLOADING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

16.1. OVERLOAD RESOLUTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

QUY Táº®C:
Compiler chá»n function tá»‘t nháº¥t dá»±a trÃªn:
1. Exact match (tá»‘t nháº¥t)
2. Promotion (char â†’ int, float â†’ double)
3. Standard conversion (int â†’ double)
4. User-defined conversion

VÃ Dá»¤:
```cpp
void func(int x) { cout << "int"; }
void func(double x) { cout << "double"; }
void func(char x) { cout << "char"; }

func(10);      // "int" - Exact match
func(10.5);    // "double" - Exact match
func('a');     // "char" - Exact match
func(10.5f);   // "double" - Promotion (float â†’ double)
```

16.2. AMBIGUITY Vá»šI DEFAULT PARAMETERS (Test2/on_1.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ÄÃƒ PHÃ‚N TÃCH á» PHáº¦N I - CHAPTER 4.3

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 17: CONST-CORRECTNESS â­ Cá»°C Ká»² QUAN TRá»ŒNG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

17.1. CONST MEMBER FUNCTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
Member functions KHÃ”NG modify object PHáº¢I lÃ  const!

VÃ Dá»¤:
```cpp
class Point {
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}
    
    // âœ“ Const: KhÃ´ng modify
    int getX() const { return x; }
    int getY() const { return y; }
    void print() const { cout << x << ", " << y; }
    
    // Non-const: Modify object
    void setX(int newX) { x = newX; }
    void setY(int newY) { y = newY; }
};
```

17.2. CONST PARAMETERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ DÃ™NG const& CHO PARAMETERS KHÃ”NG MODIFY:
```cpp
class MyClass {
public:
    // âœ“ const parameter
    MyClass operator+(const MyClass& other) const {
        // ...
    }
    
    // âœ“ const parameter
    bool operator==(const MyClass& other) const {
        // ...
    }
};
```

17.3. CHECKLIST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â–¡ Getters: const member functions
â–¡ Comparison operators: const member functions
â–¡ Stream operators: const parameters
â–¡ Arithmetic operators: const parameters, const member functions
â–¡ operator[]: 2 versions (const vÃ  non-const)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Tá»”NG Káº¾T PHáº¦N II: OPERATOR OVERLOADING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHECKLIST QUAN TRá»ŒNG:
â–¡ =, [], (), -> PHáº¢I lÃ  member functions
â–¡ <<, >> PHáº¢I lÃ  friend functions
â–¡ Arithmetic (+, -, *, /) return BY VALUE
â–¡ Compound (+=, -=, *=, /=) return REFERENCE
â–¡ Stream operators return stream&
â–¡ operator= cáº§n self-assignment check
â–¡ operator= cáº§n deep copy vá»›i dynamic memory
â–¡ Comparison operators nÃªn lÃ  const
â–¡ operator[] return reference Ä‘á»ƒ gÃ¡n Ä‘Æ°á»£c
â–¡ operator[] nÃªn cÃ³ 2 versions (const vÃ  non-const)

ÄÃƒ Há»ŒC Tá»ª CODE TEST:
âœ“ Test2/on_1.cpp: Ambiguity vá»›i overloading + default
âœ“ Test2/on_3.cpp: Function call operator (functors)
âœ“ Test2/on_8.cpp: Assignment operator vá»›i self-check
âœ“ Test2/on_18.cpp: Arithmetic vÃ  stream operators
âœ“ Test2/on_24.cpp: Subscript operator return reference

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIáº¾P Tá»¤C Vá»šI PHáº¦N III: INHERITANCE & POLYMORPHISM
Xem file Part3_Inheritance_Polymorphism.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
