================================================================================
                   PHáº¦N I: C++ FUNDAMENTALS (Test 1)
================================================================================

TÃ i liá»‡u Ã´n táº­p chi tiáº¿t vá» cÃ¡c khÃ¡i niá»‡m cÆ¡ báº£n trong C++
Format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ VÃ­ dá»¥ code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p

================================================================================

Má»¤C Lá»¤C
â•â•â•â•â•â•â•

1. REFERENCES (THAM CHIáº¾U)
   1.1. KhÃ¡i niá»‡m cÆ¡ báº£n & Syntax
   1.2. Reference binding & LÆ°u Ã½
   1.3. VÃ­ dá»¥ code thá»±c táº¿ (Test1/on_1.cpp)
   1.4. Const reference
   1.5. Dangling reference - Lá»—i nguy hiá»ƒm
   
2. POINTERS (CON TRá»)
   2.1. KhÃ¡i niá»‡m & ToÃ¡n tá»­ *, &
   2.2. Null pointer
   2.3. Pointer arithmetic
   2.4. Reference vs Pointer - So sÃ¡nh chi tiáº¿t
   
3. SIZEOF OPERATOR â­ QUAN TRá»ŒNG
   3.1. KhÃ¡i niá»‡m cÆ¡ báº£n
   3.2. sizeof KHÃ”NG cÃ³ side effects (Test1/on_44.cpp)
   3.3. sizeof vá»›i array
   3.4. Array decay - Lá»—i cá»±c ká»³ thÆ°á»ng gáº·p
   3.5. sizeof vá»›i pointer
   3.6. sizeof vá»›i class/struct (padding)
   3.7. sizeof vá»›i inheritance
   3.8. sizeof vá»›i empty class
   3.9. TÃ³m táº¯t quan trá»ng
   
4. DEFAULT PARAMETERS
   4.1. KhÃ¡i niá»‡m & CÃº phÃ¡p
   4.2. Quy táº¯c vÃ ng: Default pháº£i á»Ÿ cuá»‘i
   4.3. Ambiguity vá»›i function overloading (Test2/on_1.cpp)
   4.4. Lá»—i thÆ°á»ng gáº·p
   
5. PASS BY VALUE/REFERENCE/POINTER
   5.1. Pass by value
   5.2. Pass by reference
   5.3. Pass by pointer
   5.4. Báº£ng quyáº¿t Ä‘á»‹nh khi nÃ o dÃ¹ng cÃ¡i gÃ¬
   
6. TYPE CONVERSION
   6.1. Implicit conversion
   6.2. Type promotion hierarchy
   6.3. Explicit cast

================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 1: REFERENCES (THAM CHIáº¾U)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Reference (tham chiáº¿u) lÃ  má»™t ALIAS (bÃ­ danh) cho má»™t biáº¿n Ä‘Ã£ tá»“n táº¡i.
NÃ³ KHÃ”NG pháº£i lÃ  má»™t object má»›i, mÃ  chá»‰ lÃ  "tÃªn khÃ¡c" cá»§a biáº¿n gá»‘c.

CÃš PHÃP:
    int x = 10;
    int& ref = x;  // ref lÃ  bÃ­ danh cá»§a x
    
    ref = 20;      // Thay Ä‘á»•i ref = thay Ä‘á»•i x
    cout << x;     // 20

HÃŒNH DUNG:
    Biáº¿n gá»‘c: [x: 10] â† Äá»‹a chá»‰ 0x1000
    Reference: [ref] â†’ CÅ©ng trá» Ä‘áº¿n 0x1000
    
    Khi thay Ä‘á»•i ref â†’ Thay Ä‘á»•i trá»±c tiáº¿p x

Äáº¶C ÄIá»‚M QUAN TRá»ŒNG:
âœ“ PHáº¢I khá»Ÿi táº¡o ngay khi khai bÃ¡o
  int& ref;  // âŒ ERROR! Pháº£i khá»Ÿi táº¡o
  
âœ“ KHÃ”NG THá»‚ thay Ä‘á»•i target (re-bind) sau khi khá»Ÿi táº¡o
  int x = 10, y = 20;
  int& ref = x;
  ref = y;  // GÃ¡n giÃ¡ trá»‹ y cho x, KHÃ”NG pháº£i ref trá» sang y
  
âœ“ KHÃ”NG cÃ³ null reference
  int& ref = nullptr;  // âŒ ERROR!
  
âœ“ KHÃ”NG chiáº¿m thÃªm memory (compiler optimization)
  sizeof(ref) == sizeof(int), khÃ´ng cÃ³ overhead

1.2. VÃ Dá»¤ CODE THá»°C Táº¾ (Test1/on_1.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <iostream>
using namespace std;

int main(){
    int var_x = 2, var_y = 6;
    int& ref_x = var_x;  // ref_x lÃ  alias cá»§a var_x
    int& ref_y = var_y;  // ref_y lÃ  alias cá»§a var_y

    // Test 1: TÄƒng biáº¿n gá»‘c
    var_x++;
    cout << var_x << " " << ref_x << endl;  // 3 3
    
    // Test 2: TÄƒng reference
    ref_x++;
    cout << var_x << " " << ref_x << endl;  // 4 4
    
    // Test 3: PhÃ©p gÃ¡n phá»©c táº¡p
    var_x = ref_x++; 
    cout << var_x << " " << ref_x << endl;  // 4 4
    
    return 0;
}
```

PHÃ‚N TÃCH CHI TIáº¾T:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ban Ä‘áº§u:
    var_x = 2, ref_x â†’ var_x

Test 1: var_x++
    var_x = 3, ref_x = 3 (cÃ¹ng biáº¿n)
    Output: 3 3 âœ“

Test 2: ref_x++
    ref_x tÄƒng = var_x tÄƒng
    var_x = 4, ref_x = 4
    Output: 4 4 âœ“

Test 3: var_x = ref_x++
    PhÃ©p gÃ¡n cÃ³ thá»© tá»±:
    1. TÃ­nh ref_x++ (postfix)
       - Tráº£ vá» giÃ¡ trá»‹ CÅ¨: 4
       - TÄƒng sau: ref_x = 5 (var_x = 5)
    2. GÃ¡n: var_x = 4
    
    Káº¿t quáº£:
    - var_x = 4 (giÃ¡ trá»‹ cÅ© cá»§a ref_x)
    - ref_x = var_x = 4 (vÃ¬ ref_x lÃ  alias cá»§a var_x)
    
    â“ Táº¡i sao khÃ´ng pháº£i 4 5?
    â†’ VÃ¬ sau khi ref_x++ (ref_x/var_x = 5)
    â†’ var_x = 4 gÃ¡n láº¡i, ghi Ä‘Ã¨ lÃªn giÃ¡ trá»‹ 5
    â†’ Cáº£ var_x vÃ  ref_x Ä‘á»u = 4
    
    Output: 4 4 âœ“ (KHÃ”NG pháº£i 4 5!)

1.3. CONST REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Const reference cho phÃ©p truy cáº­p biáº¿n mÃ  KHÃ”NG thay Ä‘á»•i giÃ¡ trá»‹.

CÃš PHÃP:
    void print(const int& x) {
        cout << x;      // âœ“ OK: Ä‘á»c Ä‘Æ°á»£c
        // x = 10;      // âŒ ERROR: khÃ´ng thá»ƒ thay Ä‘á»•i
    }

Æ¯U ÄIá»‚M:
âœ“ KHÃ”NG copy â†’ Efficient (tiáº¿t kiá»‡m memory & time)
âœ“ KHÃ”NG thay Ä‘á»•i â†’ Safe (clear intent)
âœ“ CÃ“ THá»‚ nháº­n temporary/rvalue
âœ“ Self-documenting code (rÃµ Ã½ nghÄ©a)

VÃ Dá»¤ NHáº¬N TEMPORARY:
    void print(const int& x) {
        cout << x;
    }
    
    int val = 5;
    print(val);      // âœ“ OK: Bind vá»›i lvalue
    print(10);       // âœ“ OK: Bind vá»›i rvalue (temporary)
    print(3 + 4);    // âœ“ OK: Bind vá»›i expression result
    
    // Non-const reference khÃ´ng bind Ä‘Æ°á»£c rvalue:
    void modify(int& x) {
        x++;
    }
    
    modify(10);      // âŒ ERROR: Cannot bind rvalue to non-const reference

1.4. DANGLING REFERENCE - Lá»–I NGUY HIá»‚M
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Dangling reference xáº£y ra khi reference trá» Ä‘áº¿n biáº¿n Ä‘Ã£ bá»‹ há»§y.

âŒ Lá»–I Cá»°C Ká»² NGUY HIá»‚M:
    int& getReference() {
        int x = 10;        // Local variable
        return x;          // âŒ NGUY HIá»‚M! x bá»‹ há»§y sau khi return
    }
    
    int main() {
        int& ref = getReference();
        cout << ref;       // âš ï¸ UNDEFINED BEHAVIOR!
    }

QUY Táº®C AN TOÃ€N:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âŒ KHÃ”NG return reference Ä‘áº¿n:
   - Local variable
   - Temporary object
   - Deleted memory
   - Parameter passed by value

âœ“ CÃ“ THá»‚ return reference Ä‘áº¿n:
   - Static variable
   - Global variable
   - Member variable (náº¿u object tá»“n táº¡i)
   - Parameter passed by reference (náº¿u cháº¯c tá»“n táº¡i)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 2: POINTERS (CON TRá»)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Pointer (con trá») lÃ  biáº¿n lÆ°u trá»¯ Äá»ŠA CHá»ˆ cá»§a biáº¿n khÃ¡c.

CÃš PHÃP:
    int x = 10;
    int* ptr = &x;  // ptr lÆ°u Ä‘á»‹a chá»‰ cá»§a x
    
    cout << ptr;    // In Ä‘á»‹a chá»‰ (VD: 0x7ffd5b2c3e4c)
    cout << *ptr;   // In giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰: 10
    
    *ptr = 20;      // Thay Ä‘á»•i giÃ¡ trá»‹ x qua pointer
    cout << x;      // 20

TOÃN Tá»¬:
- & : Address-of operator (láº¥y Ä‘á»‹a chá»‰)
- * : Dereference operator (láº¥y giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰)

2.2. REFERENCE VS POINTER - SO SÃNH CHI TIáº¾T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Báº¢NG SO SÃNH:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Äáº¶C ÄIá»‚M             â”‚ REFERENCE            â”‚ POINTER                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Khá»Ÿi táº¡o             â”‚ Báº®T BUá»˜C ngay        â”‚ KhÃ´ng báº¯t buá»™c         â”‚
â”‚ Null                 â”‚ KHÃ”NG THá»‚            â”‚ CÃ³ thá»ƒ (nullptr)       â”‚
â”‚ Re-assign (Ä‘á»•i má»¥c)  â”‚ KHÃ”NG THá»‚            â”‚ CÃ³ thá»ƒ                 â”‚
â”‚ Syntax truy cáº­p      â”‚ ÄÆ¡n giáº£n (.)         â”‚ Phá»©c táº¡p (*, ->)       â”‚
â”‚ Memory overhead      â”‚ KhÃ´ng (optimized)    â”‚ CÃ³ (4/8 bytes)         â”‚
â”‚ Safety               â”‚ An toÃ n hÆ¡n          â”‚ Dá»… lá»—i hÆ¡n             â”‚
â”‚ Arithmetic           â”‚ KhÃ´ng cÃ³             â”‚ CÃ³ (ptr++, ptr+n)      â”‚
â”‚ Use case chÃ­nh       â”‚ Function parameters  â”‚ Dynamic allocation     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VÃ Dá»¤ SO SÃNH:
```cpp
int x = 10, y = 20;

// REFERENCE:
int& ref = x;    // Pháº£i khá»Ÿi táº¡o ngay
ref = 30;        // x = 30
ref = y;         // x = 20 (GÃN GIÃ TRá»Š, KHÃ”NG Ä‘á»•i target)

// POINTER:
int* ptr = &x;   // ptr trá» Ä‘áº¿n x
*ptr = 30;       // x = 30
ptr = &y;        // ptr GIá»œ TRá» SANG y (Äá»”I TARGET)
*ptr = 50;       // y = 50, x váº«n = 30
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 3: SIZEOF OPERATOR â­ Cá»°C Ká»² QUAN TRá»ŒNG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

3.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
sizeof lÃ  operator tráº£ vá» kÃ­ch thÆ°á»›c (sá»‘ bytes) cá»§a type hoáº·c variable.

CÃš PHÃP:
    sizeof(type)
    sizeof(variable)
    sizeof variable  // KhÃ´ng cáº§n () vá»›i variable

VÃ Dá»¤:
    cout << sizeof(int);      // 4 (bytes)
    cout << sizeof(char);     // 1
    cout << sizeof(double);   // 8
    cout << sizeof(float);    // 4

Äáº¶C ÄIá»‚M QUAN TRá»ŒNG:
âœ“ sizeof lÃ  COMPILE-TIME operator
âœ“ Return type lÃ  size_t
âœ“ ÄÆ¡n vá»‹: BYTES (khÃ´ng pháº£i bits)

3.2. â­â­â­ sizeof KHÃ”NG CÃ“ SIDE EFFECTS â­â­â­
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ÄÃ¢y lÃ  Ä‘iá»u QUAN TRá»ŒNG NHáº¤T cáº§n nhá»› vá» sizeof!

VÃ Dá»¤ Tá»ª TEST (Test1/on_44.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

int main(){
    int x = 5;
    int y = sizeof(x++);  // sizeof KHÃ”NG THá»°C HIá»†N x++
    
    cout << x << y;  // Output: 54
    // x = 5 (KHÃ”NG Ä‘á»•i!)
    // y = 4 (sizeof(int))
    return 0;
}
```

PHÃ‚N TÃCH:
- sizeof chá»‰ quan tÃ¢m TYPE cá»§a x++
- x++ cÃ³ type lÃ  int
- sizeof(int) = 4
- x++ KHÃ”NG Ä‘Æ°á»£c thá»±c thi!
- y = 4, x = 5 (khÃ´ng Ä‘á»•i)

VÃ Dá»¤ Tá»ª TEST (Test1/on_32.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

int main(){
    int x = 5;
    float y;
    cout << sizeof(x + y) << endl;        // 4 (sizeof(float))
    cout << sizeof(++x + y) << x << endl; // 45
    // x váº«n = 5 vÃ¬ ++x trong sizeof KHÃ”NG cháº¡y!
}
```

QUAN TRá»ŒNG:
ğŸ”¥ sizeof KHÃ”NG BAO GIá»œ cÃ³ side effects
ğŸ”¥ sizeof chá»‰ quan tÃ¢m TYPE, khÃ´ng quan tÃ¢m VALUE
ğŸ”¥ Má»i expression bÃªn trong sizeof KHÃ”NG Ä‘Æ°á»£c evaluate

3.3. SIZEOF Vá»šI ARRAY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sizeof vá»›i array tráº£ vá» Tá»”NG kÃ­ch thÆ°á»›c táº¥t cáº£ pháº§n tá»­.

VÃ Dá»¤:
    int arr[10];
    cout << sizeof(arr);        // 40 (10 * 4)
    cout << sizeof(arr[0]);     // 4
    
    // CÃ´ng thá»©c tÃ­nh sá»‘ pháº§n tá»­:
    int length = sizeof(arr) / sizeof(arr[0]);  // 10

3.4. âš ï¸ ARRAY DECAY - Lá»–I Cá»°C Ká»² THÆ¯á»œNG Gáº¶P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Khi truyá»n array vÃ o function, nÃ³ "decay" thÃ nh POINTER.

âŒ Lá»–I KINH ÄIá»‚N:
```cpp
void func(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // âŒ SAI!
    cout << size;  // KhÃ´ng pháº£i 10!
}

int main() {
    int arr[10];
    cout << sizeof(arr);  // 40 (âœ“ Ä‘Ãºng - trong main)
    func(arr);  // arr decay thÃ nh pointer
}
```

âœ“ GIáº¢I PHÃP: Truyá»n size nhÆ° tham sá»‘
```cpp
void func(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i];
    }
}

int main() {
    int arr[10];
    func(arr, sizeof(arr)/sizeof(arr[0]));
}
```

3.9. TÃ“M Táº®T QUAN TRá»ŒNG
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CHECKLIST:
â–¡ sizeof KHÃ”NG cÃ³ side effects
â–¡ sizeof(array) trong function = sizeof(pointer)
â–¡ sizeof(pointer) = 4 (32-bit) hoáº·c 8 (64-bit)
â–¡ sizeof(class) bao gá»“m padding
â–¡ sizeof(Empty class) = 1

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 4: DEFAULT PARAMETERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

4.1. KHÃI NIá»†M & CÃš PHÃP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Default parameters cho phÃ©p gá»i function mÃ  khÃ´ng cáº§n truyá»n táº¥t cáº£ arguments.

CÃš PHÃP:
    void func(int x, int y = 10, int z = 5) {
        cout << x + y + z;
    }
    
    func(1, 2, 3);  // x=1, y=2, z=3 â†’ Output: 6
    func(1, 2);     // x=1, y=2, z=5 â†’ Output: 8
    func(1);        // x=1, y=10, z=5 â†’ Output: 16

VÃ Dá»¤ Tá»ª TEST (Test1/on_33.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

void Func(int x, int y = 4) {
    cout << x << y << endl;
}

int main(){
    Func(2, 3);  // Output: 23
    Func(5);     // Output: 54 (y dÃ¹ng default = 4)
    return 0;
}
```

VÃ Dá»¤ Tá»ª TEST (Test1/on_36.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

int Func(int x = 5, int y = 10, int z = 5) {
    return x + y + z;
}

int main(){
    cout << Func(10, 2, 3);  // 10 + 2 + 3 = 15
    return 0;
}
```

4.2. QUY Táº®C VÃ€NG: DEFAULT PHáº¢I á» CUá»I
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C QUAN TRá»ŒNG:
Default parameters PHáº¢I náº±m á»Ÿ CUá»I danh sÃ¡ch parameters.

âœ“ ÄÃšNG:
    void func(int x, int y = 10, int z = 5);        // OK
    void func(int x, int y, int z = 5);             // OK
    void func(int x = 1, int y = 10, int z = 5);    // OK

âŒ SAI:
    void func(int x = 10, int y);              // ERROR!
    void func(int x, int y = 10, int z);       // ERROR!
    void func(int x = 1, int y, int z = 5);    // ERROR!

Táº I SAO?
- Compiler khÃ´ng biáº¿t cÃ¡ch map arguments
- Arguments Ä‘Æ°á»£c gÃ¡n tá»« trÃ¡i sang pháº£i
- Náº¿u cÃ³ "lá»— há»•ng" á»Ÿ giá»¯a â†’ Ambiguity

HÃŒNH DUNG:
    func(int x = 10, int y, int z = 5);
    func(20, 30);  // x=20, y=30, z=5? Hay x=10, y=20, z=30?
    // â†’ Ambiguous! Compiler khÃ´ng biáº¿t!

4.3. AMBIGUITY Vá»šI FUNCTION OVERLOADING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Default parameters + Function overloading = âš ï¸ NGUY HIá»‚M!

VÃ Dá»¤ Tá»ª TEST (Test2/on_1.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <bits/stdc++.h>
using namespace std;

int Func(int, int);
int Func(int, int, int);
// âŒ ERROR khi gá»i Func(2, 4) vÃ¬ khÃ´ng biáº¿t chá»n hÃ m nÃ o

int main(){
    // cout << Func(2, 4);     // âŒ COMPILE ERROR: Ambiguous
    cout << Func(2, 4, 6);     // âœ“ OK: Gá»i Func(int, int, int)
}

int Func(int a, int b){
    return a * b;
}

int Func(int a, int b, int c = 6){
    return a * b * c;
}
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Func(2, 4) cÃ³ 2 lá»±a chá»n:
1. Func(int, int) â†’ 2 * 4 = 8
2. Func(int, int, int = 6) â†’ 2 * 4 * 6 = 48 (dÃ¹ng default cho c)

â†’ Compiler KHÃ”NG BIáº¾T chá»n hÃ m nÃ o
â†’ COMPILE ERROR: Ambiguous call

âœ“ Gá»ŒI RÃ• RÃ€NG:
    Func(2, 4, 6);   // OK: Cháº¯c cháº¯n gá»i Func(int, int, int)
    // Pháº£i truyá»n Ä‘á»§ 3 arguments Ä‘á»ƒ trÃ¡nh ambiguity

4.4. Lá»–I THÆ¯á»œNG Gáº¶P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I 1: Default khÃ´ng á»Ÿ cuá»‘i
    void func(int x = 10, int y);  // ERROR!

âŒ Lá»–I 2: Redeclaration vá»›i default khÃ¡c
    void func(int x = 10);
    void func(int x = 20);  // ERROR! Conflicting defaults

âŒ Lá»–I 3: Ambiguity vá»›i overloading
    int func(int x, int y);
    int func(int x, int y, int z = 5);
    func(1, 2);  // ERROR! Ambiguous

âœ“ BEST PRACTICES:
1. Default parameters á»Ÿ cuá»‘i
2. Cáº©n tháº­n khi káº¿t há»£p vá»›i overloading
3. Document rÃµ default values
4. DÃ¹ng default cho optional parameters tháº­t sá»±

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 5: PASS BY VALUE/REFERENCE/POINTER
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

5.1. PASS BY VALUE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Truyá»n COPY cá»§a biáº¿n vÃ o function. Thay Ä‘á»•i trong function KHÃ”NG áº£nh hÆ°á»Ÿng gá»‘c.

VÃ Dá»¤ Tá»ª TEST (Test1/on_37.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

void Func(int x, int y){
    x = 2;
    y = 1;
}

int main(){
    int x = 1;
    Func(x, x);
    cout << x;  // Output: 1 (x KHÃ”NG Ä‘á»•i!)
    return 0;
}
```

PHÃ‚N TÃCH:
- Func nháº­n COPY cá»§a x (2 láº§n)
- Thay Ä‘á»•i x, y trong Func chá»‰ áº£nh hÆ°á»Ÿng copies
- x gá»‘c trong main KHÃ”NG Ä‘á»•i
- Output: 1

Æ¯U ÄIá»‚M:
âœ“ An toÃ n: KhÃ´ng thay Ä‘á»•i biáº¿n gá»‘c
âœ“ ÄÆ¡n giáº£n: KhÃ´ng cáº§n quan tÃ¢m side effects

NHÆ¯á»¢C ÄIá»‚M:
âŒ Cháº­m vá»›i object lá»›n (copy toÃ n bá»™)
âŒ Tá»‘n memory

5.2. PASS BY REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Truyá»n ALIAS cá»§a biáº¿n. Thay Ä‘á»•i trong function áº£nh hÆ°á»Ÿng biáº¿n gá»‘c.

VÃ Dá»¤:
```cpp
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10, y = 20;
    swap(x, y);
    cout << x << " " << y;  // 20 10 (x, y ÄÃƒ Äá»”I)
}
```

Æ¯U ÄIá»‚M:
âœ“ Nhanh: KhÃ´ng copy
âœ“ CÃ³ thá»ƒ modify biáº¿n gá»‘c
âœ“ Efficient vá»›i object lá»›n

NHÆ¯á»¢C ÄIá»‚M:
âŒ CÃ³ thá»ƒ thay Ä‘á»•i biáº¿n gá»‘c (cáº©n tháº­n!)
âŒ KhÃ´ng dÃ¹ng Ä‘Æ°á»£c vá»›i literal/temporary (dÃ¹ng const ref)

5.3. PASS BY POINTER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Truyá»n Ä‘á»‹a chá»‰ cá»§a biáº¿n. Giá»‘ng reference nhÆ°ng cÃ³ thá»ƒ nullptr.

VÃ Dá»¤:
```cpp
void increment(int* ptr) {
    if (ptr != nullptr) {
        (*ptr)++;
    }
}

int main() {
    int x = 10;
    increment(&x);
    cout << x;  // 11
    
    increment(nullptr);  // OK: KhÃ´ng crash
}
```

Æ¯U ÄIá»‚M:
âœ“ CÃ³ thá»ƒ nullptr (optional parameter)
âœ“ CÃ³ thá»ƒ Ä‘á»•i target
âœ“ RÃµ rÃ ng khi gá»i (pháº£i dÃ¹ng &)

NHÆ¯á»¢C ÄIá»‚M:
âŒ Pháº£i check nullptr
âŒ Syntax phá»©c táº¡p hÆ¡n (*, &, ->)

5.4. Báº¢NG QUYáº¾T Äá»ŠNH KHI NÃ€O DÃ™NG CÃI GÃŒ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TÃŒNH HUá»NG                 â”‚ DÃ™NG              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Small types (int, char)    â”‚ Pass by VALUE     â”‚
â”‚ Chá»‰ Ä‘á»c, khÃ´ng Ä‘á»•i         â”‚ const REFERENCE   â”‚
â”‚ Cáº§n modify biáº¿n gá»‘c        â”‚ REFERENCE         â”‚
â”‚ Optional parameter         â”‚ POINTER           â”‚
â”‚ CÃ³ thá»ƒ null               â”‚ POINTER           â”‚
â”‚ Array/Dynamic memory       â”‚ POINTER           â”‚
â”‚ Large object, chá»‰ Ä‘á»c      â”‚ const REFERENCE   â”‚
â”‚ Large object, cáº§n Ä‘á»•i      â”‚ REFERENCE         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VÃ Dá»¤:
```cpp
// Small type â†’ Value
int add(int a, int b) {
    return a + b;
}

// Large object, chá»‰ Ä‘á»c â†’ const reference
void print(const string& str) {
    cout << str;
}

// Cáº§n modify â†’ Reference
void uppercase(string& str) {
    // ...
}

// Optional â†’ Pointer
void process(int* optional = nullptr) {
    if (optional) {
        // ...
    }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 6: TYPE CONVERSION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

6.1. IMPLICIT CONVERSION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Compiler tá»± Ä‘á»™ng chuyá»ƒn Ä‘á»•i type khi cáº§n thiáº¿t.

VÃ Dá»¤:
```cpp
int x = 5;
double y = x;  // int â†’ double (implicit)
cout << y;     // 5.0

float f = 3.14f;
int i = f;     // float â†’ int (implicit, máº¥t pháº§n tháº­p phÃ¢n)
cout << i;     // 3
```

VÃ Dá»¤ Tá»ª TEST (Test1/on_32.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

int main(){
    int x = 5;
    float y;
    cout << sizeof(x + y) << endl;  // 4
    // x + y â†’ float (int promoted to float)
    // sizeof(float) = 4
}
```

6.2. TYPE PROMOTION HIERARCHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

QUY Táº®C PROMOTION (Tá»« nhá» â†’ lá»›n):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    char/short â†’ int â†’ long â†’ long long â†’ float â†’ double â†’ long double

VÃ Dá»¤:
```cpp
char c = 'A';
short s = 100;
int i = 1000;
float f = 3.14f;
double d = 2.718;

// char + int â†’ int
cout << sizeof(c + i);  // 4 (int)

// int + float â†’ float
cout << sizeof(i + f);  // 4 (float)

// float + double â†’ double
cout << sizeof(f + d);  // 8 (double)

// short + short â†’ int
cout << sizeof(s + s);  // 4 (int, khÃ´ng pháº£i short!)
```

LÆ¯U Ã QUAN TRá»ŒNG:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš ï¸ char, short LUÃ”N Ä‘Æ°á»£c promote lÃªn int trong expressions
âš ï¸ float + double = double
âš ï¸ int / int = int (khÃ´ng pháº£i double!)

VÃ Dá»¤ BáºªY:
```cpp
int a = 5, b = 2;
cout << a / b;        // 2 (int division)
cout << (double)a / b; // 2.5 (a cast to double)
cout << a / 2.0;      // 2.5 (2.0 lÃ  double)
```

6.3. EXPLICIT CAST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Programmer chá»§ Ä‘á»™ng chuyá»ƒn Ä‘á»•i type.

4 LOáº I CAST TRONG C++:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. C-STYLE CAST (KhÃ´ng khuyÃªn dÃ¹ng):
    int x = 10;
    double y = (double)x;

2. STATIC_CAST (Compile-time, khuyÃªn dÃ¹ng):
    int x = 10;
    double y = static_cast<double>(x);

3. DYNAMIC_CAST (Runtime, dÃ¹ng vá»›i polymorphism):
    Base* b = new Derived();
    Derived* d = dynamic_cast<Derived*>(b);

4. CONST_CAST (Remove const):
    const int x = 10;
    int* p = const_cast<int*>(&x);

5. REINTERPRET_CAST (Low-level, nguy hiá»ƒm):
    int x = 10;
    char* p = reinterpret_cast<char*>(&x);

VÃ Dá»¤ THá»°C Táº¾:
```cpp
// Division vá»›i floating point
int a = 5, b = 2;
double result = static_cast<double>(a) / b;  // 2.5

// Array index
int arr[10];
double index = 3.7;
arr[static_cast<int>(index)] = 100;  // arr[3] = 100
```

BEST PRACTICE:
âœ“ DÃ¹ng static_cast trong C++ (khÃ´ng dÃ¹ng C-style)
âœ“ TrÃ¡nh reinterpret_cast trá»« khi tháº­t sá»± cáº§n
âœ“ Cáº©n tháº­n vá»›i const_cast (cÃ³ thá»ƒ undefined behavior)
âœ“ dynamic_cast dÃ¹ng vá»›i polymorphism

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Tá»”NG Káº¾T PHáº¦N I: C++ FUNDAMENTALS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHECKLIST QUAN TRá»ŒNG:
â–¡ Reference lÃ  alias, khÃ´ng thá»ƒ null, khÃ´ng thá»ƒ re-bind
â–¡ Pointer cÃ³ thá»ƒ null, cÃ³ thá»ƒ Ä‘á»•i target
â–¡ sizeof KHÃ”NG cÃ³ side effects (quan trá»ng nháº¥t!)
â–¡ sizeof(array) trong function = sizeof(pointer) (array decay)
â–¡ Default parameters pháº£i á»Ÿ cuá»‘i
â–¡ Cáº©n tháº­n ambiguity vá»›i overloading + default
â–¡ Pass by value: Safe nhÆ°ng cháº­m vá»›i object lá»›n
â–¡ Pass by const reference: Nhanh, safe, dÃ¹ng cho large objects
â–¡ Pass by reference: Khi cáº§n modify
â–¡ Pass by pointer: Khi cáº§n nullptr hoáº·c optional
â–¡ Type promotion: char/short â†’ int, smaller â†’ larger type
â–¡ DÃ¹ng static_cast thay vÃ¬ C-style cast

ÄÃƒ Há»ŒC Tá»ª CODE TEST:
âœ“ Test1/on_1.cpp: Reference behavior vá»›i var_x++, ref_x++
âœ“ Test1/on_44.cpp: sizeof(x++) khÃ´ng cÃ³ side effects (quan trá»ng!)
âœ“ Test1/on_32.cpp: sizeof(x + y) vá»›i type promotion
âœ“ Test1/on_33.cpp: Default parameters cÆ¡ báº£n
âœ“ Test1/on_36.cpp: Multiple default parameters
âœ“ Test1/on_37.cpp: Pass by value khÃ´ng Ä‘á»•i biáº¿n gá»‘c
âœ“ Test2/on_1.cpp: Ambiguity vá»›i overloading + default

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIáº¾P Tá»¤C Vá»šI PHáº¦N II: OPERATOR OVERLOADING
Xem file Part2_Operator_Overloading.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
