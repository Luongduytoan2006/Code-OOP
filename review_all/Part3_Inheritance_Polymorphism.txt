================================================================================
          PHáº¦N III: INHERITANCE & POLYMORPHISM (Giá»¯a KÃ¬ + Test 3)
================================================================================

TÃ i liá»‡u Ã´n táº­p chi tiáº¿t vá» Káº¿ thá»«a vÃ  Äa hÃ¬nh trong C++
Format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ VÃ­ dá»¥ code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p

================================================================================

Má»¤C Lá»¤C
â•â•â•â•â•â•â•

18. Káº¾ THá»ªA ÄÆ N (SINGLE INHERITANCE)
    18.1. KhÃ¡i niá»‡m IS-A relationship
    18.2. Public/Protected/Private inheritance
    18.3. VÃ­ dá»¥ code chi tiáº¿t (Gki/test.cpp)
    
19. CONSTRUCTOR & DESTRUCTOR ORDER â­ THEN CHá»T
    19.1. Quy táº¯c vÃ ng: Cha â†’ Con, ~Con â†’ ~Cha
    19.2. VÃ­ dá»¥ code (Gki/test.cpp, test2.cpp)
    19.3. PhÃ¢n tÃ­ch chi tiáº¿t tá»«ng bÆ°á»›c
    19.4. Multiple inheritance order
    
20. INITIALIZER LIST
    20.1. KhÃ¡i niá»‡m & Syntax
    20.2. Gá»i base constructor
    20.3. Lá»—i: KhÃ´ng gá»i base constructor
    20.4. Thá»© tá»± khá»Ÿi táº¡o
    
21. VIRTUAL DESTRUCTOR â­ Cá»°C Ká»² QUAN TRá»ŒNG
    21.1. Táº¡i sao cáº§n virtual destructor
    21.2. Memory leak khi khÃ´ng cÃ³ virtual
    21.3. VÃ­ dá»¥ code (Gki/test.cpp)
    21.4. Quy táº¯c: Base class â†’ virtual destructor
    
22. VIRTUAL FUNCTIONS
    22.1. KhÃ¡i niá»‡m dynamic binding
    22.2. Override keyword
    22.3. Virtual function table (vtable)
    
23. POLYMORPHISM
    23.1. Compile-time polymorphism (static)
    23.2. Runtime polymorphism (dynamic)
    23.3. Upcasting (an toÃ n)
    23.4. Downcasting (dynamic_cast)
    
24. SLICING PROBLEM â­ Lá»–I THÆ¯á»œNG Gáº¶P
    24.1. KhÃ¡i niá»‡m slicing
    24.2. VÃ­ dá»¥ code minh há»a
    24.3. Giáº£i phÃ¡p: Pass by reference/pointer
    
25. ÄA Káº¾ THá»ªA (MULTIPLE INHERITANCE)
    25.1. KhÃ¡i niá»‡m & Syntax
    25.2. Constructor/Destructor order
    25.3. Diamond problem
    25.4. Virtual inheritance
    
26. OPERATOR OVERLOADING Vá»šI INHERITANCE
    26.1. Káº¿ thá»«a operators
    26.2. Override operators cho derived class
    26.3. Gá»i base class operator
    26.4. Stream operators vá»›i inheritance

================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 18: Káº¾ THá»ªA ÄÆ N (SINGLE INHERITANCE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

18.1. KHÃI NIá»†M IS-A RELATIONSHIP
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Inheritance (káº¿ thá»«a) cho phÃ©p class con (derived) káº¿ thá»«a properties vÃ  methods 
tá»« class cha (base).

IS-A RELATIONSHIP:
- Derived class "IS-A" Base class
- Dog IS-A Animal
- Circle IS-A Shape
- Student IS-A Person

CÃš PHÃP:
```cpp
class Base {
    // Base class members
};

class Derived : public Base {
    // Derived class members
    // + káº¿ thá»«a Base members
};
```

18.2. PUBLIC/PROTECTED/PRIVATE INHERITANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

3 LOáº I INHERITANCE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Base Member    â”‚ public      â”‚ protected    â”‚ private      â”‚
â”‚ Access         â”‚ inheritance â”‚ inheritance  â”‚ inheritance  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ public         â”‚ public      â”‚ protected    â”‚ private      â”‚
â”‚ protected      â”‚ protected   â”‚ protected    â”‚ private      â”‚
â”‚ private        â”‚ khÃ´ng accessâ”‚ khÃ´ng access â”‚ khÃ´ng access â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PUBLIC INHERITANCE (khuyÃªn dÃ¹ng):
- Giá»¯ nguyÃªn access specifier
- IS-A relationship
- 99% trÆ°á»ng há»£p dÃ¹ng public

PROTECTED INHERITANCE:
- public/protected â†’ protected
- Hiáº¿m khi dÃ¹ng

PRIVATE INHERITANCE:
- Táº¥t cáº£ â†’ private
- HAS-A relationship (composition)
- Hiáº¿m khi dÃ¹ng

18.3. VÃ Dá»¤ CODE Tá»ª TEST (Gki/test.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
#include <iostream>
using namespace std;

static int GID = 0;

//===== ExamA (Lá»›p cÆ¡ sá»Ÿ) =====
class ExamA {
    int secret_ = -777;  // private
public:
    int ax = -1;

    ExamA() : ax(0) {
        cout << "ExamA()  id=" << ++GID << "  ax=" << ax << "\n";
    }

    ExamA(int x) : ax(x) {
        cout << "ExamA(int)  ax=" << ax << "\n";
    }

    ExamA(const ExamA& other) : ax(other.ax) {
        cout << "ExamA(copy)  ax=" << ax << "\n";
    }

    ExamA& operator=(const ExamA& rhs) {
        cout << "ExamA::operator= from ax=" << rhs.ax << "\n";
        if (this != &rhs) ax = rhs.ax;
        return *this;
    }

    virtual ~ExamA() {
        cout << "~ExamA()  ax=" << ax << "\n";
    }

    friend ostream& operator<<(ostream& os, const ExamA& a) {
        return os << "[A ax=" << a.ax << "]";
    }
};

//===== ExamB (Lá»›p dáº«n xuáº¥t) =====
class ExamB : public ExamA {  // â­ public inheritance
public:
    int bx = -2;

    ExamB() : ExamA(), bx(100) {
        cout << "ExamB()       bx=" << bx << "\n";
    }

    explicit ExamB(int a, int b) : ExamA(a), bx(b) {
        cout << "ExamB(int,int) ax=" << a << "  bx=" << bx << "\n";
    }
    
    // ... copy, destructor, operators ...
};
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ExamB : public ExamA
   - ExamB káº¿ thá»«a táº¥t cáº£ public/protected members cá»§a ExamA
   - ax (public) â†’ váº«n public trong ExamB
   - secret_ (private) â†’ KHÃ”NG access Ä‘Æ°á»£c trong ExamB

2. ExamB cÃ³ thá»ƒ:
   - Access ax (inherited public member)
   - Gá»i ExamA constructor trong initializer list
   - Override virtual functions cá»§a ExamA

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 19: CONSTRUCTOR & DESTRUCTOR ORDER â­ THEN CHá»T
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

19.1. QUY Táº®C VÃ€NG
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­â­â­ GHI NHá»š:
CONSTRUCTION: Base â†’ Derived (Cha â†’ Con)
DESTRUCTION:  Derived â†’ Base (~Con â†’ ~Cha)

HÃŒNH DUNG:
    class Base {};
    class Derived : public Base {};
    
    Derived obj;
    // 1. Base constructor
    // 2. Derived constructor
    
    // ... use obj ...
    
    // 3. Derived destructor
    // 4. Base destructor

Táº I SAO?
- Derived cáº§n Base Ä‘Ã£ Ä‘Æ°á»£c khá»Ÿi táº¡o
- Derived phá»¥ thuá»™c vÃ o Base
- Há»§y ngÆ°á»£c láº¡i: Con trÆ°á»›c, Cha sau

19.2. VÃ Dá»¤ CODE Tá»ª TEST (Gki/test.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
int main() {
    cout << "\n=== Test 1: Táº¡o ExamB() ===\n";
    {
        ExamB b1;
    }
    cout << "Káº¿t thÃºc scope\n";
}
```

OUTPUT:
```
=== Test 1: Táº¡o ExamB() ===
ExamA()  id=1  ax=0        â† 1. Base constructor
ExamB()       bx=100       â† 2. Derived constructor
~ExamB() bx=100            â† 3. Derived destructor
~ExamA()  ax=0             â† 4. Base destructor
Káº¿t thÃºc scope
```

PHÃ‚N TÃCH Tá»ªNG BÆ¯á»šC:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. CONSTRUCTION:
   a. Gá»i ExamA() - Base constructor
      - ax = 0
      - In "ExamA() id=1 ax=0"
   
   b. Gá»i ExamB() - Derived constructor
      - bx = 100
      - In "ExamB() bx=100"

2. DESTRUCTION (khi ra khá»i scope):
   a. Gá»i ~ExamB() - Derived destructor
      - In "~ExamB() bx=100"
   
   b. Gá»i ~ExamA() - Base destructor
      - In "~ExamA() ax=0"

19.3. VÃ Dá»¤ Vá»šI THAM Sá» (Gki/test.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
int main() {
    cout << "\n=== Test 2: ExamB(10, 20) ===\n";
    {
        ExamB b2(10, 20);
    }
}
```

OUTPUT:
```
=== Test 2: ExamB(10, 20) ===
ExamA(int)  ax=10          â† 1. Base constructor vá»›i tham sá»‘
ExamB(int,int) ax=10 bx=20 â† 2. Derived constructor
~ExamB() bx=20             â† 3. Derived destructor
~ExamA()  ax=10            â† 4. Base destructor
```

CODE CONSTRUCTOR:
```cpp
explicit ExamB(int a, int b) : ExamA(a), bx(b) {
    //                         ^^^^^^^^  ^^^^^^
    //                         Gá»i Base  Init member
    cout << "ExamB(int,int) ax=" << a << "  bx=" << bx << "\n";
}
```

THá»¨ Tá»° KHá»I Táº O:
1. ExamA(a) - Gá»i base constructor trÆ°á»›c
2. bx(b) - Init member cá»§a derived
3. Body cá»§a ExamB constructor

19.4. VÃ Dá»¤ Vá»šI COPY CONSTRUCTOR (Gki/test2.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
class ExamA {
public:
    int ax;
    ExamA() : ax(0) { cout << "A() ax=" << ax << "\n"; }
    ExamA(int x) : ax(x) { cout << "A(int) ax=" << ax << "\n"; }
    ExamA(const ExamA& o) : ax(o.ax) { cout << "A(copy) ax=" << ax << "\n"; }
    virtual ~ExamA() { cout << "~A() ax=" << ax << "\n"; }
};

class ExamB : public ExamA {
public:
    int bx;
    ExamB() : ExamA(), bx(10) { cout << "B() bx=" << bx << "\n"; }
    ExamB(int a, int b) : ExamA(a), bx(b) { cout << "B(int,int) bx=" << bx << "\n"; }
    
    ExamB(const ExamB& o) : ExamA(o), bx(o.bx) {
        //                  ^^^^^^^^^  ^^^^^^^^^
        //                  Copy Base  Copy member
        cout << "B(copy) bx=" << bx << "\n";
    }
    
    ~ExamB() override { cout << "~B() bx=" << bx << "\n"; }
};

int main() {
    ExamB b1(5, 10);
    cout << "--- Copy b1 ---\n";
    ExamB b2 = b1;  // Copy constructor
}
```

OUTPUT:
```
A(int) ax=5            â† 1. Base constructor
B(int,int) bx=10       â† 2. Derived constructor
--- Copy b1 ---
A(copy) ax=5           â† 3. Base COPY constructor
B(copy) bx=10          â† 4. Derived COPY constructor
~B() bx=10             â† 5. ~Derived (b2)
~A() ax=5              â† 6. ~Base (b2)
~B() bx=10             â† 7. ~Derived (b1)
~A() ax=5              â† 8. ~Base (b1)
```

â­ LÆ¯U Ã COPY CONSTRUCTOR:
```cpp
ExamB(const ExamB& o) : ExamA(o), bx(o.bx) {
    //                  ^^^^^^^^^
    //                  PHáº¢I gá»i base copy constructor!
}
```

Náº¿u quÃªn gá»i ExamA(o):
```cpp
ExamB(const ExamB& o) : bx(o.bx) {  // âŒ QuÃªn gá»i base copy!
    // Sáº½ gá»i ExamA() default constructor thay vÃ¬ copy
    // â†’ ax = 0 thay vÃ¬ ax = o.ax
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 20: INITIALIZER LIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

20.1. KHÃI NIá»†M & SYNTAX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Initializer list khá»Ÿi táº¡o members TRÆ¯á»šC khi vÃ o body cá»§a constructor.

CÃš PHÃP:
```cpp
class MyClass {
    int x, y;
public:
    // Initializer list
    MyClass(int a, int b) : x(a), y(b) {
        //                  ^^^^^^^^^^^
        //                  Initializer list
        // Body cá»§a constructor
    }
};
```

20.2. Gá»ŒI BASE CONSTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Vá»šI Káº¾ THá»ªA:
```cpp
class Base {
    int value;
public:
    Base(int v) : value(v) {}
};

class Derived : public Base {
    int extra;
public:
    // âœ“ ÄÃšNG: Gá»i base constructor
    Derived(int v, int e) : Base(v), extra(e) {}
    //                      ^^^^^^^
    //                      Gá»i base constructor
};
```

20.3. Lá»–I: KHÃ”NG Gá»ŒI BASE CONSTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Lá»–I THÆ¯á»œNG Gáº¶P:
```cpp
class Base {
    int value;
public:
    Base(int v) : value(v) {}
    // KHÃ”NG cÃ³ default constructor!
};

class Derived : public Base {
    int extra;
public:
    // âŒ ERROR: Base khÃ´ng cÃ³ default constructor
    Derived(int e) : extra(e) {}
    // Compiler tá»± gá»i Base(), nhÆ°ng khÃ´ng tá»“n táº¡i!
};
```

âœ“ GIáº¢I PHÃP:
```cpp
// CÃ¡ch 1: Gá»i rÃµ rÃ ng base constructor
Derived(int v, int e) : Base(v), extra(e) {}

// CÃ¡ch 2: ThÃªm default constructor cho Base
class Base {
public:
    Base() : value(0) {}  // Default constructor
    Base(int v) : value(v) {}
};
```

20.4. THá»¨ Tá»° KHá»I Táº O
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C QUAN TRá»ŒNG:
Thá»© tá»± khá»Ÿi táº¡o KHÃ”NG phá»¥ thuá»™c thá»© tá»± trong initializer list,
mÃ  phá»¥ thuá»™c thá»© tá»± KHAI BÃO trong class!

VÃ Dá»¤:
```cpp
class MyClass {
    int x, y, z;  // Khai bÃ¡o theo thá»© tá»± x, y, z
public:
    // Khá»Ÿi táº¡o theo thá»© tá»± z, y, x (trong initializer list)
    MyClass(int a, int b, int c) : z(c), y(b), x(a) {}
    //                             ^^^^^^^^^^^^^^^^^^^^
    
    // NhÆ°ng thá»© tá»± THáº¬T Sá»° khá»Ÿi táº¡o: x, y, z (theo khai bÃ¡o!)
};
```

VÃ Dá»¤ Lá»–I:
```cpp
class Bad {
    int x, y;  // x khai bÃ¡o trÆ°á»›c y
public:
    Bad(int val) : y(val), x(y) {}
    //             ^^^^^^^^^^^^
    //             y = val, x = y
    
    // NhÆ°ng x khá»Ÿi táº¡o TRÆ¯á»šC y (theo khai bÃ¡o)!
    // â†’ x = ??? (y chÆ°a khá»Ÿi táº¡o)
    // â†’ Undefined behavior!
};

âœ“ ÄÃšNG:
class Good {
    int x, y;
public:
    Good(int val) : x(val), y(x) {}
    //              ^^^^^^^^^^^^
    //              x khá»Ÿi táº¡o trÆ°á»›c, y dÃ¹ng x
};
```

Vá»šI Káº¾ THá»ªA:
```cpp
class Base {
    int b;
public:
    Base(int val) : b(val) {}
};

class Derived : public Base {
    int d1, d2;
public:
    Derived(int a, int b, int c) : d2(c), Base(a), d1(b) {}
    //                             ^^^^^^^^^^^^^^^^^^^^^
    
    // Thá»© tá»± THáº¬T Sá»°:
    // 1. Base(a) - Base constructor LUÃ”N TRÆ¯á»šC
    // 2. d1(b) - Member theo thá»© tá»± khai bÃ¡o
    // 3. d2(c)
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 21: VIRTUAL DESTRUCTOR â­ Cá»°C Ká»² QUAN TRá»ŒNG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

21.1. Táº I SAO Cáº¦N VIRTUAL DESTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­â­â­ QUY Táº®C VÃ€NG:
Náº¿u class cÃ³ thá»ƒ lÃ  BASE CLASS, destructor PHáº¢I lÃ  VIRTUAL!

Táº I SAO?
- Khi delete qua base pointer, cáº§n gá»i derived destructor
- Náº¿u destructor KHÃ”NG virtual â†’ Chá»‰ gá»i base destructor
- Derived members khÃ´ng Ä‘Æ°á»£c há»§y â†’ MEMORY LEAK!

21.2. MEMORY LEAK KHI KHÃ”NG CÃ“ VIRTUAL (Gki/test.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST:
```cpp
class ExamA {
public:
    int ax;
    
    // â­ virtual destructor
    virtual ~ExamA() {
        cout << "~ExamA() ax=" << ax << "\n";
    }
};

class ExamB : public ExamA {
public:
    int bx;
    int* data;  // Dynamic memory
    
    ExamB() : ExamA(), bx(100) {
        data = new int[1000];  // Allocate memory
    }
    
    ~ExamB() {
        cout << "~ExamB() bx=" << bx << "\n";
        delete[] data;  // â­ Giáº£i phÃ³ng memory
    }
};

int main() {
    ExamA* ptr = new ExamB();  // Base pointer to derived object
    delete ptr;  // Gá»i destructor nÃ o?
}
```

Vá»šI VIRTUAL DESTRUCTOR (âœ“ ÄÃšNG):
```
~ExamB() bx=100      â† 1. Derived destructor (giáº£i phÃ³ng data)
~ExamA() ax=0        â† 2. Base destructor
```

KHÃ”NG VIRTUAL (âŒ SAI):
```cpp
class ExamA {
public:
    ~ExamA() {}  // âŒ KHÃ”NG virtual!
};

// delete ptr chá»‰ gá»i:
~ExamA() ax=0        â† CHá»ˆ base destructor!
// ~ExamB() KHÃ”NG Ä‘Æ°á»£c gá»i!
// data KHÃ”NG Ä‘Æ°á»£c delete[] â†’ MEMORY LEAK!
```

HÃŒNH DUNG:
```
Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ExamB object        â”‚
â”‚  - ax (inherited)   â”‚
â”‚  - bx               â”‚
â”‚  - data* â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”˜
                    â†“
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ int[1000]      â”‚ â† LEAKED! KhÃ´ng Ä‘Æ°á»£c delete
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

21.3. QUY Táº®C: BASE CLASS â†’ VIRTUAL DESTRUCTOR
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ CHECKLIST:
â–¡ Class cÃ³ virtual functions â†’ destructor PHáº¢I virtual
â–¡ Class Ä‘Æ°á»£c káº¿ thá»«a â†’ destructor PHáº¢I virtual
â–¡ Polymorphism â†’ destructor PHáº¢I virtual
â–¡ Chá»‰ cÃ³ final class hoáº·c khÃ´ng káº¿ thá»«a â†’ destructor cÃ³ thá»ƒ non-virtual

VÃ Dá»¤:
```cpp
// âœ“ ÄÃšNG: Base class vá»›i virtual destructor
class Base {
public:
    virtual ~Base() {}
    virtual void func() {}
};

// âŒ SAI: Base class KHÃ”NG virtual destructor
class Bad {
public:
    ~Bad() {}  // âŒ NÃªn lÃ  virtual!
    virtual void func() {}
};

// âœ“ OK: Final class (khÃ´ng káº¿ thá»«a)
class Final {
public:
    ~Final() {}  // OK: KhÃ´ng ai káº¿ thá»«a
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 22: VIRTUAL FUNCTIONS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

22.1. KHÃI NIá»†M DYNAMIC BINDING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Virtual function cho phÃ©p gá»i derived class method qua base class pointer.

STATIC BINDING (compile-time):
```cpp
class Base {
public:
    void func() { cout << "Base"; }
};

class Derived : public Base {
public:
    void func() { cout << "Derived"; }  // Hide Base::func
};

Base* ptr = new Derived();
ptr->func();  // "Base" - Gá»i Base::func (compile-time)
```

DYNAMIC BINDING (runtime):
```cpp
class Base {
public:
    virtual void func() { cout << "Base"; }  // â­ virtual
};

class Derived : public Base {
public:
    void func() override { cout << "Derived"; }
};

Base* ptr = new Derived();
ptr->func();  // "Derived" - Gá»i Derived::func (runtime)
```

22.2. OVERRIDE KEYWORD
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ C++11: DÃ¹ng override Ä‘á»ƒ rÃµ rÃ ng
```cpp
class Base {
public:
    virtual void func() {}
    virtual void func(int) {}
};

class Derived : public Base {
public:
    // âœ“ ÄÃšNG: override rÃµ rÃ ng
    void func() override {}
    
    // âŒ ERROR: Signature khÃ´ng khá»›p
    void func(double) override {}  // Compile error!
    
    // âŒ NGUY HIá»‚M: KhÃ´ng override, táº¡o function má»›i
    void func(double) {}  // KhÃ´ng lá»—i, nhÆ°ng KHÃ”NG override!
};
```

Æ¯U ÄIá»‚M Cá»¦A override:
âœ“ Compiler check signature
âœ“ RÃµ rÃ ng intent
âœ“ TrÃ¡nh lá»—i typo

22.3. VIRTUAL FUNCTION TABLE (vtable)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CÃCH HOáº T Äá»˜NG:
- Má»—i class cÃ³ virtual functions cÃ³ vtable
- vtable lÆ°u pointers Ä‘áº¿n virtual functions
- Má»—i object cÃ³ vptr (virtual pointer) trá» Ä‘áº¿n vtable

HÃŒNH DUNG:
```
Base* ptr = new Derived();

Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Derived object     â”‚
â”‚  - vptr â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  - data          â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”˜
                   â†“
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Derived vtable  â”‚
        â”‚  - func â†’ Derived::func
        â”‚  - ~Derived â†’ ~Derived()
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ptr->func():
1. Dereference vptr
2. Tra cá»©u vtable
3. Gá»i Derived::func
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 23: POLYMORPHISM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

23.1. COMPILE-TIME POLYMORPHISM (STATIC)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

2 LOáº I:
1. Function overloading
2. Template

VÃ Dá»¤ FUNCTION OVERLOADING:
```cpp
void print(int x) { cout << "int: " << x; }
void print(double x) { cout << "double: " << x; }
void print(string x) { cout << "string: " << x; }

print(10);      // Gá»i print(int) - compile-time
print(10.5);    // Gá»i print(double) - compile-time
```

VÃ Dá»¤ TEMPLATE:
```cpp
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

max(10, 20);     // Instantiate max<int> - compile-time
max(10.5, 20.5); // Instantiate max<double> - compile-time
```

23.2. RUNTIME POLYMORPHISM (DYNAMIC)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Vá»šI VIRTUAL FUNCTIONS:
```cpp
class Shape {
public:
    virtual double area() const = 0;  // Pure virtual
    virtual void draw() const = 0;
    virtual ~Shape() {}
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}
    
    double area() const override {
        return 3.14 * radius * radius;
    }
    
    void draw() const override {
        cout << "Drawing Circle\n";
    }
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    double area() const override {
        return width * height;
    }
    
    void draw() const override {
        cout << "Drawing Rectangle\n";
    }
};

int main() {
    Shape* shapes[2];
    shapes[0] = new Circle(5);
    shapes[1] = new Rectangle(4, 6);
    
    for (int i = 0; i < 2; i++) {
        shapes[i]->draw();         // Runtime polymorphism!
        cout << shapes[i]->area() << endl;
        delete shapes[i];
    }
}
```

OUTPUT:
```
Drawing Circle
78.5
Drawing Rectangle
24
```

23.3. UPCASTING (AN TOÃ€N)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Chuyá»ƒn derived pointer/reference sang base pointer/reference.

VÃ Dá»¤:
```cpp
Derived d;
Base* ptr = &d;     // âœ“ Upcasting - An toÃ n, tá»± Ä‘á»™ng
Base& ref = d;      // âœ“ Upcasting - An toÃ n, tá»± Ä‘á»™ng
```

LUÃ”N AN TOÃ€N:
- Derived IS-A Base
- Compiler tá»± Ä‘á»™ng convert
- KhÃ´ng cáº§n cast

23.4. DOWNCASTING (DYNAMIC_CAST)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Chuyá»ƒn base pointer/reference sang derived pointer/reference.

âš ï¸ NGUY HIá»‚M: KhÃ´ng pháº£i lÃºc nÃ o cÅ©ng an toÃ n!

VÃ Dá»¤:
```cpp
Base* ptr = new Derived();

// âœ“ ÄÃšNG: DÃ¹ng dynamic_cast
Derived* dptr = dynamic_cast<Derived*>(ptr);
if (dptr != nullptr) {
    // An toÃ n: ptr tháº­t sá»± trá» Ä‘áº¿n Derived
    dptr->derivedMethod();
}

// âŒ NGUY HIá»‚M: C-style cast
Derived* bad = (Derived*)ptr;  // KhÃ´ng check!
```

dynamic_cast:
- Return nullptr náº¿u cast fail (pointer)
- Throw bad_cast náº¿u cast fail (reference)
- Chá»‰ hoáº¡t Ä‘á»™ng vá»›i polymorphic types (cÃ³ virtual functions)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 24: SLICING PROBLEM â­ Lá»–I THÆ¯á»œNG Gáº¶P
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

24.1. KHÃI NIá»†M SLICING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Slicing xáº£y ra khi pass derived object BY VALUE sang base parameter.
Derived-specific members bá»‹ "cáº¯t bá»" (sliced off).

âŒ VÃ Dá»¤ Lá»–I:
```cpp
class Base {
public:
    int b;
    Base(int x = 0) : b(x) {}
    virtual void print() { cout << "Base: " << b; }
};

class Derived : public Base {
public:
    int d;
    Derived(int x = 0, int y = 0) : Base(x), d(y) {}
    void print() override { cout << "Derived: " << b << ", " << d; }
};

void func(Base obj) {  // âŒ Pass by VALUE!
    obj.print();
}

int main() {
    Derived d(10, 20);
    func(d);  // Slicing happens here!
}
```

OUTPUT:
```
Base: 10  â† âŒ Gá»i Base::print, khÃ´ng pháº£i Derived::print!
```

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. func(d): Pass Derived by value
2. Chá»‰ copy Base part cá»§a d
3. Derived part (d = 20) bá»‹ "sliced off"
4. obj lÃ  Base object, khÃ´ng pháº£i Derived
5. obj.print() gá»i Base::print (no polymorphism!)

HÃŒNH DUNG:
```
Original:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Derived d      â”‚
â”‚  Base part:    â”‚
â”‚    b = 10      â”‚
â”‚  Derived part: â”‚
â”‚    d = 20      â”‚ â† Bá»‹ cáº¯t bá»!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After pass by value:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Base obj       â”‚
â”‚    b = 10      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

24.2. GIáº¢I PHÃP: PASS BY REFERENCE/POINTER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ GIáº¢I PHÃP 1: Pass by reference
```cpp
void func(Base& obj) {  // âœ“ Pass by REFERENCE
    obj.print();
}

int main() {
    Derived d(10, 20);
    func(d);  // No slicing!
}

OUTPUT:
Derived: 10, 20  â† âœ“ Polymorphism works!
```

âœ“ GIáº¢I PHÃP 2: Pass by pointer
```cpp
void func(Base* obj) {  // âœ“ Pass by POINTER
    obj->print();
}

int main() {
    Derived d(10, 20);
    func(&d);  // No slicing!
}

OUTPUT:
Derived: 10, 20  â† âœ“ Polymorphism works!
```

â­ QUY Táº®C:
- Pass by value â†’ Slicing, no polymorphism
- Pass by reference/pointer â†’ No slicing, polymorphism works

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 25: ÄA Káº¾ THá»ªA (MULTIPLE INHERITANCE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

25.1. KHÃI NIá»†M & SYNTAX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Class káº¿ thá»«a tá»« NHIá»€U base classes.

CÃš PHÃP:
```cpp
class Base1 {
public:
    int b1;
    Base1(int x = 0) : b1(x) {}
};

class Base2 {
public:
    int b2;
    Base2(int y = 0) : b2(y) {}
};

class Derived : public Base1, public Base2 {
    //              ^^^^^^^^^^^^^^^^^^^^^^
    //              Káº¿ thá»«a tá»« 2 classes
public:
    int d;
    Derived(int x, int y, int z) : Base1(x), Base2(y), d(z) {}
};
```

25.2. CONSTRUCTOR/DESTRUCTOR ORDER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

QUY Táº®C:
- Construction: Base classes theo thá»© tá»± khai bÃ¡o, rá»“i Derived
- Destruction: NgÆ°á»£c láº¡i

VÃ Dá»¤:
```cpp
class A {
public:
    A() { cout << "A() "; }
    ~A() { cout << "~A() "; }
};

class B {
public:
    B() { cout << "B() "; }
    ~B() { cout << "~B() "; }
};

class C : public A, public B {
    //        ^^^^^^^^^^^^
    //        Thá»© tá»±: A trÆ°á»›c, B sau
public:
    C() { cout << "C() "; }
    ~C() { cout << "~C() "; }
};

int main() {
    C obj;
}

OUTPUT:
A() B() C() ~C() ~B() ~A()
```

25.3. DIAMOND PROBLEM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Khi Derived káº¿ thá»«a tá»« 2 classes, cáº£ 2 Ä‘á»u káº¿ thá»«a tá»« cÃ¹ng 1 Base.

VÃ Dá»¤:
```
      Base
      /  \
     A    B
      \  /
    Derived
```

CODE:
```cpp
class Base {
public:
    int value;
    Base(int v = 0) : value(v) {}
};

class A : public Base {
public:
    A(int v = 0) : Base(v) {}
};

class B : public Base {
public:
    B(int v = 0) : Base(v) {}
};

class Derived : public A, public B {
public:
    Derived(int a, int b) : A(a), B(b) {}
};

int main() {
    Derived d(10, 20);
    
    // âŒ AMBIGUOUS: value tá»« A hay B?
    // cout << d.value;  // ERROR!
    
    // âœ“ PHáº¢I chá»‰ rÃµ:
    cout << d.A::value;  // 10
    cout << d.B::value;  // 20
}
```

PROBLEM:
- Derived cÃ³ 2 copies cá»§a Base (qua A vÃ  qua B)
- Ambiguity khi access Base members

25.4. VIRTUAL INHERITANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

GIáº¢I PHÃP:
DÃ¹ng virtual inheritance Ä‘á»ƒ chá»‰ cÃ³ 1 copy cá»§a Base.

```cpp
class Base {
public:
    int value;
    Base(int v = 0) : value(v) { cout << "Base(" << v << ")\n"; }
};

class A : virtual public Base {  // â­ virtual
    //    ^^^^^^^
public:
    A(int v = 0) : Base(v) {}
};

class B : virtual public Base {  // â­ virtual
    //    ^^^^^^^
public:
    B(int v = 0) : Base(v) {}
};

class Derived : public A, public B {
public:
    Derived(int v) : Base(v), A(v), B(v) {}
    //               ^^^^^^^
    //               Derived PHáº¢I gá»i Base constructor!
};

int main() {
    Derived d(42);
    cout << d.value;  // âœ“ OK: Chá»‰ cÃ³ 1 value
}

OUTPUT:
Base(42)
42
```

â­ LÆ¯U Ã:
- virtual inheritance â†’ Chá»‰ 1 copy cá»§a Base
- Derived class PHáº¢I gá»i Base constructor
- Tá»‘n thÃªm memory vÃ  overhead

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 26: OPERATOR OVERLOADING Vá»šI INHERITANCE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

26.1. Káº¾ THá»ªA OPERATORS (Gki/test2.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST:
```cpp
class ExamA {
public:
    int ax;
    ExamA(int x = 0) : ax(x) {}
    
    // Comparison operator
    bool operator<(const ExamA& rhs) const {
        return ax < rhs.ax;
    }
    
    // Stream operator
    friend ostream& operator<<(ostream& os, const ExamA& a) {
        return os << "[A ax=" << a.ax << "]";
    }
};

class ExamB : public ExamA {
public:
    int bx;
    ExamB(int a = 0, int b = 0) : ExamA(a), bx(b) {}
    
    // â­ ExamB Káº¾ THá»ªA operator< tá»« ExamA
    // CÃ³ thá»ƒ dÃ¹ng trá»±c tiáº¿p:
    // ExamB b1(10, 20), b2(5, 30);
    // if (b1 < b2) { ... }  // So sÃ¡nh ax
};
```

26.2. OVERRIDE OPERATORS CHO DERIVED CLASS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class ExamB : public ExamA {
public:
    int bx;
    ExamB(int a = 0, int b = 0) : ExamA(a), bx(b) {}
    
    // Override operator< Ä‘á»ƒ so sÃ¡nh cáº£ ax vÃ  bx
    bool operator<(const ExamB& rhs) const {
        if (ax != rhs.ax) return ax < rhs.ax;  // So sÃ¡nh ax trÆ°á»›c
        return bx < rhs.bx;  // Náº¿u ax báº±ng nhau, so sÃ¡nh bx
    }
    
    // Override stream operator
    friend ostream& operator<<(ostream& os, const ExamB& b) {
        return os << static_cast<const ExamA&>(b)  // â­ Gá»i base operator
                  << " [B bx=" << b.bx << "]";
    }
};
```

26.3. Gá»ŒI BASE CLASS OPERATOR (Gki/test2.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST:
```cpp
class ExamB : public ExamA {
public:
    int bx;
    
    ExamB& operator=(const ExamB& o) {
        cout << "B::operator=\n";
        ExamA::operator=(o);  // â­ Gá»i base operator= trÆ°á»›c
        bx = o.bx;            // Rá»“i copy member cá»§a B
        return *this;
    }
    
    friend ostream& operator<<(ostream& os, const ExamB& b) {
        // Cast to base, gá»i base operator<<
        return os << static_cast<const ExamA&>(b)
                  << " [B bx=" << b.bx << "]";
    }
};

int main() {
    ExamB b1(10, 20), b2;
    b2 = b1;
    cout << b2 << endl;
}

OUTPUT:
B::operator=
A::operator= from 10
[A ax=10] [B bx=20]
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Tá»”NG Káº¾T PHáº¦N III: INHERITANCE & POLYMORPHISM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHECKLIST QUAN TRá»ŒNG:
â–¡ Construction order: Base â†’ Derived
â–¡ Destruction order: ~Derived â†’ ~Base
â–¡ Virtual destructor PHáº¢I cÃ³ náº¿u class Ä‘Æ°á»£c káº¿ thá»«a
â–¡ Initializer list: Gá»i base constructor trÆ°á»›c members
â–¡ Copy constructor: Pháº£i gá»i base copy constructor
â–¡ Virtual functions cho runtime polymorphism
â–¡ DÃ¹ng override keyword Ä‘á»ƒ rÃµ rÃ ng
â–¡ Pass by reference/pointer Ä‘á»ƒ trÃ¡nh slicing
â–¡ Upcasting luÃ´n an toÃ n, downcasting cáº§n dynamic_cast
â–¡ Multiple inheritance: Cáº©n tháº­n diamond problem
â–¡ Virtual inheritance giáº£i quyáº¿t diamond problem
â–¡ Operator overloading: Gá»i base operators khi override

ÄÃƒ Há»ŒC Tá»ª CODE TEST:
âœ“ Gki/test.cpp: Constructor/destructor order, virtual destructor
âœ“ Gki/test2.cpp: Copy constructor, operators vá»›i inheritance
âœ“ Gki/test3.cpp: Declare/define separation, virtual functions

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIáº¾P Tá»¤C Vá»šI PHáº¦N IV: ADVANCED CONCEPTS
Xem file Part4_Advanced_Concepts.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
