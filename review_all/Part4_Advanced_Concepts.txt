================================================================================
                  PHáº¦N IV: ADVANCED CONCEPTS (Test 3)
================================================================================

TÃ i liá»‡u Ã´n táº­p chi tiáº¿t vá» cÃ¡c khÃ¡i niá»‡m nÃ¢ng cao trong C++
Format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ VÃ­ dá»¥ code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p

================================================================================

Má»¤C Lá»¤C
â•â•â•â•â•â•â•

29. TEMPLATES (FUNCTION & CLASS)
    29.1. Function templates
    29.2. Class templates
    29.3. Template specialization
    29.4. Non-type template parameters
    
30. EXCEPTION HANDLING
    30.1. try-catch-throw
    30.2. Exception hierarchy
    30.3. noexcept
    30.4. RAII pattern
    
31. COPY CONTROL â­ RULE OF THREE/FIVE/ZERO
    31.1. Rule of Three
    31.2. Deep copy vs Shallow copy
    31.3. Copy constructor (Test2/on_8.cpp)
    31.4. Copy assignment operator
    31.5. Rule of Five (C++11)
    31.6. Copy-and-swap idiom
    
32. STATIC MEMBERS
    32.1. Static data members
    32.2. Static member functions
    32.3. Static local variables (Gki/test2.cpp)
    32.4. Static vá»›i inheritance
    
33. FRIEND FUNCTIONS & CLASSES
    33.1. Friend function
    33.2. Friend class
    33.3. Khi nÃ o dÃ¹ng friend

================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 29: TEMPLATES (FUNCTION & CLASS)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

29.1. FUNCTION TEMPLATES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Function template cho phÃ©p viáº¿t function hoáº¡t Ä‘á»™ng vá»›i nhiá»u types.

CÃš PHÃP:
```cpp
template<typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << max(10, 20);       // max<int>
    cout << max(10.5, 20.5);   // max<double>
    cout << max('a', 'z');     // max<char>
}
```

VÃ Dá»¤ Äáº¦Y Äá»¦:
```cpp
template<typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

template<typename T>
void print(const T& value) {
    cout << value << endl;
}

template<typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int x = 10, y = 20;
    swap(x, y);
    cout << x << " " << y << endl;  // 20 10
    
    print(42);
    print(3.14);
    print("Hello");
    
    cout << add(10, 20) << endl;      // 30
    cout << add(10.5, 20.5) << endl;  // 31
}
```

MULTIPLE TEMPLATE PARAMETERS:
```cpp
template<typename T1, typename T2>
void print(const T1& a, const T2& b) {
    cout << a << " " << b << endl;
}

print(10, 3.14);     // int, double
print("Age:", 25);   // const char*, int
```

29.2. CLASS TEMPLATES (Template/Vector.h)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Class template cho phÃ©p táº¡o class hoáº¡t Ä‘á»™ng vá»›i nhiá»u types.

VÃ Dá»¤:
```cpp
template<typename T>
class Vector {
    T* data;
    int size;
public:
    Vector(T value, int s) : size(s) {
        data = new T[size];
        for (int i = 0; i < size; i++) {
            data[i] = value;
        }
    }
    
    ~Vector() {
        delete[] data;
    }
    
    void Show() const {
        for (int i = 0; i < size; i++) {
            cout << data[i] << " ";
        }
        cout << endl;
    }
    
    T& operator[](int index) {
        return data[index];
    }
};

int main() {
    Vector<int> v1(5, 3);
    v1.Show();  // 5 5 5
    
    Vector<double> v2(3.14, 2);
    v2.Show();  // 3.14 3.14
    
    Vector<string> v3("Hello", 2);
    v3.Show();  // Hello Hello
}
```

Vá»šI CUSTOM TYPES:
```cpp
class Point {
    int x, y;
public:
    Point(int a = 0, int b = 0) : x(a), y(b) {}
    friend ostream& operator<<(ostream& os, const Point& p) {
        return os << "(" << p.x << "," << p.y << ")";
    }
};

int main() {
    Vector<Point> v(Point(1, 2), 3);
    v.Show();  // (1,2) (1,2) (1,2)
}
```

29.3. TEMPLATE SPECIALIZATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Äá»‹nh nghÄ©a riÃªng cho má»™t type cá»¥ thá»ƒ.

VÃ Dá»¤:
```cpp
// Generic template
template<typename T>
class Container {
    T value;
public:
    Container(T v) : value(v) {}
    void print() { cout << value << endl; }
};

// Specialization cho bool
template<>
class Container<bool> {
    bool value;
public:
    Container(bool v) : value(v) {}
    void print() {
        cout << (value ? "true" : "false") << endl;
    }
};

int main() {
    Container<int> c1(42);
    c1.print();  // 42
    
    Container<bool> c2(true);
    c2.print();  // true
}
```

29.4. NON-TYPE TEMPLATE PARAMETERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
template<typename T, int SIZE>
class Array {
    T data[SIZE];
public:
    Array() {
        for (int i = 0; i < SIZE; i++) {
            data[i] = T();
        }
    }
    
    T& operator[](int index) {
        return data[index];
    }
    
    int size() const { return SIZE; }
};

int main() {
    Array<int, 10> arr1;
    Array<double, 5> arr2;
    
    cout << arr1.size() << endl;  // 10
    cout << arr2.size() << endl;  // 5
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 30: EXCEPTION HANDLING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

30.1. TRY-CATCH-THROW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CÃš PHÃP:
```cpp
try {
    // Code cÃ³ thá»ƒ throw exception
    throw exception_object;
} catch (ExceptionType& e) {
    // Xá»­ lÃ½ exception
}
```

VÃ Dá»¤ CÆ  Báº¢N:
```cpp
#include <iostream>
#include <stdexcept>
using namespace std;

double divide(double a, double b) {
    if (b == 0) {
        throw runtime_error("Division by zero!");
    }
    return a / b;
}

int main() {
    try {
        cout << divide(10, 2) << endl;   // 5
        cout << divide(10, 0) << endl;   // Throw!
    } catch (const runtime_error& e) {
        cout << "Error: " << e.what() << endl;
    }
    
    cout << "Program continues..." << endl;
}

OUTPUT:
5
Error: Division by zero!
Program continues...
```

30.2. EXCEPTION HIERARCHY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STD::EXCEPTION HIERARCHY:
```
std::exception
  â”œâ”€ logic_error
  â”‚   â”œâ”€ invalid_argument
  â”‚   â”œâ”€ domain_error
  â”‚   â”œâ”€ length_error
  â”‚   â”œâ”€ out_of_range
  â”‚   â””â”€ future_error
  â””â”€ runtime_error
      â”œâ”€ range_error
      â”œâ”€ overflow_error
      â””â”€ underflow_error
```

VÃ Dá»¤:
```cpp
class Array {
    int* data;
    int size;
public:
    Array(int s) : size(s) {
        if (s <= 0) {
            throw invalid_argument("Size must be positive");
        }
        data = new int[size];
    }
    
    ~Array() { delete[] data; }
    
    int& operator[](int index) {
        if (index < 0 || index >= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }
};

int main() {
    try {
        Array arr(10);
        arr[5] = 42;   // OK
        arr[20] = 10;  // Throw out_of_range
    } catch (const invalid_argument& e) {
        cout << "Invalid argument: " << e.what() << endl;
    } catch (const out_of_range& e) {
        cout << "Out of range: " << e.what() << endl;
    } catch (const exception& e) {
        cout << "Exception: " << e.what() << endl;
    }
}
```

MULTIPLE CATCH:
```cpp
try {
    // ...
} catch (const out_of_range& e) {
    // Specific exception first
} catch (const logic_error& e) {
    // More general exception
} catch (const exception& e) {
    // Most general
} catch (...) {
    // Catch all (khÃ´ng khuyÃªn dÃ¹ng)
}
```

30.3. NOEXCEPT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Chá»‰ Ä‘á»‹nh function khÃ´ng throw exception.

VÃ Dá»¤:
```cpp
int add(int a, int b) noexcept {
    return a + b;  // KhÃ´ng throw
}

int divide(int a, int b) noexcept(false) {
    if (b == 0) throw runtime_error("Div by zero");
    return a / b;
}

// Move constructor nÃªn noexcept
class MyClass {
public:
    MyClass(MyClass&& other) noexcept {
        // Move without throwing
    }
};
```

30.4. RAII PATTERN
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Resource Acquisition Is Initialization - Tá»± Ä‘á»™ng quáº£n lÃ½ resources.

VÃ Dá»¤:
```cpp
class FileHandle {
    FILE* file;
public:
    FileHandle(const char* name) {
        file = fopen(name, "r");
        if (!file) {
            throw runtime_error("Cannot open file");
        }
    }
    
    ~FileHandle() {
        if (file) {
            fclose(file);  // â­ Tá»± Ä‘á»™ng close
        }
    }
    
    // Prevent copy
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;
};

int main() {
    try {
        FileHandle f("data.txt");
        // Use file...
        throw runtime_error("Error!");
    } catch (...) {
        // File tá»± Ä‘á»™ng close trong ~FileHandle()
    }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 31: COPY CONTROL â­ RULE OF THREE/FIVE/ZERO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

31.1. RULE OF THREE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â­ QUY Táº®C:
Náº¿u class cáº§n má»™t trong ba, thÃ¬ cáº§n Cáº¢ BA:
1. Destructor
2. Copy constructor
3. Copy assignment operator

Táº I SAO?
- Class quáº£n lÃ½ dynamic memory
- Cáº§n deep copy thay vÃ¬ shallow copy
- TrÃ¡nh double delete

31.2. DEEP COPY VS SHALLOW COPY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SHALLOW COPY (âŒ NGUY HIá»‚M):
```cpp
class Bad {
    int* data;
public:
    Bad(int value) {
        data = new int(value);
    }
    
    // âŒ Compiler-generated copy constructor (shallow copy)
    // Bad(const Bad& other) : data(other.data) {}
    
    ~Bad() {
        delete data;  // âŒ DOUBLE DELETE!
    }
};

int main() {
    Bad b1(42);
    Bad b2 = b1;  // Shallow copy: b2.data = b1.data (same pointer!)
}  // âŒ CRASH: b2.~Bad() delete data, rá»“i b1.~Bad() delete data again!
```

DEEP COPY (âœ“ ÄÃšNG):
```cpp
class Good {
    int* data;
public:
    Good(int value) {
        data = new int(value);
    }
    
    // âœ“ Deep copy constructor
    Good(const Good& other) {
        data = new int(*other.data);  // âœ“ New memory!
    }
    
    // âœ“ Copy assignment operator
    Good& operator=(const Good& other) {
        if (this != &other) {
            delete data;  // Delete old
            data = new int(*other.data);  // Deep copy new
        }
        return *this;
    }
    
    ~Good() {
        delete data;  // âœ“ Safe: Each object owns its data
    }
};
```

31.3. VÃ Dá»¤ CODE Tá»ª TEST (Test2/on_8.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```cpp
class Exam {
    int prop;
public:
    Exam(int = 1);
    Exam(const Exam&);  // Copy constructor
    ~Exam();
    const Exam& operator=(const Exam&);  // Assignment
};

Exam::Exam(int prop) : prop(prop) {
    cout << "1";
}

Exam::Exam(Exam const& obj) : prop(obj.prop) {
    cout << "2";  // Copy constructor called
}

Exam::~Exam() {}

const Exam& Exam::operator=(Exam const& obj) {
    if (this != &obj) {  // â­ Self-assignment check
        this->prop = obj.prop;
        cout << "3";
    }
    return *this;
}
```

31.4. RULE OF FIVE (C++11)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

THÃŠM 2 FUNCTIONS:
4. Move constructor
5. Move assignment operator

VÃ Dá»¤:
```cpp
class MyString {
    char* data;
    int length;
public:
    // 1. Destructor
    ~MyString() {
        delete[] data;
    }
    
    // 2. Copy constructor
    MyString(const MyString& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }
    
    // 3. Copy assignment
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data;
            length = other.length;
            data = new char[length + 1];
            strcpy(data, other.data);
        }
        return *this;
    }
    
    // 4. Move constructor (C++11)
    MyString(MyString&& other) noexcept {
        data = other.data;
        length = other.length;
        other.data = nullptr;  // â­ Steal resources
        other.length = 0;
    }
    
    // 5. Move assignment (C++11)
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            length = other.length;
            other.data = nullptr;  // â­ Steal resources
            other.length = 0;
        }
        return *this;
    }
};
```

31.5. COPY-AND-SWAP IDIOM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ELEGANT SOLUTION:
```cpp
class MyString {
    char* data;
    int length;
public:
    // Helper: swap
    void swap(MyString& other) noexcept {
        std::swap(data, other.data);
        std::swap(length, other.length);
    }
    
    // Copy constructor
    MyString(const MyString& other) {
        length = other.length;
        data = new char[length + 1];
        strcpy(data, other.data);
    }
    
    // Assignment dÃ¹ng copy-and-swap
    MyString& operator=(MyString other) {  // â­ Pass by value
        swap(other);  // Swap vá»›i copy
        return *this;
        // other's destructor cleans up old data
    }
};
```

Æ¯U ÄIá»‚M:
âœ“ Exception-safe
âœ“ Self-assignment safe
âœ“ Ngáº¯n gá»n
âœ“ Reuse copy constructor

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 32: STATIC MEMBERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

32.1. STATIC DATA MEMBERS (Gki/test2.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Static members Ä‘Æ°á»£c share bá»Ÿi Táº¤T Cáº¢ objects cá»§a class.

VÃ Dá»¤ Tá»ª TEST:
```cpp
class ExamA {
public:
    int ax;                    // Instance member
    static int sA;             // â­ Static member (shared)
    
    ExamA(int x = 0) : ax(x) {}
};

// â­ PHáº¢I define á»Ÿ ngoÃ i class
int ExamA::sA = 100;

int main() {
    ExamA obj1, obj2, obj3;
    
    obj1.ax = 10;
    obj2.ax = 20;
    obj3.ax = 30;
    // Each object has its own ax
    
    ExamA::sA = 200;  // Change static member
    // âœ“ ALL objects see sA = 200
    
    cout << obj1.sA << endl;  // 200
    cout << obj2.sA << endl;  // 200
    cout << obj3.sA << endl;  // 200
}
```

HÃŒNH DUNG:
```
Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ obj1       â”‚
â”‚  ax = 10   â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ obj2       â”‚  â”œâ”€â†’ All share
â”‚  ax = 20   â”‚â”€â”€â”¤   sA = 200
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ obj3       â”‚  â”‚
â”‚  ax = 30   â”‚â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Static:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ sA = 200   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

32.2. STATIC MEMBER FUNCTIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class Counter {
    static int count;
public:
    Counter() { count++; }
    ~Counter() { count--; }
    
    // â­ Static function
    static int getCount() {
        return count;
    }
};

int Counter::count = 0;

int main() {
    cout << Counter::getCount() << endl;  // 0
    
    Counter c1, c2, c3;
    cout << Counter::getCount() << endl;  // 3
}
```

LÆ¯U Ã:
- Static functions KHÃ”NG cÃ³ this pointer
- Chá»‰ access Ä‘Æ°á»£c static members
- Gá»i qua class name: Class::function()

32.3. STATIC LOCAL VARIABLES (Gki/test2.cpp)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST:
```cpp
class ExamA {
public:
    static int nextId() {
        static int id = 0;  // â­ Static local
        return ++id;
    }
};

int main() {
    cout << ExamA::nextId() << endl;  // 1
    cout << ExamA::nextId() << endl;  // 2
    cout << ExamA::nextId() << endl;  // 3
    // id giá»¯ giÃ¡ trá»‹ giá»¯a cÃ¡c láº§n gá»i
}
```

HÃ€NH VI:
- Init chá»‰ 1 láº§n (first call)
- Giá»¯ giÃ¡ trá»‹ giá»¯a cÃ¡c láº§n gá»i
- Destroy khi program káº¿t thÃºc

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 33: FRIEND FUNCTIONS & CLASSES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

33.1. FRIEND FUNCTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Friend function cÃ³ thá»ƒ access private/protected members.

VÃ Dá»¤:
```cpp
class MyClass {
    int secret;
public:
    MyClass(int s) : secret(s) {}
    
    // â­ Declare friend
    friend void showSecret(const MyClass& obj);
};

// Friend function CAN access private
void showSecret(const MyClass& obj) {
    cout << "Secret: " << obj.secret << endl;  // âœ“ OK!
}

int main() {
    MyClass obj(42);
    showSecret(obj);  // Secret: 42
}
```

33.2. FRIEND CLASS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤:
```cpp
class ClassA {
    int secret;
public:
    ClassA(int s) : secret(s) {}
    
    // â­ Declare friend class
    friend class ClassB;
};

class ClassB {
public:
    void showSecret(const ClassA& a) {
        cout << a.secret << endl;  // âœ“ OK: B is friend of A
    }
};

int main() {
    ClassA a(42);
    ClassB b;
    b.showSecret(a);  // 42
}
```

33.3. KHI NÃ€O DÃ™NG FRIEND
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ“ DÃ™NG KHI:
- Stream operators (<<, >>)
- Binary operators cáº§n symmetry
- Closely related classes
- Performance-critical code

âŒ TRÃNH KHI:
- CÃ³ thá»ƒ dÃ¹ng public interface
- Breaking encapsulation khÃ´ng cáº§n thiáº¿t
- KhÃ´ng cÃ³ relationship rÃµ rÃ ng

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ Tá»”NG Káº¾T PHáº¦N IV: ADVANCED CONCEPTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHECKLIST QUAN TRá»ŒNG:
â–¡ Templates cho code reuse vá»›i multiple types
â–¡ Class templates cáº§n explicit instantiation
â–¡ Exception handling: try-catch-throw
â–¡ RAII pattern tá»± Ä‘á»™ng quáº£n lÃ½ resources
â–¡ Rule of Three: Destructor + Copy ctor + Copy assignment
â–¡ Rule of Five: + Move ctor + Move assignment
â–¡ Deep copy cho dynamic memory
â–¡ Self-assignment check trong operator=
â–¡ Static members shared by all objects
â–¡ Static local variables giá»¯ giÃ¡ trá»‹ giá»¯a calls
â–¡ Friend functions access private members
â–¡ DÃ¹ng friend cho operators khi cáº§n

ÄÃƒ Há»ŒC Tá»ª CODE TEST:
âœ“ Template/B1.cpp: Class templates vá»›i multiple types
âœ“ Test2/on_8.cpp: Copy constructor vÃ  assignment operator
âœ“ Gki/test2.cpp: Static members vÃ  static local variables

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TIáº¾P Tá»¤C Vá»šI PHáº¦N V: SUMMARY & PRACTICE
Xem file Part5_Summary_Practice.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
