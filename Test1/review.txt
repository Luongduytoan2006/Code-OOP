================================================================================
                    TÃ€I LIá»†U Ã”N Táº¬P OOP - TEST 1
              C++ FUNDAMENTALS & BASIC CONCEPTS
================================================================================

Má»¤C Lá»¤C:
1. REFERENCES (THAM CHIáº¾U)
2. POINTERS (CON TRá»)
3. SIZEOF OPERATOR
4. DEFAULT PARAMETERS
5. PASS BY VALUE/REFERENCE/POINTER
6. TYPE PROMOTION & CONVERSION
7. CÃC Lá»–I THÆ¯á»œNG Gáº¶P
8. TIPS & TRICKS

================================================================================
1. REFERENCES (THAM CHIáº¾U)
================================================================================

1.1. KHÃI NIá»†M CÆ  Báº¢N
----------------------
Reference lÃ  ALIAS (bÃ­ danh) cá»§a má»™t biáº¿n Ä‘Ã£ tá»“n táº¡i.

CÃš PHÃP:
    int x = 10;
    int& ref = x;  // ref lÃ  bÃ­ danh cá»§a x
    
    ref = 20;      // x cÅ©ng thÃ nh 20
    cout << x;     // 20

Äáº¶C ÄIá»‚M:
âœ“ PHáº¢I KHá»I Táº O khi khai bÃ¡o
âœ“ KHÃ”NG THá»‚ THAY Äá»”I sau khi khá»Ÿi táº¡o (khÃ´ng thá»ƒ re-bind)
âœ“ KHÃ”NG Tá»’N Táº I Äá»˜C Láº¬P (luÃ´n tham chiáº¿u Ä‘áº¿n biáº¿n khÃ¡c)

1.2. REFERENCE VS POINTER
-------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Äáº¶C ÄIá»‚M        â”‚ REFERENCE    â”‚ POINTER       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pháº£i khá»Ÿi táº¡o   â”‚ Báº¯t buá»™c     â”‚ KhÃ´ng báº¯t buá»™câ”‚
â”‚ Thay Ä‘á»•i target â”‚ KhÃ´ng thá»ƒ    â”‚ CÃ³ thá»ƒ        â”‚
â”‚ Null            â”‚ KhÃ´ng thá»ƒ    â”‚ CÃ³ thá»ƒ        â”‚
â”‚ CÃº phÃ¡p         â”‚ ÄÆ¡n giáº£n     â”‚ DÃ¹ng * vÃ  &   â”‚
â”‚ Overhead        â”‚ KhÃ´ng        â”‚ CÃ³ (size)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VÃ Dá»¤ Tá»ª TEST (on_1.cpp):

    int x = 10;
    int& ref = x;    // Reference
    int* ptr = &x;   // Pointer
    
    ref = 20;        // x = 20
    *ptr = 30;       // x = 30
    
    int y = 40;
    ref = y;         // x = 40 (KHÃ”NG pháº£i ref tham chiáº¿u y)
    ptr = &y;        // ptr giá» trá» Ä‘áº¿n y (Äá»”I TARGET)

1.3. REFERENCE PARAMETERS
-------------------------
VÃ Dá»¤ Tá»ª TEST (on_32.cpp):

    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
    
    int main() {
        int x = 5, y = 10;
        swap(x, y);
        cout << x << y;  // 10 5 (Ä‘Ã£ Ä‘á»•i chá»—)
    }

Táº I SAO DÃ™NG REFERENCE?
âœ“ TrÃ¡nh copy (hiá»‡u quáº£ vá»›i objects lá»›n)
âœ“ Thay Ä‘á»•i biáº¿n gá»‘c
âœ“ CÃº phÃ¡p Ä‘Æ¡n giáº£n hÆ¡n pointer

1.4. CONST REFERENCE
--------------------
VÃ Dá»¤ Tá»ª TEST (on_33.cpp):

    void printValue(const int& x) {
        cout << x;
        // x = 10;  // COMPILE ERROR! KhÃ´ng thá»ƒ thay Ä‘á»•i
    }
    
    int main() {
        int val = 5;
        printValue(val);      // OK
        printValue(10);       // OK: const ref cÃ³ thá»ƒ bind vá»›i rvalue
    }

Æ¯U ÄIá»‚M:
âœ“ TrÃ¡nh copy (hiá»‡u quáº£)
âœ“ An toÃ n (khÃ´ng thay Ä‘á»•i giÃ¡ trá»‹)
âœ“ CÃ³ thá»ƒ nháº­n rvalue (temporary)

1.5. REFERENCE TO POINTER
--------------------------
VÃ Dá»¤ Tá»ª TEST (on_34.cpp):

    void allocate(int*& ptr, int size) {
        ptr = new int[size];  // Thay Ä‘á»•i pointer gá»‘c
    }
    
    int main() {
        int* p = nullptr;
        allocate(p, 5);  // p giá» trá» Ä‘áº¿n array má»›i
        p[0] = 10;       // OK
        delete[] p;
    }

KHI NÃ€O DÃ™NG?
- Muá»‘n thay Ä‘á»•i pointer trong function
- TrÃ¡nh dÃ¹ng double pointer (int**)

1.6. DANGLING REFERENCE
-----------------------
âŒ Lá»–I NGUY HIá»‚M:

    int& getReference() {
        int x = 10;
        return x;  // NGUY HIá»‚M! x bá»‹ há»§y sau khi return
    }
    
    int main() {
        int& ref = getReference();
        cout << ref;  // UNDEFINED BEHAVIOR!
    }

QUY Táº®C:
âŒ KHÃ”NG return reference Ä‘áº¿n local variable
âœ“ Return reference Ä‘áº¿n:
  - Static variable
  - Global variable
  - Member variable
  - Parameter (reference)

================================================================================
2. POINTERS (CON TRá»)
================================================================================

2.1. KHÃI NIá»†M CÆ  Báº¢N
----------------------
Pointer lÃ  biáº¿n lÆ°u Ä‘á»‹a chá»‰ cá»§a biáº¿n khÃ¡c.

CÃš PHÃP:
    int x = 10;
    int* ptr = &x;  // ptr lÆ°u Ä‘á»‹a chá»‰ cá»§a x
    
    cout << ptr;    // Äá»‹a chá»‰ cá»§a x
    cout << *ptr;   // 10 (giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰)

TOÃN Tá»¬:
- & : Address-of operator (láº¥y Ä‘á»‹a chá»‰)
- * : Dereference operator (láº¥y giÃ¡ trá»‹)

2.2. POINTER ARITHMETIC
-----------------------
VÃ Dá»¤ Tá»ª TEST (on_36.cpp):

    int arr[5] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // ptr trá» Ä‘áº¿n arr[0]
    
    cout << *ptr;       // 10
    cout << *(ptr+1);   // 20
    cout << ptr[2];     // 30 (tÆ°Æ¡ng Ä‘Æ°Æ¡ng *(ptr+2))
    
    ptr++;              // ptr giá» trá» Ä‘áº¿n arr[1]
    cout << *ptr;       // 20

QUY Táº®C:
- ptr + n â†’ Nháº£y n pháº§n tá»­ (n * sizeof(type))
- ptr++ â†’ Nháº£y 1 pháº§n tá»­
- ptr - ptr2 â†’ Sá»‘ pháº§n tá»­ giá»¯a 2 con trá»

2.3. NULL POINTER
-----------------
    int* ptr = nullptr;  // C++11
    int* ptr2 = NULL;    // C-style
    int* ptr3 = 0;       // Old style
    
    if (ptr == nullptr) {
        cout << "Null pointer";
    }

BEST PRACTICE:
âœ“ Khá»Ÿi táº¡o pointer vá»›i nullptr
âœ“ Kiá»ƒm tra nullptr trÆ°á»›c khi dereference
âœ“ GÃ¡n nullptr sau khi delete

2.4. DYNAMIC MEMORY
-------------------
VÃ Dá»¤ Tá»ª TEST (on_37.cpp):

    int* ptr = new int(10);        // Cáº¥p phÃ¡t 1 int
    int* arr = new int[5];         // Cáº¥p phÃ¡t array
    
    cout << *ptr;                  // 10
    arr[0] = 100;
    
    delete ptr;                    // Giáº£i phÃ³ng 1 object
    delete[] arr;                  // Giáº£i phÃ³ng array
    
    ptr = nullptr;                 // Avoid dangling pointer

QUY Táº®C:
âœ“ new â†’ delete
âœ“ new[] â†’ delete[]
âœ“ GÃ¡n nullptr sau delete
âœ“ KhÃ´ng delete 2 láº§n

2.5. POINTER TO POINTER
-----------------------
VÃ Dá»¤:
    int x = 10;
    int* ptr = &x;      // ptr trá» Ä‘áº¿n x
    int** pptr = &ptr;  // pptr trá» Ä‘áº¿n ptr
    
    cout << **pptr;     // 10

á»¨NG Dá»¤NG:
- Dynamic 2D arrays
- Function thay Ä‘á»•i pointer
- Linked structures

2.6. FUNCTION POINTER
---------------------
VÃ Dá»¤ Tá»ª TEST (on_39.cpp):

    int add(int a, int b) {
        return a + b;
    }
    
    int main() {
        int (*funcPtr)(int, int) = add;
        cout << funcPtr(5, 3);  // 8
    }

á»¨NG Dá»¤NG:
- Callback functions
- Event handlers
- Function tables

================================================================================
3. SIZEOF OPERATOR
================================================================================

3.1. KHÃI NIá»†M
--------------
sizeof tráº£ vá» kÃ­ch thÆ°á»›c (bytes) cá»§a type hoáº·c variable.

CÃš PHÃP:
    sizeof(type)
    sizeof(variable)
    sizeof variable  // KhÃ´ng cáº§n ()

VÃ Dá»¤:
    cout << sizeof(int);      // 4 (thÆ°á»ng)
    cout << sizeof(char);     // 1
    cout << sizeof(double);   // 8

3.2. SIZEOF Vá»šI ARRAY
---------------------
VÃ Dá»¤ Tá»ª TEST (on_40.cpp):

    int arr[10];
    cout << sizeof(arr);        // 40 (10 * sizeof(int))
    cout << sizeof(arr[0]);     // 4
    
    int length = sizeof(arr) / sizeof(arr[0]);  // 10

LÆ¯U Ã:
    void func(int arr[]) {
        cout << sizeof(arr);  // SIZE Cá»¦A POINTER! (4 or 8)
    }
    
    int main() {
        int arr[10];
        func(arr);  // Array decay thÃ nh pointer

3.3. SIZEOF Vá»šI POINTER
-----------------------
VÃ Dá»¤ Tá»ª TEST (on_43.cpp):

    int x = 10;
    int* ptr = &x;
    
    cout << sizeof(ptr);   // 4 (32-bit) hoáº·c 8 (64-bit)
    cout << sizeof(*ptr);  // 4 (sizeof(int))

3.4. SIZEOF KHÃ”NG CÃ“ SIDE EFFECTS
----------------------------------
VÃ Dá»¤ Tá»ª TEST (on_44.cpp):

    int x = 5;
    sizeof(x++);  // sizeof KHÃ”NG THá»°C HIá»†N x++
    cout << x;    // 5 (khÃ´ng thay Ä‘á»•i)

GIáº¢I THÃCH:
- sizeof lÃ  compile-time operator
- Chá»‰ tÃ­nh kÃ­ch thÆ°á»›c, khÃ´ng evaluate expression

VÃ Dá»¤ QUAN TRá»ŒNG Tá»ª TEST:

    int x = 5;
    int y = sizeof(x++);
    cout << x << y;  // 54 (x váº«n lÃ  5, y = sizeof(int) = 4)

3.5. SIZEOF Vá»šI CLASS
---------------------
VÃ Dá»¤ Tá»ª TEST (on_45.cpp):

    class Base {
        int x;      // 4 bytes
        double y;   // 8 bytes
    };
    
    cout << sizeof(Base);  // 16 (cÃ³ padding/alignment)

PADDING:
    class Example {
        char c;   // 1 byte
        int i;    // 4 bytes
        // 3 bytes padding sau c
    };
    
    sizeof(Example) = 8 (khÃ´ng pháº£i 5!)

3.6. SIZEOF Vá»šI EMPTY CLASS
----------------------------
    class Empty {};
    cout << sizeof(Empty);  // 1 (khÃ´ng pháº£i 0!)

LÃ DO:
- Má»—i object cáº§n Ä‘á»‹a chá»‰ riÃªng
- Minimum size = 1 byte

================================================================================
4. DEFAULT PARAMETERS
================================================================================

4.1. KHÃI NIá»†M
--------------
Default parameters cho phÃ©p hÃ m cÃ³ giÃ¡ trá»‹ máº·c Ä‘á»‹nh cho tham sá»‘.

CÃš PHÃP:
    void func(int x, int y = 10, int z = 5) {
        cout << x + y + z;
    }
    
    func(1);        // x=1, y=10, z=5 â†’ 16
    func(1, 2);     // x=1, y=2, z=5 â†’ 8
    func(1, 2, 3);  // x=1, y=2, z=3 â†’ 6

4.2. QUY Táº®C
------------
VÃ Dá»¤ Tá»ª TEST (on_46.cpp):

âœ“ ÄÃšNG:
    void func(int x, int y = 10, int z = 5);

âŒ SAI:
    void func(int x = 1, int y, int z);  // Default pháº£i á»Ÿ cuá»‘i
    void func(int x, int y = 10, int z); // z khÃ´ng cÃ³ default

QUY Táº®C:
âœ“ Default parameters pháº£i á»Ÿ CUá»I danh sÃ¡ch
âœ“ KhÃ´ng thá»ƒ bá» qua parameter á»Ÿ giá»¯a
âœ“ Chá»‰ khai bÃ¡o default trong declaration (khÃ´ng trong definition)

4.3. TRÆ¯á»œNG Há»¢P Äáº¶C BIá»†T
-------------------------
VÃ Dá»¤ Tá»ª TEST (on_47.cpp):

    void func(int x, int y = x) {  // Lá»–I! KhÃ´ng thá»ƒ dÃ¹ng x
        cout << x + y;
    }

âœ“ ÄÃšNG:
    void func(int x, int y = 10) {
        cout << x + y;
    }

4.4. DEFAULT Vá»šI OVERLOADING
-----------------------------
VÃ Dá»¤:
    void func(int x);
    void func(int x, int y = 10);
    
    func(5);  // AMBIGUOUS! Cáº£ 2 hÃ m Ä‘á»u match

GIáº¢I PHÃP:
- TrÃ¡nh dÃ¹ng default parameter vá»›i overloaded functions
- Hoáº·c Ä‘áº£m báº£o khÃ´ng cÃ³ ambiguity

================================================================================
5. PASS BY VALUE/REFERENCE/POINTER
================================================================================

5.1. PASS BY VALUE
------------------
VÃ Dá»¤ Tá»ª TEST (on_49.cpp):

    void func(int x) {  // Copy x
        x = 10;
    }
    
    int main() {
        int a = 5;
        func(a);
        cout << a;  // 5 (khÃ´ng thay Ä‘á»•i)
    }

Äáº¶C ÄIá»‚M:
- Táº¡o COPY cá»§a biáº¿n
- Thay Ä‘á»•i trong function KHÃ”NG áº£nh hÆ°á»Ÿng biáº¿n gá»‘c
- COSTLY vá»›i objects lá»›n

5.2. PASS BY REFERENCE
----------------------
VÃ Dá»¤ Tá»ª TEST (on_50.cpp):

    void func(int& x) {  // Reference
        x = 10;
    }
    
    int main() {
        int a = 5;
        func(a);
        cout << a;  // 10 (Ä‘Ã£ thay Ä‘á»•i)
    }

Äáº¶C ÄIá»‚M:
- KHÃ”NG táº¡o copy
- Thay Ä‘á»•i trong function áº¢NH HÆ¯á»NG biáº¿n gá»‘c
- Hiá»‡u quáº£ vá»›i objects lá»›n

5.3. PASS BY POINTER
--------------------
VÃ Dá»¤:
    void func(int* ptr) {
        *ptr = 10;
    }
    
    int main() {
        int a = 5;
        func(&a);
        cout << a;  // 10
    }

Äáº¶C ÄIá»‚M:
- Truyá»n Ä‘á»‹a chá»‰
- CÃ³ thá»ƒ nullptr
- CÃº phÃ¡p phá»©c táº¡p hÆ¡n reference

5.4. SO SÃNH
------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚ Value    â”‚ Reference â”‚ Pointer    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Copy         â”‚ CÃ³       â”‚ KhÃ´ng     â”‚ Copy ptr   â”‚
â”‚ Modify gá»‘c   â”‚ KhÃ´ng    â”‚ CÃ³        â”‚ CÃ³         â”‚
â”‚ Null         â”‚ N/A      â”‚ KhÃ´ng thá»ƒ â”‚ CÃ³ thá»ƒ     â”‚
â”‚ Syntax       â”‚ ÄÆ¡n giáº£n â”‚ ÄÆ¡n giáº£n  â”‚ Phá»©c táº¡p   â”‚
â”‚ Overhead     â”‚ High     â”‚ Low       â”‚ Low        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5.5. CONST REFERENCE
--------------------
    void print(const int& x) {
        cout << x;
        // x = 10;  // ERROR! KhÃ´ng thá»ƒ thay Ä‘á»•i
    }

Æ¯U ÄIá»‚M:
âœ“ KhÃ´ng copy (hiá»‡u quáº£)
âœ“ KhÃ´ng thay Ä‘á»•i (an toÃ n)
âœ“ CÃ³ thá»ƒ nháº­n temporary

KHI NÃ€O DÃ™NG?
- Function chá»‰ Ä‘á»c giÃ¡ trá»‹
- Tham sá»‘ lÃ  object lá»›n
- KhÃ´ng muá»‘n copy

5.6. RETURN BY VALUE/REFERENCE
-------------------------------
VÃ Dá»¤ Tá»ª TEST:

A) Return by value:
    int getMax(int a, int b) {
        return (a > b) ? a : b;  // Copy
    }

B) Return by reference:
    int& getElement(int arr[], int index) {
        return arr[index];  // Reference
    }
    
    int main() {
        int arr[5] = {1,2,3,4,5};
        getElement(arr, 0) = 10;  // arr[0] = 10
    }

Cáº¢NH BÃO:
âŒ KHÃ”NG return reference Ä‘áº¿n local variable!

    int& func() {
        int x = 10;
        return x;  // DANGLING REFERENCE!
    }

================================================================================
6. TYPE PROMOTION & CONVERSION
================================================================================

6.1. IMPLICIT TYPE CONVERSION
------------------------------
VÃ Dá»¤:
    int x = 5;
    double y = x;  // int â†’ double (widening)
    
    double z = 3.14;
    int w = z;     // double â†’ int (narrowing, máº¥t dá»¯ liá»‡u)

6.2. TYPE PROMOTION IN EXPRESSIONS
-----------------------------------
VÃ Dá»¤ Tá»ª TEST:

    char c = 'A';  // ASCII 65
    int result = c + 1;  // char â†’ int, result = 66
    
    cout << result;  // 66

QUY Táº®C PROMOTION:
    char, short â†’ int
    int â†’ long â†’ long long
    float â†’ double

6.3. TYPE CONVERSION WITH FUNCTIONS
------------------------------------
VÃ Dá»¤:
    void func(double x) {
        cout << x;
    }
    
    int main() {
        func(5);  // int â†’ double (implicit conversion)
    }

6.4. EXPLICIT CAST
------------------
    double x = 3.14;
    int y = (int)x;           // C-style cast
    int z = static_cast<int>(x);  // C++ style

================================================================================
7. CÃC Lá»–I THÆ¯á»œNG Gáº¶P
================================================================================

7.1. CONFUSING REFERENCE WITH POINTER
--------------------------------------
âŒ SAI:
    int x = 10;
    int& ref = &x;  // Lá»–I! &x lÃ  Ä‘á»‹a chá»‰ (int*), khÃ´ng pháº£i int

âœ“ ÄÃšNG:
    int& ref = x;   // ref tham chiáº¿u x

7.2. DANGLING REFERENCE/POINTER
--------------------------------
âŒ SAI:
    int& getRef() {
        int x = 10;
        return x;  // x bá»‹ há»§y sau return
    }

âœ“ ÄÃšNG:
    int& getRef(int& x) {
        return x;  // x tá»“n táº¡i ngoÃ i function
    }

7.3. SIZEOF SIDE EFFECTS
-------------------------
âŒ NHáº¦M TÆ¯ DUY:
    int x = 5;
    sizeof(x++);  // x++ KHÃ”NG Ä‘Æ°á»£c thá»±c hiá»‡n
    // x váº«n lÃ  5

7.4. ARRAY DECAY
----------------
    void func(int arr[]) {
        int size = sizeof(arr) / sizeof(arr[0]);  // SAI!
        // arr decay thÃ nh pointer, sizeof(arr) = sizeof(pointer)
    }

âœ“ ÄÃšNG:
    void func(int arr[], int size) {
        // Truyá»n size nhÆ° tham sá»‘
    }

7.5. DELETE SAI CÃCH
--------------------
âŒ SAI:
    int* arr = new int[10];
    delete arr;  // NÃªn dÃ¹ng delete[]

âœ“ ÄÃšNG:
    int* arr = new int[10];
    delete[] arr;

7.6. DEFAULT PARAMETER ORDER
-----------------------------
âŒ SAI:
    void func(int x = 10, int y);  // Default pháº£i á»Ÿ cuá»‘i

âœ“ ÄÃšNG:
    void func(int x, int y = 10);

7.7. MISSING nullptr CHECK
---------------------------
âŒ SAI:
    int* ptr = nullptr;
    *ptr = 10;  // CRASH! Dereference null pointer

âœ“ ÄÃšNG:
    int* ptr = nullptr;
    if (ptr != nullptr) {
        *ptr = 10;
    }

================================================================================
8. TIPS & TRICKS
================================================================================

8.1. REFERENCE BEST PRACTICES
------------------------------
âœ“ DÃ¹ng const reference cho parameters (trÃ¡nh copy)
âœ“ Return reference cho member variables
âŒ KhÃ´ng return reference Ä‘áº¿n local variables
âœ“ Prefer reference over pointer (trá»« khi cáº§n nullptr)

PATTERN:
    // Read-only parameter
    void print(const MyClass& obj);
    
    // Modify parameter
    void modify(MyClass& obj);
    
    // Return member
    int& getValue() { return value; }

8.2. POINTER BEST PRACTICES
----------------------------
âœ“ Khá»Ÿi táº¡o vá»›i nullptr
âœ“ Check nullptr trÆ°á»›c dereference
âœ“ GÃ¡n nullptr sau delete
âœ“ new â†’ delete, new[] â†’ delete[]

PATTERN:
    int* ptr = nullptr;
    ptr = new int(10);
    if (ptr != nullptr) {
        *ptr = 20;
    }
    delete ptr;
    ptr = nullptr;

8.3. SIZEOF TIPS
----------------
âœ“ sizeof khÃ´ng cÃ³ side effects
âœ“ sizeof(array) â‰  sizeof(pointer)
âœ“ sizeof hoáº¡t Ä‘á»™ng compile-time

CÃ”NG THá»¨C:
    // Array length
    int len = sizeof(arr) / sizeof(arr[0]);
    
    // Pointer size (architecture dependent)
    sizeof(void*) = 4 (32-bit) or 8 (64-bit)

8.4. DEFAULT PARAMETERS TIPS
-----------------------------
âœ“ Default parameters á»Ÿ cuá»‘i
âœ“ Chá»‰ khai bÃ¡o trong declaration
âŒ TrÃ¡nh dÃ¹ng vá»›i overloading

PATTERN:
    // In header file
    void func(int x, int y = 10, int z = 5);
    
    // In source file
    void func(int x, int y, int z) {
        // Implementation
    }

8.5. PASS BY CHECKLIST
----------------------
â–¡ Function thay Ä‘á»•i argument? â†’ Reference/Pointer
â–¡ Function chá»‰ Ä‘á»c? â†’ Const reference
â–¡ Argument nhá» (int, char)? â†’ By value
â–¡ Argument lá»›n (class, struct)? â†’ Reference
â–¡ Cáº§n nullptr? â†’ Pointer
â–¡ Muá»‘n syntax Ä‘Æ¡n giáº£n? â†’ Reference

8.6. QUICK REFERENCE TABLE
---------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SCENARIO       â”‚ RECOMMENDED  â”‚ REASON        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Read only      â”‚ const T&     â”‚ No copy, safe â”‚
â”‚ Modify         â”‚ T&           â”‚ Direct access â”‚
â”‚ Small type     â”‚ T            â”‚ Simple        â”‚
â”‚ Large type     â”‚ const T&     â”‚ Efficient     â”‚
â”‚ Optional       â”‚ T*           â”‚ Can be null   â”‚
â”‚ Array          â”‚ T*           â”‚ Decay to ptr  â”‚
â”‚ Return member  â”‚ T&           â”‚ Direct access â”‚
â”‚ Return local   â”‚ T            â”‚ Avoid danglingâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8.7. COMMON PATTERNS
--------------------

PATTERN 1: Swap using reference
    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }

PATTERN 2: Array parameter
    void processArray(int arr[], int size) {
        for (int i = 0; i < size; i++) {
            cout << arr[i];
        }
    }

PATTERN 3: Optional parameter
    void func(int* ptr = nullptr) {
        if (ptr != nullptr) {
            *ptr = 10;
        }
    }

PATTERN 4: Getter/Setter
    class MyClass {
        int value;
    public:
        int getValue() const { return value; }
        void setValue(int v) { value = v; }
        int& getRef() { return value; }
    };

8.8. DEBUG CHECKLIST
--------------------
â–¡ Reference Ä‘Æ°á»£c khá»Ÿi táº¡o?
â–¡ Pointer Ä‘Æ°á»£c kiá»ƒm tra nullptr?
â–¡ sizeof cÃ³ side effects? (KhÃ´ng!)
â–¡ Array decay trong function?
â–¡ Default parameters Ä‘Ãºng thá»© tá»±?
â–¡ Return reference an toÃ n?
â–¡ Delete Ä‘Ãºng cÃ¡ch (delete vs delete[])?
â–¡ Memory leaks? (new cÃ³ delete?)

8.9. COMPILATION FLAGS
----------------------
    // Kiá»ƒm tra warnings
    g++ -Wall -Wextra -Werror file.cpp
    
    // Optimization
    g++ -O2 file.cpp
    
    // Debug
    g++ -g file.cpp

8.10. MEMORY MANAGEMENT PATTERN
--------------------------------
    class Resource {
        int* data;
    public:
        // Constructor
        Resource(int size) {
            data = new int[size];
        }
        
        // Destructor
        ~Resource() {
            delete[] data;
            data = nullptr;
        }
        
        // Copy constructor
        Resource(const Resource& other) {
            // Deep copy
        }
        
        // Assignment operator
        Resource& operator=(const Resource& other) {
            if (this != &other) {
                delete[] data;
                // Deep copy
            }
            return *this;
        }
    };

================================================================================
Káº¾T LUáº¬N
================================================================================

TEST 1 Táº¬P TRUNG VÃ€O:
âœ… References (30%)
âœ… Pointers (25%)
âœ… sizeof operator (20%)
âœ… Default parameters (15%)
âœ… Pass by value/reference (10%)

ÄIá»‚M THEN CHá»T Cáº¦N NHá»š:
1. Reference = alias, khÃ´ng thá»ƒ re-bind
2. Pointer = Ä‘á»‹a chá»‰, cÃ³ thá»ƒ nullptr
3. sizeof khÃ´ng cÃ³ side effects
4. Default parameters pháº£i á»Ÿ cuá»‘i
5. Pass by reference cho objects lá»›n

CÃC Lá»–I THÆ¯á»œNG Gáº¶P:
- Dangling reference/pointer
- Array decay trong function
- sizeof vá»›i side effects (nháº§m tÆ° duy)
- Delete sai cÃ¡ch (delete vs delete[])
- Default parameter order sai

LUYá»†N Táº¬P:
- Viáº¿t function swap, copy, compare
- Practice pointer arithmetic
- Debug memory issues
- Hiá»ƒu sizeof vá»›i arrays, pointers, classes

BEST PRACTICES:
- Prefer reference over pointer
- Always initialize pointers
- Check nullptr before dereference
- Use const reference for read-only
- Return by value for local variables

CHÃšC Báº N Ã”N Táº¬P Tá»T VÃ€ Äáº T ÄIá»‚M CAO! ğŸš€
