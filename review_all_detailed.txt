================================================================================
                    TÃ€I LIá»†U Ã”N Táº¬P OOP - Tá»”NG Há»¢P CHI TIáº¾T
              C++ OBJECT-ORIENTED PROGRAMMING - COMPLETE GUIDE
================================================================================

                        TOÃ€N Bá»˜ KIáº¾N THá»¨C OOP C++ - PHIÃŠN Báº¢N Äáº¦Y Äá»¦
              Tá»•ng há»£p chi tiáº¿t tá»« Test 1, Test 2, Giá»¯a KÃ¬, vÃ  Test 3
              
              Format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ VÃ­ dá»¥ code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p

================================================================================

â­ LÆ¯U Ã KHI Äá»ŒC TÃ€I LIá»†U NÃ€Y:
- Má»—i section cÃ³: KhÃ¡i niá»‡m cÆ¡ báº£n â†’ LÆ°u Ã½ quan trá»ng â†’ VÃ­ dá»¥ tá»« code test
- Code examples Ä‘Æ°á»£c láº¥y tá»« cÃ¡c file test thá»±c táº¿
- PhÃ¢n tÃ­ch chi tiáº¿t output vÃ  cÃ¡ch hoáº¡t Ä‘á»™ng
- Lá»—i thÆ°á»ng gáº·p Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u âŒ
- Best practices Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u âœ“

================================================================================

Má»¤C Lá»¤C CHI TIáº¾T
================

ğŸ“š PHáº¦N I: C++ FUNDAMENTALS (Test 1)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1. REFERENCES (THAM CHIáº¾U)
       1.1. KhÃ¡i niá»‡m cÆ¡ báº£n & Syntax
       1.2. Reference binding & LÆ°u Ã½
       1.3. VÃ­ dá»¥ code thá»±c táº¿ (Test1/on_1.cpp)
       1.4. Const reference
       1.5. Dangling reference - Lá»—i nguy hiá»ƒm
       
    2. POINTERS (CON TRá»)
       2.1. KhÃ¡i niá»‡m & ToÃ¡n tá»­ *, &
       2.2. Null pointer
       2.3. Pointer arithmetic
       2.4. Reference vs Pointer - So sÃ¡nh chi tiáº¿t
       
    3. SIZEOF OPERATOR â­ QUAN TRá»ŒNG
       3.1. KhÃ¡i niá»‡m cÆ¡ báº£n
       3.2. sizeof KHÃ”NG cÃ³ side effects (Test1/on_44.cpp)
       3.3. sizeof vá»›i array
       3.4. Array decay - Lá»—i cá»±c ká»³ thÆ°á»ng gáº·p
       3.5. sizeof vá»›i pointer
       3.6. sizeof vá»›i class/struct (padding)
       
    4. DEFAULT PARAMETERS
       4.1. KhÃ¡i niá»‡m & CÃº phÃ¡p
       4.2. Quy táº¯c vÃ ng: Default pháº£i á»Ÿ cuá»‘i
       4.3. Ambiguity vá»›i function overloading (Test2/on_1.cpp)
       
    5. PASS BY VALUE/REFERENCE/POINTER
       5.1. Pass by value
       5.2. Pass by reference
       5.3. Pass by pointer
       5.4. Báº£ng quyáº¿t Ä‘á»‹nh khi nÃ o dÃ¹ng cÃ¡i gÃ¬
       
    6. TYPE CONVERSION
       6.1. Implicit conversion
       6.2. Type promotion hierarchy
       6.3. Explicit cast

ğŸ“š PHáº¦N II: OPERATOR OVERLOADING (Test 2)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    7. OPERATOR OVERLOADING CÆ  Báº¢N
       7.1. KhÃ¡i niá»‡m & Má»¥c Ä‘Ã­ch
       7.2. Member function syntax
       7.3. Friend function syntax
       7.4. Khi nÃ o dÃ¹ng member, khi nÃ o dÃ¹ng friend
       
    8. ARITHMETIC OPERATORS (+, -, *, /)
       8.1. KhÃ¡i niá»‡m & Return type
       8.2. VÃ­ dá»¥ code (Test2/on_15.cpp, on_18.cpp)
       8.3. operator+ return by value
       8.4. Lá»—i thÆ°á»ng gáº·p: Return type sai
       
    9. COMPOUND ASSIGNMENT (+=, -=, *=, /=)
       9.1. KhÃ¡i niá»‡m & Return reference
       9.2. Cho phÃ©p chain: a += b += c
       9.3. Implement operator+ báº±ng operator+=
       
    10. STREAM OPERATORS (<<, >>)
        10.1. Táº¡i sao PHáº¢I lÃ  friend function
        10.2. VÃ­ dá»¥ code chi tiáº¿t (Test2/on_18.cpp)
        10.3. Return stream& Ä‘á»ƒ chain
        10.4. Lá»—i: LÃ m member function
        
    11. COMPARISON OPERATORS (==, !=, <, >, <=, >=)
        11.1. Implement == vÃ  <
        11.2. Derive cÃ¡c toÃ¡n tá»­ khÃ¡c
        11.3. const-correctness
        
    12. SUBSCRIPT OPERATOR ([])
        12.1. PHáº¢I lÃ  member function
        12.2. Return reference Ä‘á»ƒ gÃ¡n Ä‘Æ°á»£c (Test2/on_24.cpp)
        12.3. 2 versions: const vÃ  non-const
        12.4. Bounds checking
        
    13. FUNCTION CALL OPERATOR (())
        13.1. Functors - Function objects (Test2/on_3.cpp)
        13.2. á»¨ng dá»¥ng trong STL
        
    14. ASSIGNMENT OPERATOR (=)
        14.1. PHáº¢I lÃ  member function
        14.2. Self-assignment check (Test2/on_8.cpp)
        14.3. Return *this
        14.4. Deep copy
        
    15. SPECIAL OPERATORS
        15.1. new & delete overloading (Test2/on_13.cpp)
        15.2. Type conversion operators (Test2/on_26.cpp)
        15.3. Comma operator (Test2/on_5.cpp)
        
    16. FUNCTION OVERLOADING
        16.1. Overload resolution
        16.2. Ambiguity vá»›i default parameters (Test2/on_1.cpp)
        16.3. Type promotion trong overloading
        
    17. CONST-CORRECTNESS â­ Cá»°C Ká»² QUAN TRá»ŒNG
        17.1. Const member function
        17.2. Const parameters
        17.3. Const return type
        17.4. Checklist

ğŸ“š PHáº¦N III: INHERITANCE & POLYMORPHISM (Giá»¯a KÃ¬ + Test 3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    18. Káº¾ THá»ªA ÄÆ N (SINGLE INHERITANCE)
        18.1. KhÃ¡i niá»‡m IS-A relationship
        18.2. Public/Protected/Private inheritance
        18.3. VÃ­ dá»¥ code chi tiáº¿t (Gki/test.cpp)
        
    19. CONSTRUCTOR & DESTRUCTOR ORDER â­ THEN CHá»T
        19.1. Quy táº¯c vÃ ng: Cha â†’ Con, ~Con â†’ ~Cha
        19.2. VÃ­ dá»¥ code (Test3/on_2.cpp, on_23.cpp)
        19.3. PhÃ¢n tÃ­ch chi tiáº¿t tá»«ng bÆ°á»›c
        19.4. Multiple inheritance order
        
    20. INITIALIZER LIST
        20.1. KhÃ¡i niá»‡m & Syntax
        20.2. Gá»i base constructor (Test3/on_5.cpp)
        20.3. Lá»—i: KhÃ´ng gá»i base constructor
        20.4. Thá»© tá»± khá»Ÿi táº¡o
        
    21. NAME HIDING & FUNCTION HIDING
        21.1. Name hiding trong inheritance (Test3/on_9.cpp)
        21.2. Function hiding (Test3/on_41.cpp)
        21.3. using directive Ä‘á»ƒ expose
        
    22. VIRTUAL DESTRUCTOR â­ Cá»°C Ká»² QUAN TRá»ŒNG
        22.1. Táº¡i sao cáº§n virtual destructor
        22.2. Memory leak khi khÃ´ng cÃ³ virtual
        22.3. VÃ­ dá»¥ code (Gki/test3.cpp)
        22.4. Quy táº¯c: Base class â†’ virtual destructor
        
    23. VIRTUAL FUNCTIONS
        23.1. KhÃ¡i niá»‡m dynamic binding
        23.2. Override keyword
        23.3. Virtual function table (vtable)
        23.4. VÃ­ dá»¥ code (Gki/test4.cpp)
        
    24. PURE VIRTUAL & ABSTRACT CLASSES
        24.1. Pure virtual function (= 0)
        24.2. Abstract class - KhÃ´ng thá»ƒ instantiate
        24.3. Interface pattern
        24.4. Concrete class implementation
        
    25. POLYMORPHISM
        25.1. Compile-time polymorphism (static)
        25.2. Runtime polymorphism (dynamic)
        25.3. Upcasting (an toÃ n)
        25.4. Downcasting (dynamic_cast)
        
    26. SLICING PROBLEM â­ Lá»–I THÆ¯á»œNG Gáº¶P
        26.1. KhÃ¡i niá»‡m slicing
        26.2. VÃ­ dá»¥ code minh há»a
        26.3. Giáº£i phÃ¡p: Pass by reference/pointer
        
    27. ÄA Káº¾ THá»ªA (MULTIPLE INHERITANCE)
        27.1. KhÃ¡i niá»‡m & Syntax
        27.2. Constructor/Destructor order
        27.3. Diamond problem
        27.4. Virtual inheritance
        
    28. OPERATOR OVERLOADING Vá»šI INHERITANCE
        28.1. Káº¿ thá»«a operators
        28.2. Override operators cho derived class
        28.3. Gá»i base class operator
        28.4. Stream operators vá»›i inheritance

ğŸ“š PHáº¦N IV: ADVANCED CONCEPTS (Test 3)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    29. TEMPLATES (FUNCTION & CLASS)
        29.1. Function templates
        29.2. Class templates
        29.3. Template specialization
        29.4. Non-type template parameters
        29.5. Variadic templates
        
    30. EXCEPTION HANDLING
        30.1. try-catch-throw
        30.2. Exception hierarchy
        30.3. noexcept
        30.4. Rethrow
        30.5. RAII pattern
        
    31. COPY CONTROL â­ RULE OF THREE/FIVE/ZERO
        31.1. Rule of Three
        31.2. Deep copy vs Shallow copy
        31.3. Copy constructor (Test2/on_8.cpp)
        31.4. Copy assignment operator
        31.5. Rule of Five (C++11)
        31.6. Move semantics
        31.7. Copy-and-swap idiom
        
    32. STATIC MEMBERS
        32.1. Static data members
        32.2. Static member functions
        32.3. Static local variables
        32.4. Static vá»›i inheritance
        
    33. FRIEND FUNCTIONS & CLASSES
        33.1. Friend function
        33.2. Friend class
        33.3. Khi nÃ o dÃ¹ng friend
        
    34. DESIGN PATTERNS
        34.1. Singleton
        34.2. Factory
        34.3. Observer
        34.4. Strategy

ğŸ“š PHáº¦N V: Tá»”NG Há»¢P & THá»°C HÃ€NH
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    35. CÃC Lá»–I THÆ¯á»œNG Gáº¶P (TOP 20)
    36. BEST PRACTICES
    37. CHECKLIST Tá»”NG Há»¢P
    38. DEBUGGING TECHNIQUES
    39. PERFORMANCE TIPS
    40. COMPILATION & TOOLS

================================================================================
                         PHáº¦N I: C++ FUNDAMENTALS
================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 1: REFERENCES (THAM CHIáº¾U)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Reference (tham chiáº¿u) lÃ  má»™t ALIAS (bÃ­ danh) cho má»™t biáº¿n Ä‘Ã£ tá»“n táº¡i.
NÃ³ KHÃ”NG pháº£i lÃ  má»™t object má»›i, mÃ  chá»‰ lÃ  "tÃªn khÃ¡c" cá»§a biáº¿n gá»‘c.

CÃš PHÃP:
    int x = 10;
    int& ref = x;  // ref lÃ  bÃ­ danh cá»§a x
    
    ref = 20;      // Thay Ä‘á»•i ref = thay Ä‘á»•i x
    cout << x;     // 20

HÃŒNH DUNG:
    Biáº¿n gá»‘c: [x: 10] â† Äá»‹a chá»‰ 0x1000
    Reference: [ref] â†’ CÅ©ng trá» Ä‘áº¿n 0x1000
    
    Khi thay Ä‘á»•i ref â†’ Thay Ä‘á»•i trá»±c tiáº¿p x

Äáº¶C ÄIá»‚M QUAN TRá»ŒNG:
âœ“ PHáº¢I khá»Ÿi táº¡o ngay khi khai bÃ¡o
  int& ref;  // âŒ ERROR! Pháº£i khá»Ÿi táº¡o
  
âœ“ KHÃ”NG THá»‚ thay Ä‘á»•i target (re-bind) sau khi khá»Ÿi táº¡o
  int x = 10, y = 20;
  int& ref = x;
  ref = y;  // GÃ¡n giÃ¡ trá»‹ y cho x, KHÃ”NG pháº£i ref trá» sang y
  
âœ“ KHÃ”NG cÃ³ null reference
  int& ref = nullptr;  // âŒ ERROR!
  
âœ“ KHÃ”NG chiáº¿m thÃªm memory (compiler optimization)
  sizeof(ref) == sizeof(int), khÃ´ng cÃ³ overhead

1.2. VÃ Dá»¤ CODE THá»°C Táº¾
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ Tá»ª TEST (Test1/on_1.cpp):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
using namespace std;

int main(){
    int var_x = 2, var_y = 6;
    int& ref_x = var_x;  // ref_x lÃ  alias cá»§a var_x
    int& ref_y = var_y;  // ref_y lÃ  alias cá»§a var_y

    // Test 1: TÄƒng biáº¿n gá»‘c
    var_x++;
    cout << var_x << " " << ref_x << endl;  // 3 3
    
    // Test 2: TÄƒng reference
    ref_x++;
    cout << var_x << " " << ref_x << endl;  // 4 4
    
    // Test 3: PhÃ©p gÃ¡n phá»©c táº¡p
    var_x = ref_x++; 
    cout << var_x << " " << ref_x << endl;  // 4 4
    
    return 0;
}
```

PHÃ‚N TÃCH CHI TIáº¾T:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ban Ä‘áº§u:
    var_x = 2, ref_x â†’ var_x

Test 1: var_x++
    var_x = 3, ref_x = 3 (cÃ¹ng biáº¿n)
    Output: 3 3 âœ“

Test 2: ref_x++
    ref_x tÄƒng = var_x tÄƒng
    var_x = 4, ref_x = 4
    Output: 4 4 âœ“

Test 3: var_x = ref_x++
    PhÃ©p gÃ¡n cÃ³ thá»© tá»±:
    1. TÃ­nh ref_x++ (postfix)
       - Tráº£ vá» giÃ¡ trá»‹ CÅ¨: 4
       - TÄƒng sau: ref_x = 5 (var_x = 5)
    2. GÃ¡n: var_x = 4
    
    Káº¿t quáº£:
    - var_x = 4 (giÃ¡ trá»‹ cÅ© cá»§a ref_x)
    - ref_x = var_x = 4 (vÃ¬ ref_x lÃ  alias cá»§a var_x)
    
    â“ Táº¡i sao khÃ´ng pháº£i 4 5?
    â†’ VÃ¬ sau khi ref_x++ (ref_x/var_x = 5)
    â†’ var_x = 4 gÃ¡n láº¡i, ghi Ä‘Ã¨ lÃªn giÃ¡ trá»‹ 5
    â†’ Cáº£ var_x vÃ  ref_x Ä‘á»u = 4
    
    Output: 4 4 âœ“ (KHÃ”NG pháº£i 4 5!)

LÆ¯U Ã QUAN TRá»ŒNG:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reference KHÃ”NG THá»‚ re-bind (Ä‘á»•i target):
    int x = 10, y = 20;
    int& ref = x;  // ref â†’ x
    ref = y;       // GÃN GIÃ TRá»Š y cho x, KHÃ”NG pháº£i ref â†’ y
    
    cout << x;     // 20 (x Ä‘Ã£ Ä‘á»•i)
    cout << ref;   // 20 (ref váº«n â†’ x)

1.3. CONST REFERENCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Const reference cho phÃ©p truy cáº­p biáº¿n mÃ  KHÃ”NG thay Ä‘á»•i giÃ¡ trá»‹.

CÃš PHÃP:
    void print(const int& x) {
        cout << x;      // âœ“ OK: Ä‘á»c Ä‘Æ°á»£c
        // x = 10;      // âŒ ERROR: khÃ´ng thá»ƒ thay Ä‘á»•i
    }

VÃ Dá»¤ Vá»šI CLASS:
    class BigData {
        int data[10000];
    public:
        // ...
    };
    
    // âŒ SAI: Pass by value â†’ Copy 10000 pháº§n tá»­!
    void process(BigData obj) {
        cout << obj.data[0];
    }
    
    // âœ“ ÄÃšNG: Pass by const reference â†’ KhÃ´ng copy, khÃ´ng Ä‘á»•i
    void process(const BigData& obj) {
        cout << obj.data[0];  // âœ“ Äá»c OK
        // obj.data[0] = 5;   // âŒ ERROR: const
    }

Æ¯U ÄIá»‚M:
âœ“ KHÃ”NG copy â†’ Efficient (tiáº¿t kiá»‡m memory & time)
âœ“ KHÃ”NG thay Ä‘á»•i â†’ Safe (clear intent)
âœ“ CÃ“ THá»‚ nháº­n temporary/rvalue
âœ“ Self-documenting code (rÃµ Ã½ nghÄ©a)

VÃ Dá»¤ NHáº¬N TEMPORARY:
    void print(const int& x) {
        cout << x;
    }
    
    int val = 5;
    print(val);      // âœ“ OK: Bind vá»›i lvalue
    print(10);       // âœ“ OK: Bind vá»›i rvalue (temporary)
    print(3 + 4);    // âœ“ OK: Bind vá»›i expression result
    
    // Non-const reference khÃ´ng bind Ä‘Æ°á»£c rvalue:
    void modify(int& x) {
        x++;
    }
    
    modify(10);      // âŒ ERROR: Cannot bind rvalue to non-const reference

BEST PRACTICE:
â•â•â•â•â•â•â•â•â•â•â•â•â•
â†’ DÃ¹ng const reference cho parameters lá»›n chá»‰ Ä‘á»c
â†’ DÃ¹ng reference cho parameters cáº§n modify
â†’ DÃ¹ng value cho small types (int, char, bool)

Quy táº¯c ngÃ³n tay cÃ¡i:
    sizeof(type) <= sizeof(pointer) â†’ Pass by value
    sizeof(type) > sizeof(pointer)  â†’ Pass by const reference

1.4. DANGLING REFERENCE - Lá»–I NGUY HIá»‚M
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Dangling reference xáº£y ra khi reference trá» Ä‘áº¿n biáº¿n Ä‘Ã£ bá»‹ há»§y.

âŒ Lá»–I Cá»°C Ká»² NGUY HIá»‚M:
    int& getReference() {
        int x = 10;        // Local variable
        return x;          // âŒ NGUY HIá»‚M! x bá»‹ há»§y sau khi return
    }
    
    int main() {
        int& ref = getReference();
        cout << ref;       // âš ï¸ UNDEFINED BEHAVIOR!
        // ref trá» Ä‘áº¿n memory Ä‘Ã£ bá»‹ deallocate
    }

Táº I SAO NGUY HIá»‚M?
- Local variable x tá»“n táº¡i trÃªn stack
- Khi function return, stack frame bá»‹ há»§y
- x khÃ´ng cÃ²n tá»“n táº¡i
- ref trá» Ä‘áº¿n "vÃ¹ng rÃ¡c" (garbage memory)
- Má»i thao tÃ¡c vá»›i ref â†’ Crash hoáº·c behavior khÃ´ng xÃ¡c Ä‘á»‹nh

HÃŒNH DUNG:
    Stack trÆ°á»›c return:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ getReference()   â”‚
    â”‚   x = 10   â†â”€â”€â”€â”€â”€â”¼â”€ ref trá» Ä‘áº¿n Ä‘Ã¢y
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Stack sau return:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ main()           â”‚
    â”‚   ref â”€â”€â†’  ???   â”‚â† Trá» Ä‘áº¿n vÃ¹ng Ä‘Ã£ bá»‹ deallocate
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

QUY Táº®C AN TOÃ€N:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âŒ KHÃ”NG return reference Ä‘áº¿n:
   - Local variable
   - Temporary object
   - Deleted memory
   - Parameter passed by value

âœ“ CÃ“ THá»‚ return reference Ä‘áº¿n:
   - Static variable
   - Global variable
   - Member variable (náº¿u object tá»“n táº¡i)
   - Parameter passed by reference (náº¿u cháº¯c tá»“n táº¡i)

VÃ Dá»¤ AN TOÃ€N:
```cpp
// âœ“ Static variable - OK
int& getStatic() {
    static int x = 10;  // Static â†’ tá»“n táº¡i sau return
    return x;
}

// âœ“ Member variable - OK
class MyClass {
    int value;
public:
    int& getValue() {
        return value;  // OK: value tá»“n táº¡i trong object
    }
};

// âœ“ Parameter reference - OK
int& max(int& a, int& b) {
    return (a > b) ? a : b;  // OK: a, b tá»“n táº¡i ngoÃ i function
}

int main() {
    int x = 10, y = 20;
    int& larger = max(x, y);  // OK: trá» Ä‘áº¿n y
    larger = 30;              // y = 30
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 2: POINTERS (CON TRá»)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

2.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
Pointer (con trá») lÃ  biáº¿n lÆ°u trá»¯ Äá»ŠA CHá»ˆ cá»§a biáº¿n khÃ¡c.

CÃš PHÃP:
    int x = 10;
    int* ptr = &x;  // ptr lÆ°u Ä‘á»‹a chá»‰ cá»§a x
    
    cout << ptr;    // In Ä‘á»‹a chá»‰ (VD: 0x7ffd5b2c3e4c)
    cout << *ptr;   // In giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰: 10
    
    *ptr = 20;      // Thay Ä‘á»•i giÃ¡ trá»‹ x qua pointer
    cout << x;      // 20

TOÃN Tá»¬:
- & : Address-of operator (láº¥y Ä‘á»‹a chá»‰)
- * : Dereference operator (láº¥y giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰)

HÃŒNH DUNG:
    Memory:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Address     â”‚ Value    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ 0x1000      â”‚ 10       â”‚ â† x
    â”‚ 0x2000      â”‚ 0x1000   â”‚ â† ptr (lÆ°u Ä‘á»‹a chá»‰ cá»§a x)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    &x = 0x1000    (Ä‘á»‹a chá»‰ cá»§a x)
    ptr = 0x1000   (giÃ¡ trá»‹ cá»§a ptr)
    *ptr = 10      (giÃ¡ trá»‹ táº¡i Ä‘á»‹a chá»‰ ptr trá» tá»›i)

Äáº¶C ÄIá»‚M QUAN TRá»ŒNG:
âœ“ CÃ³ thá»ƒ nullptr (trá» Ä‘áº¿n "khÃ´ng Ä‘Ã¢u")
âœ“ CÃ³ thá»ƒ thay Ä‘á»•i target (trá» sang biáº¿n khÃ¡c)
âœ“ CÃ³ pointer arithmetic (ptr++, ptr+n)
âœ“ Chiáº¿m memory:
  - 4 bytes trÃªn há»‡ thá»‘ng 32-bit
  - 8 bytes trÃªn há»‡ thá»‘ng 64-bit

2.2. NULL POINTER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

NULL POINTER: Pointer khÃ´ng trá» Ä‘áº¿n Ä‘Ã¢u cáº£.

CÃC CÃCH KHAI BÃO:
    int* ptr = nullptr;  // âœ“ C++11 - KhuyÃªn dÃ¹ng
    int* ptr2 = NULL;    // C-style (macro = 0)
    int* ptr3 = 0;       // Old style
    
    if (ptr == nullptr) {
        cout << "Null pointer";
    }

Táº I SAO Cáº¦N nullptr?
- TrÃ¡nh dereference pointer khÃ´ng há»£p lá»‡ â†’ Crash
- Kiá»ƒm tra trÆ°á»›c khi dÃ¹ng
- GÃ¡n nullptr sau delete

âŒ Lá»–I THÆ¯á»œNG Gáº¶P:
```cpp
int* ptr = nullptr;
*ptr = 10;  // âŒ CRASH! Dereference null pointer
```

âœ“ ÄÃšNG:
```cpp
int* ptr = nullptr;
if (ptr != nullptr) {
    *ptr = 10;  // âœ“ An toÃ n
}
```

2.3. POINTER ARITHMETIC
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Pointer cÃ³ thá»ƒ cá»™ng/trá»« Ä‘á»ƒ truy cáº­p cÃ¡c pháº§n tá»­ káº¿ tiáº¿p.

VÃ Dá»¤:
    int arr[5] = {10, 20, 30, 40, 50};
    int* ptr = arr;  // ptr trá» Ä‘áº¿n arr[0]
    
    cout << *ptr;       // 10 (arr[0])
    cout << *(ptr+1);   // 20 (arr[1])
    cout << *(ptr+2);   // 30 (arr[2])
    cout << ptr[2];     // 30 (tÆ°Æ¡ng Ä‘Æ°Æ¡ng *(ptr+2))
    
    ptr++;              // ptr giá» trá» Ä‘áº¿n arr[1]
    cout << *ptr;       // 20

QUY Táº®C:
- ptr + n â†’ Nháº£y n pháº§n tá»­ (n * sizeof(type))
- ptr++ â†’ Nháº£y 1 pháº§n tá»­
- ptr - ptr2 â†’ Sá»‘ pháº§n tá»­ giá»¯a 2 con trá»

HÃŒNH DUNG:
    Array: [10][20][30][40][50]
            â†‘   â†‘   â†‘   â†‘   â†‘
    Addr:  100 104 108 112 116  (giáº£ sá»­ sizeof(int) = 4)
    
    ptr = 100
    ptr + 1 = 104 (khÃ´ng pháº£i 101!)
    ptr + 2 = 108
    
    Compiler tá»± Ä‘á»™ng nhÃ¢n vá»›i sizeof(type)

VÃ Dá»¤ Vá»šI CHAR:
    char str[] = "Hello";
    char* p = str;
    
    p + 1 â†’ Nháº£y 1 byte (sizeof(char) = 1)
    
    str: ['H']['e']['l']['l']['o']['\0']
          â†‘   â†‘
         100 101

VÃ Dá»¤ Vá»šI DOUBLE:
    double arr[3] = {1.1, 2.2, 3.3};
    double* p = arr;
    
    p + 1 â†’ Nháº£y 8 bytes (sizeof(double) = 8)
    
    arr: [1.1  ][2.2  ][3.3  ]
          â†‘     â†‘
         100   108

2.4. REFERENCE VS POINTER - SO SÃNH CHI TIáº¾T
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Báº¢NG SO SÃNH TOÃ€N DIá»†N:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Äáº¶C ÄIá»‚M             â”‚ REFERENCE            â”‚ POINTER                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Khá»Ÿi táº¡o             â”‚ Báº®T BUá»˜C ngay        â”‚ KhÃ´ng báº¯t buá»™c         â”‚
â”‚ Null                 â”‚ KHÃ”NG THá»‚            â”‚ CÃ³ thá»ƒ (nullptr)       â”‚
â”‚ Re-assign (Ä‘á»•i má»¥c)  â”‚ KHÃ”NG THá»‚            â”‚ CÃ³ thá»ƒ                 â”‚
â”‚ Syntax truy cáº­p      â”‚ ÄÆ¡n giáº£n (.)         â”‚ Phá»©c táº¡p (*, ->)       â”‚
â”‚ Memory overhead      â”‚ KhÃ´ng (optimized)    â”‚ CÃ³ (4/8 bytes)         â”‚
â”‚ Safety               â”‚ An toÃ n hÆ¡n          â”‚ Dá»… lá»—i hÆ¡n             â”‚
â”‚ Arithmetic           â”‚ KhÃ´ng cÃ³             â”‚ CÃ³ (ptr++, ptr+n)      â”‚
â”‚ Levels of indirectionâ”‚ 1 level              â”‚ Multiple (**, ***)     â”‚
â”‚ Use case chÃ­nh       â”‚ Function parameters  â”‚ Dynamic allocation     â”‚
â”‚ CÃ³ thá»ƒ lÃ  member     â”‚ CÃ³ (cáº©n tháº­n)        â”‚ CÃ³                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VÃ Dá»¤ SO SÃNH TRá»°C TIáº¾P:
```cpp
int x = 10;

// â•â•â• REFERENCE â•â•â•
int& ref = x;    // Pháº£i khá»Ÿi táº¡o ngay
ref = 20;        // x = 20

int y = 40;
ref = y;         // x = 40 (GÃN GIÃ TRá»Š, KHÃ”NG Ä‘á»•i target)
cout << x;       // 40

// â•â•â• POINTER â•â•â•
int* ptr = &x;   // ptr trá» Ä‘áº¿n x
*ptr = 30;       // x = 30

ptr = &y;        // ptr GIá»œ TRá» SANG y (Äá»”I TARGET)
*ptr = 50;       // y = 50, x váº«n = 30
cout << x << " " << y;  // 30 50
```

PHÃ‚N TÃCH:
1. Reference:
   - ref = y: GÃ¡n GIÃTRá»Š cá»§a y cho x
   - ref VáºªN lÃ  alias cá»§a x
   - x = 40

2. Pointer:
   - ptr = &y: ptr Äá»”I TARGET, trá» sang y
   - *ptr = 50: Thay Ä‘á»•i y
   - x khÃ´ng Ä‘á»•i (váº«n 30)

KHI NÃ€O DÃ™NG CÃI GÃŒ?
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ“ DÃ¹ng REFERENCE khi:
  - Function parameters (read/write)
  - Return tá»« function (member variable)
  - KhÃ´ng cáº§n null
  - KhÃ´ng cáº§n Ä‘á»•i target
  - Muá»‘n syntax Ä‘Æ¡n giáº£n

âœ“ DÃ¹ng POINTER khi:
  - Dynamic memory allocation (new/delete)
  - Cáº§n nullptr (optional parameter)
  - Cáº§n Ä‘á»•i target
  - Array/Data structures
  - C-style APIs

VÃ Dá»¤ THá»°C Táº¾:
```cpp
// Reference: Function parameter
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// Pointer: Dynamic allocation
int* arr = new int[100];
// ... use arr
delete[] arr;

// Pointer: Optional parameter
void process(int* optional = nullptr) {
    if (optional != nullptr) {
        cout << *optional;
    }
}

// Reference: Return member
class MyClass {
    int value;
public:
    int& getValue() { return value; }
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHAPTER 3: SIZEOF OPERATOR â­ Cá»°C Ká»² QUAN TRá»ŒNG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

3.1. KHÃI NIá»†M CÆ  Báº¢N
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Äá»ŠNH NGHÄ¨A:
sizeof lÃ  operator tráº£ vá» kÃ­ch thÆ°á»›c (sá»‘ bytes) cá»§a type hoáº·c variable.

CÃš PHÃP:
    sizeof(type)
    sizeof(variable)
    sizeof variable  // KhÃ´ng cáº§n () vá»›i variable

VÃ Dá»¤ CÆ  Báº¢N:
    cout << sizeof(int);      // 4 (bytes)
    cout << sizeof(char);     // 1
    cout << sizeof(double);   // 8
    cout << sizeof(float);    // 4
    cout << sizeof(long);     // 4 (32-bit) hoáº·c 8 (64-bit)
    cout << sizeof(short);    // 2
    cout << sizeof(bool);     // 1
    
    int x = 10;
    cout << sizeof(x);        // 4
    cout << sizeof x;         // 4 (khÃ´ng cáº§n ())

Äáº¶C ÄIá»‚M QUAN TRá»ŒNG:
âœ“ sizeof lÃ  COMPILE-TIME operator
  - Káº¿t quáº£ Ä‘Æ°á»£c tÃ­nh khi compile
  - KHÃ”NG pháº£i runtime
  - CÃ³ thá»ƒ dÃ¹ng trong constant expressions

âœ“ Return type lÃ  size_t (unsigned integer type)

âœ“ ÄÆ¡n vá»‹: BYTES (khÃ´ng pháº£i bits)

LÆ¯U Ã PLATFORM:
- KÃ­ch thÆ°á»›c cÃ³ thá»ƒ khÃ¡c trÃªn cÃ¡c há»‡ thá»‘ng
- int: ThÆ°á»ng lÃ  4 bytes (32-bit int)
- long: 4 bytes (32-bit) hoáº·c 8 bytes (64-bit)
- pointer: 4 bytes (32-bit) hoáº·c 8 bytes (64-bit)

3.2. â­â­â­ ÄIá»‚M THEN CHá»T: sizeof KHÃ”NG CÃ“ SIDE EFFECTS â­â­â­
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ÄÃ¢y lÃ  Ä‘iá»u QUAN TRá»ŒNG NHáº¤T cáº§n nhá»› vá» sizeof!
CÃ¢u há»i hay nháº¥t trong exam!

KHÃI NIá»†M:
sizeof KHÃ”NG thá»±c thi expression, chá»‰ tÃ­nh kÃ­ch thÆ°á»›c cá»§a TYPE.

VÃ Dá»¤ Tá»ª TEST (Test1/on_44.cpp - CÃ¢u hay bá»‹ nháº§m nháº¥t):
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```cpp
#include <iostream>
#include <string>
using namespace std;

int main(){
    int x = 5;
    int y = sizeof(x++);  // sizeof KHÃ”NG THá»°C HIá»†N x++
    
    cout << x << y;  // 54
    // x = 5 (KHÃ”NG Ä‘á»•i!)
    // y = 4 (sizeof(int))
    return 0;
}
```

PHÃ‚N TÃCH Tá»ªNG BÆ¯á»šC:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ban Ä‘áº§u:
    x = 5

DÃ²ng: int y = sizeof(x++);
1. sizeof chá»‰ quan tÃ¢m TYPE cá»§a x++
2. x++ cÃ³ type lÃ  int
3. sizeof(int) = 4
4. x++ KHÃ”NG Ä‘Æ°á»£c thá»±c thi!
5. y = 4

Káº¿t quáº£ cuá»‘i:
    x = 5 (KHÃ”NG tÄƒng)
    y = 4 (kÃ­ch thÆ°á»›c int)
    Output: 54

Táº I SAO KHÃ”NG THá»°C THI?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- sizeof lÃ  compile-time operator
- Compiler chá»‰ cáº§n biáº¿t TYPE, khÃ´ng cáº§n VALUE
- Expression khÃ´ng Ä‘Æ°á»£c evaluate
- Táº¥t cáº£ side effects bá»‹ bá» qua

VÃ Dá»¤ KHÃC:
```cpp
int a = 10;
sizeof(a = 100);  // a VáºªN LÃ€ 10, khÃ´ng gÃ¡n 100
sizeof(func());   // func() KHÃ”NG Ä‘Æ°á»£c gá»i
sizeof(a++);      // a KHÃ”NG tÄƒng
sizeof(++a);      // a KHÃ”NG tÄƒng
sizeof(a = a + 5);// a KHÃ”NG Ä‘á»•i
sizeof(a *= 2);   // a KHÃ”NG Ä‘á»•i

cout << a;  // 10 (khÃ´ng Ä‘á»•i!)
```

Cáº¤U TRÃšC PHá»¨C Táº P HÆ N (Tricky question):
```cpp
int x = 5;
int y = sizeof(x = sizeof(x++));
cout << x << " " << y;  // 5 4

PHÃ‚N TÃCH:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Trong cÃ¹ng: sizeof(x++)
   - Type: int
   - Size: 4
   - x++ KHÃ”NG cháº¡y
   
2. Giá»¯a: x = sizeof(x++)
   - Type: int (type cá»§a phÃ©p gÃ¡n)
   - Value sáº½ lÃ : 4 (NHÆ¯NG KHÃ”NG GÃN!)
   - Size: 4 (sizeof(int))
   
3. NgoÃ i cÃ¹ng: sizeof(x = ...)
   - Type: int
   - Size: 4
   - PhÃ©p gÃ¡n KHÃ”NG cháº¡y
   
Káº¿t quáº£: x = 5 (khÃ´ng Ä‘á»•i), y = 4
```

LÆ¯U Ã Vá»šI FUNCTION CALL:
```cpp
int func() {
    cout << "Called!";
    return 10;
}

int main() {
    sizeof(func());  // func() KHÃ”NG Ä‘Æ°á»£c gá»i
                     // "Called!" KHÃ”NG in ra
                     // Chá»‰ biáº¿t return type lÃ  int
                     // sizeof = 4
}
```

BÃ€I Táº¬P LUYá»†N Táº¬P:
```cpp
// CÃ¢u há»i: Output lÃ  gÃ¬?
int x = 1, y = 2, z = 3;
sizeof(x + y * z++);
cout << x << y << z;  // ?

ÄÃP ÃN: 123
- z++ KHÃ”NG cháº¡y
- x, y, z khÃ´ng Ä‘á»•i
```

QUAN TRá»ŒNG - Ghi nhá»›:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”¥ sizeof KHÃ”NG BAO GIá»œ cÃ³ side effects
ğŸ”¥ sizeof chá»‰ quan tÃ¢m TYPE, khÃ´ng quan tÃ¢m VALUE
ğŸ”¥ Má»i expression bÃªn trong sizeof KHÃ”NG Ä‘Æ°á»£c evaluate
ğŸ”¥ ÄÃ¢y lÃ  cÃ¢u há»i hay nháº¥t trong exam - Äá»«ng nháº§m!

3.3. SIZEOF Vá»šI ARRAY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sizeof vá»›i array tráº£ vá» Tá»”NG kÃ­ch thÆ°á»›c táº¥t cáº£ pháº§n tá»­.

VÃ Dá»¤ CÆ  Báº¢N:
    int arr[10];
    cout << sizeof(arr);        // 40 (10 * sizeof(int))
    cout << sizeof(arr[0]);     // 4 (sizeof(int))
    
    // CÃ´ng thá»©c tÃ­nh sá»‘ pháº§n tá»­ array (hay dÃ¹ng!)
    int length = sizeof(arr) / sizeof(arr[0]);  // 10

VÃ Dá»¤ Vá»šI CHAR ARRAY:
    char str[] = "Hello";
    cout << sizeof(str);  // 6 (5 kÃ½ tá»± + '\0')
    
    // Array layout: ['H']['e']['l']['l']['o']['\0']
    //                 0    1    2    3    4    5
    
    char str2[100] = "Hi";
    cout << sizeof(str2); // 100 (kÃ­ch thÆ°á»›c KHAI BÃO, khÃ´ng pháº£i Ä‘á»™ dÃ i string!)

VÃ Dá»¤ Vá»šI TYPES KHÃC:
    double darr[5];
    cout << sizeof(darr);  // 40 (5 * 8)
    
    char carr[20];
    cout << sizeof(carr);  // 20 (20 * 1)
    
    // Struct array
    struct Point { int x, y; };
    Point parr[3];
    cout << sizeof(parr);  // 24 (3 * 8)

CÃ”NG THá»¨C TÃNH LENGTH:
    Type arr[N];
    int length = sizeof(arr) / sizeof(arr[0]);
    
    // Hoáº·c dÃ¹ng macro (C-style)
    #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

3.4. âš ï¸ ARRAY DECAY - Lá»–I Cá»°C Ká»² THÆ¯á»œNG Gáº¶P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

KHÃI NIá»†M:
Khi truyá»n array vÃ o function, nÃ³ "decay" (chuyá»ƒn) thÃ nh POINTER.
sizeof trong function tráº£ vá» sizeof(pointer), KHÃ”NG pháº£i sizeof(array)!

âŒ Lá»–I KINH ÄIá»‚N:
```cpp
void func(int arr[]) {
    int size = sizeof(arr) / sizeof(arr[0]);  // âŒ SAI!
    cout << size;  // KhÃ´ng pháº£i 10!
}

int main() {
    int arr[10];
    cout << sizeof(arr);  // 40 (âœ“ Ä‘Ãºng - trong main)
    
    func(arr);  // arr decay thÃ nh pointer
}
```

PHÃ‚N TÃCH:
- Trong main(): sizeof(arr) = 40 (toÃ n bá»™ array)
- Trong func(): sizeof(arr) = 4 hoáº·c 8 (size cá»§a POINTER!)
- size = 4/4 = 1 hoáº·c 8/4 = 2 (SAI!)

Táº I SAO?
- Parameter int arr[] tÆ°Æ¡ng Ä‘Æ°Æ¡ng int* arr
- Compiler chuyá»ƒn array thÃ nh pointer
- sizeof(arr) = sizeof(pointer) = 4 (32-bit) hoáº·c 8 (64-bit)

HÃŒNH DUNG:
    main():
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ arr: [0][1][2]...[9]           â”‚â† sizeof = 40
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    func(arr):
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ arr: ptr â”‚â†’ points to array    â† sizeof = 4/8 (pointer)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ“ GIáº¢I PHÃP 1: Truyá»n size nhÆ° tham sá»‘
```cpp
void func(int arr[], int size) {  // size truyá»n tá»« ngoÃ i
    for (int i = 0; i < size; i++) {
        cout << arr[i];
    }
}

int main() {
    int arr[10];
    func(arr, sizeof(arr)/sizeof(arr[0]));  // TÃ­nh size trÆ°á»›c
}
```

âœ“ GIáº¢I PHÃP 2: Template (C++ modern)
```cpp
template<size_t N>
void func(int (&arr)[N]) {  // Reference to array
    cout << N;  // Biáº¿t chÃ­nh xÃ¡c size
    for (int i = 0; i < N; i++) {
        cout << arr[i];
    }
}

int main() {
    int arr[10];
    func(arr);  // N = 10 tá»± Ä‘á»™ng
}
```

âœ“ GIáº¢I PHÃP 3: std::array (C++11)
```cpp
#include <array>

void func(std::array<int, 10>& arr) {
    cout << arr.size();  // 10
    for (auto& elem : arr) {
        cout << elem;
    }
}

int main() {
    std::array<int, 10> arr;
    func(arr);
}
```

LÆ¯U Ã QUAN TRá»ŒNG:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¥ sizeof(array) trong main â‰  sizeof(array) trong function
ğŸ”¥ Array parameter = Pointer (decay)
ğŸ”¥ LuÃ´n truyá»n size khi truyá»n array vÃ o function
ğŸ”¥ Hoáº·c dÃ¹ng std::array, std::vector (modern C++)

3.5. SIZEOF Vá»šI POINTER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sizeof(pointer) tráº£ vá» kÃ­ch thÆ°á»›c CON TRá», khÃ´ng pháº£i data nÃ³ trá» tá»›i.

VÃ Dá»¤ CÆ  Báº¢N:
    int x = 10;
    int* ptr = &x;
    
    cout << sizeof(ptr);   // 4 (32-bit) hoáº·c 8 (64-bit)
    cout << sizeof(*ptr);  // 4 (sizeof(int))

PHÃ‚N BIá»†T:
    int arr[100];
    cout << sizeof(arr);   // 400 - size cá»§a ARRAY
    
    int* ptr = arr;
    cout << sizeof(ptr);   // 4/8 - size cá»§a POINTER

VÃ Dá»¤ Vá»šI TYPES KHÃC:
    char* p1;
    int* p2;
    double* p3;
    void* p4;
    MyClass* p5;
    
    // Táº¤T Cáº¢ Ä‘á»u cÃ³ size giá»‘ng nhau!
    cout << sizeof(p1);  // 4 hoáº·c 8
    cout << sizeof(p2);  // 4 hoáº·c 8
    cout << sizeof(p3);  // 4 hoáº·c 8
    cout << sizeof(p4);  // 4 hoáº·c 8
    cout << sizeof(p5);  // 4 hoáº·c 8

Táº I SAO?
- Pointer chá»‰ lÆ°u Ä‘á»‹a chá»‰
- Táº¥t cáº£ Ä‘á»‹a chá»‰ Ä‘á»u cÃ³ cÃ¹ng kÃ­ch thÆ°á»›c
- 32-bit system: Ä‘á»‹a chá»‰ 4 bytes
- 64-bit system: Ä‘á»‹a chá»‰ 8 bytes

POINTER VS DEREFERENCE:
    int* ptr = new int[1000];
    
    sizeof(ptr)   // 4/8 - size cá»§a pointer
    sizeof(*ptr)  // 4 - size cá»§a int (1 pháº§n tá»­)
    
    // âŒ KhÃ´ng cÃ³ cÃ¡ch nÃ o biáº¿t size cá»§a toÃ n bá»™ array qua pointer!
    // Pháº£i tá»± nhá»› size khi allocate

DYNAMIC ALLOCATION:
    int* arr = new int[100];
    
    // âŒ sizeof(arr) = 4/8 (pointer)
    // âŒ KHÃ”NG THá»‚ dÃ¹ng sizeof Ä‘á»ƒ biáº¿t Ä‘Ã£ allocate bao nhiÃªu
    // âœ“ Pháº£i tá»± lÆ°u size: int size = 100;
    
    delete[] arr;

3.6. SIZEOF Vá»šI CLASS/STRUCT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

sizeof(class) bao gá»“m táº¥t cáº£ members VÃ€ padding/alignment.

VÃ Dá»¤ ÄÆ N GIáº¢N:
    class Simple {
        int x;      // 4 bytes
        double y;   // 8 bytes
    };
    
    cout << sizeof(Simple);  // 16 (khÃ´ng pháº£i 12!)

Táº I SAO 16 CHá»¨ KHÃ”NG PHáº¢I 12?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Compiler thÃªm PADDING Ä‘á»ƒ alignment (cÄƒn chá»‰nh Ä‘á»‹a chá»‰).

MEMORY LAYOUT:
    Offset:  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
            â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
            â”‚    int x    â”‚ padding â”‚       double y        â”‚
            â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
    Bytes:   4 bytes       4 bytes    8 bytes

Táº I SAO Cáº¦N PADDING?
- double cáº§n align á»Ÿ Ä‘á»‹a chá»‰ chia háº¿t cho 8
- int chiáº¿m 0-3, double pháº£i báº¯t Ä‘áº§u tá»« 8
- Byte 4-7 lÃ  padding

VÃ Dá»¤ Vá»šI PADDING:
```cpp
class Example1 {
    char c;   // 1 byte
    int i;    // 4 bytes
};

sizeof(Example1) = 8 (khÃ´ng pháº£i 5!)

Memory layout:
â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚c â”‚ padding â”‚   int i   â”‚
â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
 1     3         4

class Example2 {
    char c1;  // 1 byte
    char c2;  // 1 byte
    int i;    // 4 bytes
};

sizeof(Example2) = 8

Memory layout:
â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚c1â”‚c2â”‚ pad â”‚   int i   â”‚
â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
 1  1   2       4
```

THá»¨ Tá»° MEMBERS áº¢NH HÆ¯á»NG SIZE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âŒ Tá»N NHIá»€U MEMORY:
```cpp
class Bad {
    char a;    // 1 byte
    int b;     // 4 bytes
    char c;    // 1 byte
    int d;     // 4 bytes
};

sizeof(Bad) = 16

Memory layout:
â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚a â”‚ padding â”‚   b   â”‚c â”‚ padding â”‚   d   â”‚ pad â”‚
â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
 1     3       4     1     3       4     ???
```

âœ“ TIáº¾T KIá»†M MEMORY:
```cpp
class Good {
    int b;     // 4 bytes
    int d;     // 4 bytes
    char a;    // 1 byte
    char c;    // 1 byte
    // 2 bytes padding cuá»‘i
};

sizeof(Good) = 12

Memory layout:
â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚   b   â”‚   d   â”‚a â”‚c â”‚ pad â”‚
â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
   4       4     1  1   2
```

BEST PRACTICE:
âœ“ Sáº¯p xáº¿p members theo size giáº£m dáº§n
âœ“ Group members cÃ¹ng type
âœ“ Giáº£m padding â†’ Giáº£m memory

3.7. SIZEOF Vá»šI EMPTY CLASS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Empty class (khÃ´ng cÃ³ members) váº«n cÃ³ size = 1 byte.

VÃ Dá»¤:
    class Empty {};
    cout << sizeof(Empty);  // 1 (khÃ´ng pháº£i 0!)

LÃ DO:
- Má»—i object cáº§n má»™t Ä‘á»‹a chá»‰ RIÃŠNG BIá»†T
- Náº¿u size = 0 â†’ khÃ´ng thá»ƒ phÃ¢n biá»‡t objects
- C++ standard quy Ä‘á»‹nh minimum size = 1 byte

VÃ Dá»¤ MINH Há»ŒA:
```cpp
class Empty {};

int main() {
    Empty e1, e2, e3;
    
    cout << &e1 << endl;  // 0x7ffd5b2c3e4c
    cout << &e2 << endl;  // 0x7ffd5b2c3e4d (khÃ¡c e1)
    cout << &e3 << endl;  // 0x7ffd5b2c3e4e (khÃ¡c e1, e2)
    
    // Náº¿u sizeof = 0 â†’ khÃ´ng thá»ƒ cÃ³ Ä‘á»‹a chá»‰ khÃ¡c nhau!
}
```

Vá»šI ARRAY:
    Empty arr[10];
    cout << sizeof(arr);  // 10 (10 * 1)

3.8. SIZEOF Vá»šI INHERITANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

VÃ Dá»¤ CÆ  Báº¢N:
```cpp
class Base {
    int x;  // 4 bytes
};

class Derived : public Base {
    int y;  // 4 bytes
};

cout << sizeof(Base);     // 4
cout << sizeof(Derived);  // 8 (4 cá»§a Base + 4 cá»§a Derived)
```

Vá»šI VIRTUAL FUNCTION:
```cpp
class Base {
    int x;  // 4 bytes
public:
    virtual void func() {}  // ThÃªm vptr (4/8 bytes)
};

cout << sizeof(Base);  // 12 (32-bit) hoáº·c 16 (64-bit)
// 4 (x) + 4/8 (vptr) + padding

Memory layout:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ vptr       â”‚    x     â”‚ padding â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  4/8 bytes    4 bytes    0-4 bytes
```

MULTIPLE INHERITANCE:
```cpp
class A {
    int a;  // 4 bytes
};

class B {
    int b;  // 4 bytes
};

class C : public A, public B {
    int c;  // 4 bytes
};

cout << sizeof(A);  // 4
cout << sizeof(B);  // 4
cout << sizeof(C);  // 12 (4 + 4 + 4)
```

Vá»šI VIRTUAL INHERITANCE:
```cpp
class Base {
    int x;  // 4 bytes
};

class A : virtual public Base {
    int a;  // 4 bytes
    // + vptr cho virtual base
};

cout << sizeof(A);  // 12-16 (tÃ¹y compiler)
// CÃ³ thÃªm vptr Ä‘á»ƒ manage virtual base
```

3.9. TÃ“M Táº®T QUAN TRá»ŒNG
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CHECKLIST SIZEOF:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â–¡ sizeof KHÃ”NG cÃ³ side effects - KHÃ”NG evaluate expression
â–¡ sizeof(array) trong function = sizeof(pointer) (array decay)
â–¡ sizeof(pointer) = 4 (32-bit) hoáº·c 8 (64-bit)
â–¡ sizeof(class) bao gá»“m padding
â–¡ sizeof(Empty class) = 1
â–¡ Virtual function thÃªm vptr (4/8 bytes)
â–¡ sizeof lÃ  compile-time operator
â–¡ Return type lÃ  size_t

COMMON VALUES:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•
char        : 1 byte
short       : 2 bytes
int         : 4 bytes
long        : 4 or 8 bytes
long long   : 8 bytes
float       : 4 bytes
double      : 8 bytes
pointer     : 4 (32-bit) or 8 (64-bit)
bool        : 1 byte
Empty class : 1 byte

TIPS:
â•â•â•â•â•
âœ“ TÃ­nh array length: sizeof(arr) / sizeof(arr[0])
âœ“ Truyá»n size khi pass array vÃ o function
âœ“ Sáº¯p xáº¿p class members Ä‘á»ƒ giáº£m padding
âœ“ Nhá»› array decay thÃ nh pointer
âœ“ sizeof khÃ´ng bao giá» cÃ³ side effects!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ TÃ i liá»‡u nÃ y sáº½ Ä‘Æ°á»£c tiáº¿p tá»¥c vá»›i cÃ¡c chapters cÃ²n láº¡i...
ğŸ’¡ Má»—i chapter theo format: KhÃ¡i niá»‡m â†’ LÆ°u Ã½ â†’ Code thá»±c táº¿ â†’ Lá»—i thÆ°á»ng gáº·p
ğŸ“– Tá»•ng sá»‘ ~300+ trang vá»›i vÃ­ dá»¥ chi tiáº¿t tá»« táº¥t cáº£ cÃ¡c file test

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
