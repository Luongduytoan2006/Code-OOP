================================================================================
                    TÃ€I LIá»†U Ã”N Táº¬P OOP - TEST 2
         OPERATOR OVERLOADING & FUNCTION OVERLOADING
================================================================================

Má»¤C Lá»¤C:
1. OPERATOR OVERLOADING (Náº P CHá»’NG TOÃN Tá»¬)
2. FUNCTION OVERLOADING
3. FRIEND FUNCTION
4. SPECIAL MEMBER FUNCTIONS
5. STATIC MEMBERS
6. CONST-CORRECTNESS
7. CÃC Lá»–I THÆ¯á»œNG Gáº¶P
8. TIPS & TRICKS

================================================================================
1. OPERATOR OVERLOADING (Náº P CHá»’NG TOÃN Tá»¬)
================================================================================

1.1. KHÃI NIá»†M CÆ  Báº¢N
----------------------
Operator Overloading cho phÃ©p Ä‘á»‹nh nghÄ©a láº¡i cÃ¡ch hoáº¡t Ä‘á»™ng cá»§a toÃ¡n tá»­ 
vá»›i cÃ¡c kiá»ƒu dá»¯ liá»‡u ngÆ°á»i dÃ¹ng tá»± Ä‘á»‹nh nghÄ©a (class).

VÃ Dá»¤:
    Complex c1(1, 2), c2(3, 4);
    Complex c3 = c1 + c2;  // DÃ¹ng operator+ Ä‘Ã£ overload

Má»¤C ÄÃCH:
- LÃ m code dá»… Ä‘á»c, tá»± nhiÃªn hÆ¡n
- Táº­n dá»¥ng cÃº phÃ¡p cÃ³ sáºµn cá»§a C++
- Táº¡o sá»± nháº¥t quÃ¡n vá»›i built-in types

1.2. MEMBER FUNCTION vs FRIEND FUNCTION
----------------------------------------

a) MEMBER FUNCTION (HÃ m thÃ nh viÃªn):
    class Complex {
    public:
        Complex operator+(const Complex& other) const {
            return Complex(R + other.R, I + other.I);
        }
    };
    
    // Sá»­ dá»¥ng: c3 = c1 + c2;
    // TÆ°Æ¡ng Ä‘Æ°Æ¡ng: c3 = c1.operator+(c2);

b) FRIEND FUNCTION (HÃ m báº¡n):
    class Complex {
        friend Complex operator+(const Complex& a, const Complex& b) {
            return Complex(a.R + b.R, a.I + b.I);
        }
    };
    
    // Sá»­ dá»¥ng: c3 = c1 + c2;
    // TÆ°Æ¡ng Ä‘Æ°Æ¡ng: c3 = operator+(c1, c2);

PHÃ‚N BIá»†T:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 â”‚ Member Function  â”‚ Friend Function  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sá»‘ tham sá»‘      â”‚ 1 (bÃªn pháº£i)     â”‚ 2 (cáº£ 2 toÃ¡n háº¡ng)â”‚
â”‚ Truy cáº­p this   â”‚ CÃ³               â”‚ KhÃ´ng            â”‚
â”‚ CÃº phÃ¡p gá»i     â”‚ obj.operator+()  â”‚ operator+()      â”‚
â”‚ DÃ¹ng khi        â”‚ a op b           â”‚ Linh hoáº¡t hÆ¡n    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1.3. CÃC TOÃN Tá»¬ THÆ¯á»œNG Gáº¶P
----------------------------

A) TOÃN Tá»¬ Sá» Há»ŒC (+, -, *, /)
-------------------------------
VÃ Dá»¤ Tá»ª TEST (on_15.cpp):

    class Exam {
        int x, y, z;
    public:
        Exam(int a, int b, int c) : x(a), y(b), z(c) {}
        
        // Overload operator+
        Exam operator+(const Exam& obj) const {
            return Exam(x + obj.x, y + obj.y, z + obj.z);
        }
    };
    
    int main() {
        Exam e1(1, 2, 3), e2(10, 20, 30);
        Exam e3 = e1 + e2;  // (11, 22, 33)
    }

Äáº¶C ÄIá»‚M:
âœ“ TRáº¢ Vá»€ BY VALUE (táº¡o object má»›i)
âœ“ CONST MEMBER FUNCTION (khÃ´ng thay Ä‘á»•i object)
âœ“ Tham sá»‘ const reference

B) TOÃN Tá»¬ PHá»¨C Há»¢P (+=, -=, *=, /=)
-------------------------------------
VÃ Dá»¤ Tá»ª TEST (on_20.cpp):

    class Exam {
        int val;
    public:
        // operator+= TRáº¢ Vá»€ REFERENCE
        Exam& operator+=(const Exam& obj) {
            val += obj.val;
            return *this;  // Tráº£ vá» chÃ­nh object nÃ y
        }
        
        // operator+ dÃ¹ng +=
        Exam operator+(const Exam& obj) const {
            Exam temp = *this;
            temp += obj;
            return temp;
        }
    };

QUAN TRá»ŒNG:
âœ“ TRáº¢ Vá»€ REFERENCE (*this) Ä‘á»ƒ cho phÃ©p chain: a += b += c;
âœ“ KHÃ”NG CONST (vÃ¬ thay Ä‘á»•i object)
âœ“ CÃ³ thá»ƒ dÃ¹ng += Ä‘á»ƒ implement +

C) TOÃN Tá»¬ XUáº¤T NHáº¬P (<<, >>)
-------------------------------
VÃ Dá»¤ Tá»ª TEST (on_18.cpp):

    class Exam {
        int val;
    public:
        // PHáº¢I LÃ€ FRIEND FUNCTION
        friend ostream& operator<<(ostream& os, const Exam& obj) {
            os << obj.val;
            return os;  // Tráº£ vá» stream Ä‘á»ƒ chain
        }
        
        friend istream& operator>>(istream& is, Exam& obj) {
            is >> obj.val;
            return is;
        }
    };
    
    int main() {
        Exam e;
        cin >> e;
        cout << e << endl;  // Chain Ä‘Æ°á»£c
    }

Táº I SAO PHáº¢I LÃ€ FRIEND?
- ToÃ¡n háº¡ng bÃªn trÃ¡i lÃ  stream (ostream, istream)
- KhÃ´ng thá»ƒ lÃ m member function cá»§a class riÃªng
- Cáº§n truy cáº­p private members

D) TOÃN Tá»¬ SUBSCRIPT ([])
--------------------------
VÃ Dá»¤ Tá»ª TEST (on_24.cpp):

    class Array {
        int data[10];
        static int temp;  // DÃ¹ng khi out-of-bounds
    public:
        // Tráº£ vá» REFERENCE Ä‘á»ƒ cÃ³ thá»ƒ gÃ¡n
        int& operator[](int index) {
            if (index >= 0 && index < 10)
                return data[index];
            return temp;  // Out of bounds
        }
    };
    
    int main() {
        Array arr;
        arr[0] = 5;  // GÃ¡n Ä‘Æ°á»£c vÃ¬ tráº£ vá» reference
        cout << arr[0];  // 5
        arr[100] = 10;   // Out-of-bounds â†’ gÃ¡n vÃ o temp
    }

QUAN TRá»ŒNG:
âœ“ TRáº¢ Vá»€ REFERENCE Ä‘á»ƒ cÃ³ thá»ƒ gÃ¡n giÃ¡ trá»‹
âœ“ PHáº¢I LÃ€ MEMBER FUNCTION (khÃ´ng thá»ƒ friend)
âœ“ Xá»­ lÃ½ out-of-bounds

E) TOÃN Tá»¬ Gá»ŒI HÃ€M (())
------------------------
VÃ Dá»¤ Tá»ª TEST (on_3.cpp):

    class Functor {
        int base;
    public:
        Functor(int b) : base(b) {}
        
        // Overload operator() - Function call
        int operator()(int x) const {
            return base + x;
        }
    };
    
    int main() {
        Functor add5(5);
        cout << add5(10);  // 15 (5 + 10)
    }

á»¨NG Dá»¤NG:
- Táº¡o function objects (functors)
- DÃ¹ng trong STL algorithms
- Callback functions

F) TOÃN Tá»¬ Dáº¤U PHáº¨Y (,)
------------------------
VÃ Dá»¤ Tá»ª TEST (on_5.cpp):

    class Base {
    public:
        friend int operator,(Base& obj, int x) {
            return x;  // Tráº£ vá» toÃ¡n háº¡ng pháº£i
        }
    };
    
    int main() {
        Base obj;
        cout << (obj, 5);  // 5
    }

LÆ¯U Ã:
- Ãt dÃ¹ng trong thá»±c táº¿
- CÃ³ thá»ƒ gÃ¢y confuse
- ThÆ°á»ng dÃ¹ng cho má»¥c Ä‘Ã­ch Ä‘áº·c biá»‡t

G) TOÃN Tá»¬ CHUYá»‚N Äá»”I KIá»‚U
---------------------------
VÃ Dá»¤ Tá»ª TEST (on_26.cpp):

    class Exam {
        int val;
    public:
        Exam(int v) : val(v) {}
        
        // Chuyá»ƒn Ä‘á»•i sang double
        operator double() const {
            return static_cast<double>(val);
        }
        
        // Chuyá»ƒn Ä‘á»•i sang int
        operator int() const {
            return val;
        }
    };
    
    int main() {
        Exam e(10);
        double d = e;  // Gá»i operator double()
        int i = e;     // Gá»i operator int()
    }

1.4. CÃC TOÃN Tá»¬ Äáº¶C BIá»†T
--------------------------

A) TOÃN Tá»¬ NEW VÃ€ DELETE
-------------------------
VÃ Dá»¤ Tá»ª TEST (on_13.cpp):

    class Base {
    public:
        // Overload operator new
        void* operator new(size_t size) {
            cout << "New.";
            void* storage = malloc(size);
            if (!storage) throw bad_alloc();
            return storage;
        }
        
        // Overload operator delete
        void operator delete(void* ptr) {
            cout << "Delete.";
            free(ptr);
        }
    };
    
    int main() {
        Base* ptr = new Base;  // New.Constructor.
        delete ptr;            // Destructor.Delete.
    }

á»¨NG Dá»¤NG:
- Memory pool
- Debugging memory leaks
- Custom memory management

B) ASSIGNMENT OPERATOR (=)
---------------------------
VÃ Dá»¤ Tá»ª TEST (on_8.cpp):

    class Exam {
        int val;
    public:
        // Copy constructor
        Exam(const Exam& other) : val(other.val) {
            cout << "Copy";
        }
        
        // Assignment operator
        Exam& operator=(const Exam& other) {
            if (this != &other) {  // Kiá»ƒm tra self-assignment
                val = other.val;
            }
            return *this;
        }
    };

QUAN TRá»ŒNG:
âœ“ Kiá»ƒm tra self-assignment: if (this != &other)
âœ“ Tráº£ vá» *this by reference
âœ“ PHáº¢I LÃ€ MEMBER FUNCTION

1.5. QUY Táº®C OVERLOADING
-------------------------

CÃC TOÃN Tá»¬ PHáº¢I LÃ€ MEMBER FUNCTION:
- = (assignment)
- [] (subscript)
- () (function call)
- -> (member access)

CÃC TOÃN Tá»¬ NÃŠN LÃ€ FRIEND FUNCTION:
- << vÃ  >> (stream operators)
- Binary operators khi cáº§n symmetry: a + b vÃ  b + a

KHÃ”NG THá»‚ OVERLOAD:
- . (member access)
- .* (pointer to member)
- :: (scope resolution)
- ?: (ternary conditional)
- sizeof
- typeid

================================================================================
2. FUNCTION OVERLOADING
================================================================================

2.1. KHÃI NIá»†M
--------------
Function Overloading cho phÃ©p nhiá»u hÃ m cÃ¹ng tÃªn nhÆ°ng khÃ¡c tham sá»‘.

CÃš PHÃP:
    int add(int a, int b);
    double add(double a, double b);
    int add(int a, int b, int c);

2.2. OVERLOAD RESOLUTION
------------------------
Compiler chá»n hÃ m dá»±a vÃ o:
1. Khá»›p chÃ­nh xÃ¡c (exact match)
2. Type promotion (int â†’ long)
3. Type conversion (int â†’ double)

VÃ Dá»¤ Tá»ª TEST (on_16.cpp):

    int Func(int x, int y) {
        return x * y;
    }
    
    int Func(int x, int y, int z) {
        return x * y * z;
    }
    
    int Func(double x) {
        return x * 2;
    }
    
    int main() {
        Func(6, 10);      // Gá»i Func(int, int) â†’ 60
        Func(6, 10, 3);   // Gá»i Func(int, int, int) â†’ 180
        Func(6.0);        // Gá»i Func(double) â†’ 12
    }

2.3. AMBIGUITY (NHáº¬P NHáº°NG)
----------------------------
VÃ Dá»¤ Tá»ª TEST (on_1.cpp):

    int Func(int a, int b);
    int Func(int a, int b, int c = 6);  // Default parameter
    
    int main() {
        Func(2, 4);  // COMPILE ERROR! Ambiguous
        // Cáº£ 2 hÃ m Ä‘á»u khá»›p
    }

QUY Táº®C:
âŒ TrÃ¡nh overload khi cÃ³ default parameters trÃ¹ng láº·p
âŒ TrÃ¡nh implicit conversion gÃ¢y nháº­p nháº±ng

2.4. DEFAULT PARAMETERS
-----------------------
    void Func(int x, int y = 10, int z = 5);
    
    Func(1);        // x=1, y=10, z=5
    Func(1, 2);     // x=1, y=2, z=5
    Func(1, 2, 3);  // x=1, y=2, z=3

QUY Táº®C:
âœ“ Default parameters pháº£i á»Ÿ cuá»‘i
âœ“ KhÃ´ng thá»ƒ bá» qua tham sá»‘ á»Ÿ giá»¯a

================================================================================
3. FRIEND FUNCTION
================================================================================

3.1. KHÃI NIá»†M
--------------
Friend function cÃ³ quyá»n truy cáº­p private/protected members cá»§a class.

CÃš PHÃP:
    class MyClass {
        int secret;
        friend void showSecret(const MyClass& obj);
    };
    
    void showSecret(const MyClass& obj) {
        cout << obj.secret;  // OK: friend cÃ³ quyá»n truy cáº­p
    }

3.2. OPERATOR<< Vá»šI FRIEND
---------------------------
VÃ Dá»¤:
    class Complex {
        double R, I;
    public:
        friend ostream& operator<<(ostream& os, const Complex& c) {
            return os << c.R << " + " << c.I << "i";
        }
    };

Táº I SAO Cáº¦N FRIEND?
- ToÃ¡n háº¡ng trÃ¡i lÃ  ostream (khÃ´ng pháº£i Complex)
- KhÃ´ng thá»ƒ lÃ m member cá»§a Complex
- Cáº§n truy cáº­p private members (R, I)

3.3. QUY Táº®C FRIEND
-------------------
âœ“ Khai bÃ¡o friend TRONG class definition
âœ“ Äá»‹nh nghÄ©a cÃ³ thá»ƒ trong hoáº·c ngoÃ i class
âœ“ Friend khÃ´ng pháº£i member â†’ KhÃ´ng cÃ³ this
âœ“ Friend phÃ¡ vá»¡ encapsulation â†’ DÃ¹ng cáº©n tháº­n

================================================================================
4. SPECIAL MEMBER FUNCTIONS
================================================================================

4.1. CONSTRUCTOR
----------------
    class Exam {
    public:
        Exam();                    // Default constructor
        Exam(int x);               // Parameterized constructor
        Exam(const Exam& other);   // Copy constructor
    };

4.2. COPY CONSTRUCTOR
---------------------
VÃ Dá»¤ Tá»ª TEST (on_8.cpp):

    class Exam {
        int val;
    public:
        Exam(int v) : val(v) {
            cout << v;
        }
        
        Exam(const Exam& other) : val(other.val) {
            cout << val;
        }
    };
    
    Exam Func(Exam obj) {  // Copy khi truyá»n vÃ o
        Exam temp(3);
        return temp;       // Copy khi return (cÃ³ thá»ƒ RVO)
    }
    
    int main() {
        Exam obj(1);       // 1
        obj = Func(obj);   // Copy obj â†’ 1, táº¡o temp â†’ 3
        // Káº¿t quáº£: 113
    }

KHI NÃ€O Gá»ŒI COPY CONSTRUCTOR?
- Truyá»n tham sá»‘ by value
- Return by value (náº¿u khÃ´ng RVO)
- Khá»Ÿi táº¡o: Exam e2 = e1;

4.3. ASSIGNMENT OPERATOR
------------------------
    Exam& operator=(const Exam& other) {
        if (this != &other) {  // TrÃ¡nh self-assignment
            val = other.val;
        }
        return *this;
    }

PHÃ‚N BIá»†T COPY VS ASSIGNMENT:
    Exam e2 = e1;    // Copy constructor
    Exam e3;
    e3 = e1;         // Assignment operator

4.4. DESTRUCTOR
---------------
    ~Exam() {
        // Giáº£i phÃ³ng tÃ i nguyÃªn
    }

VÃ Dá»¤ Tá»ª TEST (on_2.cpp):

    class ExamA {
    public:
        virtual ~ExamA() {
            cout << "~ExamA";
        }
    };
    
    class Derived : public ExamA {
    public:
        ~Derived() {
            cout << "~Derived";
        }
    };
    
    int main() {
        ExamA* ptr = new Derived;
        delete ptr;  // ~Derived~ExamA (vÃ¬ virtual)
    }

================================================================================
5. STATIC MEMBERS
================================================================================

5.1. STATIC DATA MEMBER
-----------------------
VÃ Dá»¤ Tá»ª TEST (on_21.cpp):

    class Exam {
        static int count;  // Khai bÃ¡o
    public:
        Exam() { ++count; }
        ~Exam() { --count; }
        static int getCount() { return count; }
    };
    
    // Äá»‹nh nghÄ©a ngoÃ i class
    int Exam::count = 0;
    
    int main() {
        Exam e1, e2;
        cout << Exam::count;  // 2
    }

Äáº¶C ÄIá»‚M:
- Shared giá»¯a táº¥t cáº£ objects
- Pháº£i Ä‘á»‹nh nghÄ©a ngoÃ i class
- Truy cáº­p qua ClassName::member

5.2. STATIC MEMBER FUNCTION
----------------------------
    class Exam {
        static int val;
    public:
        static int getVal() {
            return val;  // Chá»‰ truy cáº­p static members
        }
    };
    
    // Gá»i khÃ´ng cáº§n object
    cout << Exam::getVal();

================================================================================
6. CONST-CORRECTNESS
================================================================================

6.1. CONST MEMBER FUNCTION
--------------------------
    class Exam {
        int val;
    public:
        int getVal() const {  // KhÃ´ng thay Ä‘á»•i object
            return val;
        }
        
        void setVal(int v) {  // Thay Ä‘á»•i object â†’ khÃ´ng const
            val = v;
        }
    };

6.2. CONST PARAMETERS
---------------------
    // Tham sá»‘ khÃ´ng Ä‘á»•i
    int add(const int& a, const int& b) {
        return a + b;
    }

6.3. CONST RETURN TYPE
----------------------
    const Exam& getMax(const Exam& a, const Exam& b) const {
        return (a > b) ? a : b;
    }

QUY Táº®C:
âœ“ HÃ m khÃ´ng thay Ä‘á»•i object â†’ const member function
âœ“ Tham sá»‘ khÃ´ng thay Ä‘á»•i â†’ const reference
âœ“ Return reference khÃ´ng muá»‘n thay Ä‘á»•i â†’ const reference

================================================================================
7. CÃC Lá»–I THÆ¯á»œNG Gáº¶P
================================================================================

7.1. RETURN TYPE SAI
--------------------
âŒ SAI:
    void operator+=(const Exam& obj) {
        val += obj.val;
    }

âœ“ ÄÃšNG:
    Exam& operator+=(const Exam& obj) {
        val += obj.val;
        return *this;  // Cho phÃ©p chain: a += b += c
    }

7.2. QUÃŠN CONST-CORRECTNESS
---------------------------
âŒ SAI:
    bool operator==(const Exam& other) {
        return val == other.val;
    }

âœ“ ÄÃšNG:
    bool operator==(const Exam& other) const {
        return val == other.val;
    }

7.3. FRIEND VS MEMBER CONFUSION
-------------------------------
âŒ SAI:
    class Exam {
        // operator<< pháº£i lÃ  friend
        ostream& operator<<(ostream& os) {
            return os << val;
        }
    };

âœ“ ÄÃšNG:
    class Exam {
        friend ostream& operator<<(ostream& os, const Exam& obj) {
            return os << obj.val;
        }
    };

7.4. SELF-ASSIGNMENT
--------------------
âŒ SAI:
    Exam& operator=(const Exam& other) {
        delete[] data;
        data = new int[other.size];
        // Náº¿u this == &other â†’ data Ä‘Ã£ bá»‹ delete
    }

âœ“ ÄÃšNG:
    Exam& operator=(const Exam& other) {
        if (this != &other) {  // Kiá»ƒm tra trÆ°á»›c
            delete[] data;
            data = new int[other.size];
        }
        return *this;
    }

7.5. OPERATOR[] RETURN TYPE
---------------------------
âŒ SAI:
    int operator[](int index) {
        return data[index];  // Return by value â†’ khÃ´ng gÃ¡n Ä‘Æ°á»£c
    }

âœ“ ÄÃšNG:
    int& operator[](int index) {
        return data[index];  // Return reference â†’ gÃ¡n Ä‘Æ°á»£c
    }

7.6. AMBIGUITY Vá»šI DEFAULT PARAMETERS
--------------------------------------
âŒ SAI:
    int Func(int x, int y);
    int Func(int x, int y, int z = 5);
    Func(1, 2);  // COMPILE ERROR! Ambiguous

âœ“ Sá»¬A:
    int Func(int x, int y);
    int Func(int x, int y, int z);  // KhÃ´ng dÃ¹ng default

7.7. MEMORY MANAGEMENT
----------------------
âŒ SAI:
    void* operator new(size_t size) {
        return malloc(size);  // KhÃ´ng check null
    }

âœ“ ÄÃšNG:
    void* operator new(size_t size) {
        void* ptr = malloc(size);
        if (!ptr) throw bad_alloc();
        return ptr;
    }

================================================================================
8. TIPS & TRICKS
================================================================================

8.1. Báº¢NG Tá»”NG Há»¢P OPERATORS
-----------------------------
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ToÃ¡n tá»­        â”‚ Member?  â”‚ Return     â”‚ Const?      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ +, -, *, /     â”‚ M hoáº·c F â”‚ By value   â”‚ const       â”‚
â”‚ +=, -=, *=, /= â”‚ M        â”‚ Reference  â”‚ non-const   â”‚
â”‚ ==, !=, <, >   â”‚ M hoáº·c F â”‚ bool       â”‚ const       â”‚
â”‚ <<, >>         â”‚ Friend   â”‚ stream&    â”‚ const param â”‚
â”‚ []             â”‚ Member   â”‚ Reference  â”‚ 2 versions  â”‚
â”‚ ()             â”‚ Member   â”‚ TÃ¹y Ã½      â”‚ TÃ¹y Ã½       â”‚
â”‚ =              â”‚ Member   â”‚ Reference  â”‚ non-const   â”‚
â”‚ new, delete    â”‚ Static M â”‚ void*      â”‚ N/A         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8.2. CHECKLIST KHI OVERLOAD
----------------------------
â–¡ Member hay Friend function?
â–¡ Return type Ä‘Ãºng chÆ°a? (value, reference, stream&)
â–¡ Const correctness? (tham sá»‘ vÃ  hÃ m)
â–¡ Self-assignment check? (vá»›i operator=)
â–¡ Bounds checking? (vá»›i operator[])
â–¡ Exception handling? (vá»›i new)
â–¡ Symmetry? (a+b vÃ  b+a Ä‘á»u hoáº¡t Ä‘á»™ng)

8.3. PATTERN THÆ¯á»œNG DÃ™NG
-------------------------

PATTERN 1: Arithmetic Operators
    Exam operator+(const Exam& obj) const {
        return Exam(val + obj.val);
    }

PATTERN 2: Compound Assignment
    Exam& operator+=(const Exam& obj) {
        val += obj.val;
        return *this;
    }

PATTERN 3: Stream Operators
    friend ostream& operator<<(ostream& os, const Exam& obj) {
        return os << obj.val;
    }

PATTERN 4: Comparison
    bool operator<(const Exam& obj) const {
        return val < obj.val;
    }

PATTERN 5: Subscript
    T& operator[](size_t index) {
        return data[index];
    }
    const T& operator[](size_t index) const {
        return data[index];
    }

8.4. BEST PRACTICES
-------------------
âœ“ DÃ¹ng const reference cho parameters lá»›n
âœ“ Return reference tá»« +=, -=, *= Ä‘á»ƒ chain
âœ“ Return by value tá»« +, -, * (táº¡o object má»›i)
âœ“ Kiá»ƒm tra self-assignment trong operator=
âœ“ Virtual destructor khi cÃ³ polymorphism
âœ“ Implement operator+ báº±ng operator+=
âœ“ Implement comparison operators (<, ==) rá»“i dÃ¹ng cho cÃ¡c toÃ¡n tá»­ khÃ¡c

8.5. CÃ”NG THá»¨C NHANH
--------------------
â€¢ operator+ â†’ return by value, const function
â€¢ operator+= â†’ return *this by reference, non-const
â€¢ operator<< â†’ friend function, return ostream&
â€¢ operator[] â†’ return reference, 2 versions (const/non-const)
â€¢ operator= â†’ member only, check self-assignment, return *this
â€¢ operator() â†’ member only, functor pattern

================================================================================
Káº¾T LUáº¬N
================================================================================

TEST 2 Táº¬P TRUNG VÃ€O:
âœ… Operator Overloading (90%)
âœ… Function Overloading (5%)
âœ… Friend Function (5%)

ÄIá»‚M THEN CHá»T Cáº¦N NHá»š:
1. PhÃ¢n biá»‡t Member vs Friend function
2. Return type Ä‘Ãºng (value, reference, stream)
3. Const-correctness (tham sá»‘ vÃ  hÃ m)
4. Self-assignment check
5. Virtual destructor vá»›i polymorphism

CÃC TOÃN Tá»¬ QUAN TRá»ŒNG:
- Arithmetic: +, +=
- Stream: <<, >>
- Subscript: []
- Function call: ()
- Assignment: =
- Memory: new, delete

LUYá»†N Táº¬P:
- Viáº¿t class vá»›i Ä‘áº§y Ä‘á»§ operators
- PhÃ¢n biá»‡t khi nÃ o dÃ¹ng member/friend
- Thá»±c hÃ nh const-correctness
- Debug ambiguity errors

CHÃšC Báº N Ã”N Táº¬P Tá»T VÃ€ Äáº T ÄIá»‚M CAO! ğŸš€
